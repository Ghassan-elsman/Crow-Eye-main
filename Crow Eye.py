# type: ignore
# pylint: disable-all
# Form implementation generated from reading ui file 'Crow Eye v14.ui'
# Do not edit this file unless you know what you are doing.

"""
Crow Eye - Windows Forensic Investigation Tool
===========================================

Crow Eye is an open-source Windows forensic investigation tool designed to collect,
analyze, and correlate forensic artifacts from Windows systems. It provides a
comprehensive GUI interface for forensic investigators to examine evidence of
program execution, system activity, and potential malicious behavior.

Key Features:
- Collection and parsing of multiple Windows forensic artifacts:
  * Prefetch files (.pf)
  * Amcache Registry hive
  * Shimcache (AppCompatCache)
  * Registry hives
  * Event logs
  * MFT
  * USN
  * Recycle bin
  
  * And more




Forensic Value:
- Provides investigators with a unified interface for Windows artifact analysis
- Correlates evidence across multiple sources for stronger conclusions
- Helps identify suspicious activity through anomaly detection
- Supports both live system analysis and offline forensic image examination

Author: Ghassan Elsman
Version: 0.3
License: GPL-3.0
"""

import venv
import os
import subprocess
import sys
import ctypes
import collections

def is_admin():
    """Check if the current process has administrator privileges.
    
    This function uses the Windows API to determine if the current process
    is running with administrator privileges, which are required for accessing
    many forensic artifacts and system resources.
    
    Returns:
        bool: True if running as administrator, False otherwise
    """
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

# Ensure the tool runs with administrator privileges on Windows
if os.name == 'nt':  # Check if running on Windows
    if not is_admin():
        print("This script requires administrator privileges to run. Please run as administrator.")
        # Re-run the script with admin privileges using ShellExecuteW with 'runas' verb
        try:
            script = os.path.abspath(sys.argv[0])  # Get absolute path to script
            # Properly handle command line arguments with spaces
            params = ' '.join([f'\"' + p + '\"' for p in sys.argv[1:]])
            # Use ShellExecuteW to prompt for UAC elevation
            ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, script, params, 1)
        except Exception as e:
            print(f"Failed to re-run as administrator: {e}")
        sys.exit(1)  # Exit the non-elevated process
else:
    print("This script is designed to run on Windows only.")
    

def install_initial_requirements():
    """Install essential packages required before the main dependency installation.
    
    This function ensures that critical base packages (colorama for colored console output
    and setuptools for package management) are installed before attempting to set up the
    virtual environment or install other dependencies. These packages are prerequisites
    for the proper functioning of the dependency management system.
    
    The function will exit the program if installation fails, as these packages are
    essential for the tool's operation.
    
    Returns:
        None: Function exits the program if installation fails
    """
    initial_requirements = ['colorama', 'setuptools']
    
    for package in initial_requirements:
        try:
            subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])
            print(f'Successfully installed {package}')
        except subprocess.CalledProcessError:
            print(f'Failed to install {package}')
            sys.exit(1)  # Exit if essential packages cannot be installed

# Install initial requirements first
install_initial_requirements()

# Now we can safely import these
from colorama import init, Fore
import importlib.metadata

def setup_virtual_environment():
    """Create and activate a virtual environment for Crow Eye.
    
    This function manages the creation, validation, and activation of a Python virtual
    environment for Crow Eye. Using a virtual environment ensures that the tool has all
    required dependencies isolated from the system Python installation, preventing
    conflicts and ensuring consistent behavior.
    
    Key features:
    - Checks if already running in a virtual environment
    - Creates a new virtual environment if one doesn't exist
    - Handles path issues with spaces and special characters
    - Restarts the application within the virtual environment
    - Falls back to system Python if virtual environment creation fails
    
    Forensic significance:
    - Ensures consistent dependency versions for reliable artifact parsing
    - Prevents conflicts with system Python packages
    - Maintains tool integrity across different Windows installations
    """
    
    init()  # Initialize colorama
    
    # Check if already in virtual environment
    if hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):
        print(Fore.GREEN + 'Already running in virtual environment' + Fore.RESET)
        return
    
    venv_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'crow_eye_venv')
    
    # Create virtual environment if it doesn't exist
    if not os.path.exists(venv_path):
        print('Creating virtual environment...')
        try:
            venv.create(venv_path, with_pip=True)
            print(Fore.GREEN + f'Virtual environment created at {venv_path}' + Fore.RESET)
        except Exception as e:
            print(Fore.RED + f'Failed to create virtual environment: {str(e)}' + Fore.RESET)
            print(Fore.RED + 'Please check disk space and permissions' + Fore.RESET)
            input('Press Enter to continue with global Python environment...')
            return
    else:
        print(Fore.GREEN + 'Virtual environment already exists' + Fore.RESET)

    # Restart the script with the virtual environment's Python executable
    try:
        if os.name == 'nt':  # Windows
            venv_python = os.path.join(venv_path, 'Scripts', 'python.exe')
        else:  # Unix-like
            venv_python = os.path.join(venv_path, 'bin', 'python')
        
        if os.path.exists(venv_python):
            print(Fore.GREEN + 'Restarting with virtual environment...' + Fore.RESET)
            # Restart the script using the virtual environment's Python
            # Use subprocess.Popen instead of os.execv to handle paths with spaces and special characters

            script_path = os.path.abspath(sys.argv[0])
            subprocess.Popen([venv_python, script_path] + sys.argv[1:], shell=False)
            sys.exit(0)  # Exit current process after starting the new one
        else:
            print(Fore.RED + f'Virtual environment Python not found at {venv_python}' + Fore.RESET)
            input('Press Enter to continue with global Python environment...')
    except Exception as e:
        print(Fore.RED + f'Failed to restart with virtual environment: {str(e)}' + Fore.RESET)
        input('Press Enter to continue with global Python environment...')

# Setup virtual environment
setup_virtual_environment()

Crow_Eye_Requirements = [
    'PyQt5',
    'python-registry',
    'pywin32',
    'pandas',
    'streamlit',
    'altair',
    'olefile',
    'windowsprefetch',
    'psutil',
    'tqdm',
    'colorama',
    'wmi'
]

def check_and_install_requirements():
    """Check and install required packages for Crow Eye application."""
    def install_package(package):
        try:
            subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])
            print(Fore.GREEN + f'Successfully installed {package}' + Fore.RESET)
            return True
        except subprocess.CalledProcessError:
            print(Fore.RED + f'Failed to install {package}' + Fore.RESET)
            return False

    missing_packages = []
    for package in Crow_Eye_Requirements:
        try:
            importlib.metadata.version(package)
            print(Fore.GREEN + f'{package} is already installed' + Fore.RESET)
        except importlib.metadata.PackageNotFoundError:
            print(Fore.RED + f'{package} is not installed' + Fore.RESET)
            missing_packages.append(package)

    if missing_packages:
        print('\nInstalling missing packages...')
        packages_installed = False
        for package in missing_packages:
            if install_package(package):
                packages_installed = True
        
        # If packages were installed, restart the application to ensure proper loading
        if packages_installed:
            print(Fore.YELLOW + '\nPackages installed. Restarting application to ensure proper module registration...' + Fore.RESET)
            # Cross-platform restart mechanism
            if os.name == 'nt':  # Windows
                subprocess.Popen([sys.executable] + sys.argv)
                sys.exit(0)
            else:  # Unix/Linux/Mac
                os.execv(sys.executable, [sys.executable] + sys.argv)
    else:
        print(Fore.GREEN + '\nAll required packages are installed!' + Fore.RESET)

# Check and install required packages
check_and_install_requirements()

# Handle pywin32 post-install if needed
def handle_pywin32_postinstall():
    """Run pywin32 post-install script if win32 modules are not accessible with automatic retry."""
    max_retries = 2
    
    for attempt in range(max_retries):
        try:
            import win32evtlog  # Test if win32 modules are accessible
            print(Fore.GREEN + "win32 modules are accessible" + Fore.RESET)
            return True
        except ImportError:
            if attempt == 0:
                print(Fore.YELLOW + "win32 modules not accessible, running pywin32 post-install..." + Fore.RESET)
            else:
                print(Fore.YELLOW + "win32 modules still not accessible, retrying pywin32 post-install..." + Fore.RESET)
            
            try:
                # Find and run pywin32 post-install script
                scripts_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'crow_eye_venv', 'Scripts')
                postinstall_script = os.path.join(scripts_dir, 'pywin32_postinstall.py')
                
                if os.path.exists(postinstall_script):
                    result = subprocess.run([sys.executable, postinstall_script, '-install'], 
                                          capture_output=True, text=True, cwd=scripts_dir)
                    if result.returncode == 0:
                        print(Fore.GREEN + "pywin32 post-install completed successfully" + Fore.RESET)
                        
                        # Give the system a moment to register the DLLs
                        import time
                        time.sleep(1)
                        
                        # Try to import again after post-install
                        try:
                            import win32evtlog
                            print(Fore.GREEN + "win32 modules now accessible after post-install" + Fore.RESET)
                            return True
                        except ImportError:
                            continue  # Try one more time if still failing
                    else:
                        print(Fore.RED + f"pywin32 post-install failed: {result.stderr}" + Fore.RESET)
                        if attempt == max_retries - 1:
                            return False
                else:
                    print(Fore.YELLOW + "pywin32 post-install script not found" + Fore.RESET)
                    if attempt == max_retries - 1:
                        return False
            except Exception as e:
                print(Fore.RED + f"Failed to run pywin32 post-install: {str(e)}" + Fore.RESET)
                if attempt == max_retries - 1:
                    return False
    
    return False

# Ensure pywin32 modules are accessible
handle_pywin32_postinstall()

# Robust import handling with better error messages
def safe_import(module_name, import_path=None, alias=None):
    """Safely import a module with comprehensive error handling."""
    try:
        if import_path:
            if alias:
                # Import with alias and add to globals
                exec(f"from {import_path} import {module_name} as {alias}", globals())
            else:
                # Import without alias and add to globals
                exec(f"from {import_path} import {module_name}", globals())
        else:
            if alias:
                # Import with alias and add to globals
                exec(f"import {module_name} as {alias}", globals())
            else:
                # Import without alias and add to globals
                exec(f"import {module_name}", globals())
        # Only show errors, not successful imports to reduce verbosity
        return True
    except ImportError as e:
        print(Fore.RED + f"✗ Failed to import {module_name}: {str(e)}" + Fore.RESET)
        print(Fore.YELLOW + f"   Please ensure {module_name} is properly installed" + Fore.RESET)
        return False
    except Exception as e:
        print(Fore.RED + f"✗ Unexpected error importing {module_name}: {str(e)}" + Fore.RESET)
        return False

# Import standard libraries
safe_import('sqlite3')
safe_import('os')
safe_import('subprocess')
safe_import('shutil')
safe_import('sys')
safe_import('json')
safe_import('datetime')

# Import pathlib and add to path
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent))

# Import PyQt5 components with comprehensive error handling
qt5_imports = [
    ('QtCore', 'PyQt5'),
    ('QtGui', 'PyQt5'),
    ('QtWidgets', 'PyQt5'),
    ('QFileDialog', 'PyQt5.QtWidgets'),
    ('QApplication', 'PyQt5.QtWidgets'),
    ('QMainWindow', 'PyQt5.QtWidgets'),
    ('QMessageBox', 'PyQt5.QtWidgets'),
    ('QInputDialog', 'PyQt5.QtWidgets'),
    ('QLineEdit', 'PyQt5.QtWidgets'),
    ('QMovie', 'PyQt5.QtGui'),
    ('QObject', 'PyQt5.QtCore'),
    ('pyqtSignal', 'PyQt5.QtCore'),
    ('Qt', 'PyQt5.QtCore'),
    ('QTimer', 'PyQt5.QtCore'),
    ('QPropertyAnimation', 'PyQt5.QtCore'),
    ('QEasingCurve', 'PyQt5.QtCore'),
    ('QWidget', 'PyQt5.QtWidgets'),
    ('QVBoxLayout', 'PyQt5.QtWidgets'),
    ('QProgressBar', 'PyQt5.QtWidgets'),
    ('QLabel', 'PyQt5.QtWidgets'),
    ('QTextEdit', 'PyQt5.QtWidgets'),
    ('QHBoxLayout', 'PyQt5.QtWidgets'),
    ('QFrame', 'PyQt5.QtWidgets'),
    ('QSplitter', 'PyQt5.QtWidgets'),
    ('QComboBox', 'PyQt5.QtWidgets'),
    ('QCheckBox', 'PyQt5.QtWidgets'),
    ('QFont', 'PyQt5.QtGui'),
    ('QPainter', 'PyQt5.QtGui'),
    ('QColor', 'PyQt5.QtGui')
]

for module_name, import_path in qt5_imports:
    safe_import(module_name, import_path)

# Import custom modules with error handling
try:
    from ui.search_filter_dialog import SearchFilterDialog
    print(Fore.GREEN + "✓ Successfully imported SearchFilterDialog" + Fore.RESET)
except ImportError as e:
    print(Fore.RED + f"✗ Failed to import SearchFilterDialog: {str(e)}" + Fore.RESET)
    # Create a dummy class as fallback
    class SearchFilterDialog:
        def __init__(self, *args, **kwargs):
            pass

# Import Artifacts_Collectors modules with fallback handling
artifact_modules = [
    ('offline_RegClaw', 'Artifacts_Collectors'),
    ('Prefetch_claw', 'Artifacts_Collectors'),
    ('WinLog_Claw', 'Artifacts_Collectors'),
    ('A_CJL_LNK_Claw', 'Artifacts_Collectors'),
    ('JLParser', 'Artifacts_Collectors'),
    ('Regclaw', 'Artifacts_Collectors')
]

for module_name, import_path in artifact_modules:
    if not safe_import(module_name, import_path, module_name):
        # Create minimal fallback modules to prevent complete failure
        exec(f"""
class {module_name}:
    def __init__(self, *args, **kwargs):
        pass
    def __call__(self, *args, **kwargs):
        return {{}}
    def __getattr__(self, name):
        return lambda *args, **kwargs: {{}}
""")

# Import other custom modules
try:
    import GUI_resources
    print(Fore.GREEN + "✓ Successfully imported GUI_resources" + Fore.RESET)
except ImportError as e:
    print(Fore.RED + f"✗ Failed to import GUI_resources: {str(e)}" + Fore.RESET)
    GUI_resources = None

try:
    from styles import CrowEyeStyles
    print(Fore.GREEN + "✓ Successfully imported CrowEyeStyles" + Fore.RESET)
except ImportError as e:
    print(Fore.RED + f"✗ Failed to import CrowEyeStyles: {str(e)}" + Fore.RESET)
    CrowEyeStyles = None

try:
    from utils import SearchUtils, SearchWorker
    print(Fore.GREEN + "✓ Successfully imported SearchUtils and SearchWorker" + Fore.RESET)
except ImportError as e:
    print(Fore.RED + f"✗ Failed to import SearchUtils/SearchWorker: {str(e)}" + Fore.RESET)
    SearchUtils = None
    SearchWorker = None

# Comprehensive dependency validation with automatic recovery
def validate_dependencies():
    """Validate that all critical dependencies are working properly with automatic recovery for win32evtlog."""
    print(Fore.CYAN + "\n=== Validating Dependencies ===" + Fore.RESET)
    
    critical_deps = [
        ('PyQt5', 'GUI framework'),
        ('sqlite3', 'Database operations'),
        ('win32evtlog', 'Windows event log access'),
        ('Registry', 'Registry parsing'),
        ('pandas', 'Data analysis'),
        ('psutil', 'System monitoring')
    ]
    
    all_ok = True
    win32evtlog_fixed = False
    
    for dep, purpose in critical_deps:
        try:
            if dep == 'win32evtlog':
                import win32evtlog
                print(Fore.GREEN + f"✓ {dep}: OK ({purpose})" + Fore.RESET)
            elif dep == 'sqlite3':
                import sqlite3
                print(Fore.GREEN + f"✓ {dep}: OK ({purpose})" + Fore.RESET)
            elif dep == 'PyQt5':
                from PyQt5 import QtCore
                print(Fore.GREEN + f"✓ {dep}: OK ({purpose})" + Fore.RESET)
            else:
                __import__(dep)
                print(Fore.GREEN + f"✓ {dep}: OK ({purpose})" + Fore.RESET)
        except ImportError:
            if dep == 'win32evtlog':
                print(Fore.RED + f"✗ {dep}: MISSING ({purpose})" + Fore.RESET)
                print(Fore.YELLOW + "   Attempting automatic recovery for win32evtlog..." + Fore.RESET)
                
                # Try to automatically fix win32evtlog
                if handle_pywin32_postinstall():
                    # Retry the import after successful post-install
                    try:
                        import win32evtlog
                        print(Fore.GREEN + f"✓ {dep}: RECOVERED ({purpose})" + Fore.RESET)
                        win32evtlog_fixed = True
                        continue  # Skip the error flag for this dependency
                    except ImportError:
                        print(Fore.RED + f"✗ {dep}: AUTOMATIC RECOVERY FAILED ({purpose})" + Fore.RESET)
                else:
                    print(Fore.RED + f"✗ {dep}: AUTOMATIC RECOVERY UNAVAILABLE ({purpose})" + Fore.RESET)
            else:
                print(Fore.RED + f"✗ {dep}: MISSING ({purpose})" + Fore.RESET)
            
            all_ok = False
        except Exception as e:
            print(Fore.YELLOW + f"⚠ {dep}: ERROR - {str(e)} ({purpose})" + Fore.RESET)
            all_ok = False
    
    if not all_ok:
        print(Fore.YELLOW + "\n⚠ Some dependencies have issues. The application may not function fully." + Fore.RESET)
        if not win32evtlog_fixed:
            print(Fore.YELLOW + "   For win32evtlog issues, try running the pywin32 post-install script manually:" + Fore.RESET)
            print(Fore.YELLOW + "   python crow_eye_venv\\Scripts\\pywin32_postinstall.py -install" + Fore.RESET)
        print(Fore.YELLOW + "   Or run: python -m pip install --upgrade -r requirements.txt" + Fore.RESET)
    else:
        print(Fore.GREEN + "\n✓ All critical dependencies are working properly!" + Fore.RESET)
    
    return all_ok

# Run dependency validation
validate_dependencies()

# ============================================================================
# UI COMPONENTS SECTION
# ============================================================================




# SearchWorker class moved to utils/search_utils.py

class Ui_Crow_Eye(object):  # This should be a proper Qt class, not just a plain object
    # Add data loading methods to the class

    def load_allReg_data(self):
        """Load core registry datasets into their tables from the registry DB"""
        # Call all individual loading functions for registry artifacts
        self.load_data_from_database_NetworkLists()
        self.load_data_from_database_NetworkInterfaces()
        self.load_data_from_database_ComputerName()
        self.load_data_from_database_Timezone()
        self.load_data_from_database_LastUpdate()
        self.load_data_from_database_LastUpdate_subkeys()
        self.load_data_from_database_shutdowninfo()
        self.load_data_from_database_MachineRune()
        self.load_data_from_database_MachineRuneOnce()
        self.load_data_from_database_UserRun()
        self.load_data_from_database_UserRunOnce()
        self.load_data_from_database_RunMRU()
        print("[Registry] All registry data loaded")
    
    # ============================================================================
    #  PROPER DATA LOADING METHODS START BELOW (at class level)
    # ============================================================================
    
    def get_registry_db_path(self):
        """Get the path to the registry database for the current case"""
        if hasattr(self, 'case_paths') and self.case_paths:
            artifacts_dir = self.case_paths.get('artifacts_dir')
            if artifacts_dir:
                return os.path.join(artifacts_dir, 'registry_data.db')
        # Fallback to current directory
        return 'registry_data.db'
    
    def load_registry_data_from_db(self):
        """Load all registry data from the database into the GUI tables"""
        try:
            print("[Registry] Loading registry data into GUI...")
            # Load core registry data (Computer Name, Time Zone, Network, Run keys, etc.)
            self.load_allReg_data()
            # Load files activity data (UserAssist, Shellbags, RunMRU, MUICache, WordWheelQuery, etc.)
            self.load_files_activity()
            print("[Registry] Registry data loaded successfully")
        except Exception as e:
            print(f"[Registry] Error loading registry data: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def load_registry_data_from_db(self):
        """Load all registry data from the database into the GUI tables"""
        try:
            print("[Registry] Loading registry data into GUI...")
            # Load core registry data (Computer Name, Time Zone, Network, Run keys, etc.)
            self.load_allReg_data()
            # Load files activity data (UserAssist, Shellbags, RunMRU, MUICache, WordWheelQuery, etc.)
            self.load_files_activity()
            print("[Registry] Registry data loaded successfully")
        except Exception as e:
            print(f"[Registry] Error loading registry data: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def load_data_from_database_NetworkLists(self):
        """Load Network Lists data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Network_list")
            rows = cursor.fetchall()
            if hasattr(self, 'NetworkLists_table'):
                self.NetworkLists_table.setRowCount(0)
                for row in rows:
                    row_index = self.NetworkLists_table.rowCount()
                    self.NetworkLists_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.NetworkLists_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[NetworkLists] Error loading data: {str(e)}")
    
    def load_data_from_database_ComputerName(self):
        """Load Computer Name data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM computer_Name")
            rows = cursor.fetchall()
            if hasattr(self, 'computerName_table'):
                self.computerName_table.setRowCount(0)
                for row in rows:
                    row_index = self.computerName_table.rowCount()
                    self.computerName_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.computerName_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[ComputerName] Error loading data: {str(e)}")
    
    def load_data_from_database_Timezone(self):
        """Load Timezone data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM time_zone")
            rows = cursor.fetchall()
            if hasattr(self, 'TimeZone_table'):
                self.TimeZone_table.setRowCount(0)
                for row in rows:
                    row_index = self.TimeZone_table.rowCount()
                    self.TimeZone_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.TimeZone_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[Timezone] Error loading data: {str(e)}")
    
    def load_data_from_database_NetworkInterfaces(self):
        """Load Network Interfaces data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM network_interfaces")
            rows = cursor.fetchall()
            if hasattr(self, 'NetworkInterface_table'):
                self.NetworkInterface_table.setRowCount(0)
                for row in rows:
                    row_index = self.NetworkInterface_table.rowCount()
                    self.NetworkInterface_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.NetworkInterface_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[NetworkInterfaces] Error loading data: {str(e)}")
    
    def load_data_from_database_MachineRune(self):
        """Load Machine Run data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM machine_run")
            rows = cursor.fetchall()
            if hasattr(self, 'MachineRun_table'):
                self.MachineRun_table.setRowCount(0)
                for row in rows:
                    row_index = self.MachineRun_table.rowCount()
                    self.MachineRun_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.MachineRun_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[MachineRun] Error loading data: {str(e)}")
    
    def load_data_from_database_MachineRuneOnce(self):
        """Load Machine Run Once data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM machine_run_once")
            rows = cursor.fetchall()
            if hasattr(self, 'MachineRunOnce_tabel'):  # Note: keeping original typo for compatibility
                self.MachineRunOnce_tabel.setRowCount(0)
                for row in rows:
                    row_index = self.MachineRunOnce_tabel.rowCount()
                    self.MachineRunOnce_tabel.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.MachineRunOnce_tabel.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[MachineRunOnce] Error loading data: {str(e)}")
    
    def load_data_from_database_UserRun(self):
        """Load User Run data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM user_run")
            rows = cursor.fetchall()
            if hasattr(self, 'UserRun_table'):
                self.UserRun_table.setRowCount(0)
                for row in rows:
                    row_index = self.UserRun_table.rowCount()
                    self.UserRun_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.UserRun_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[UserRun] Error loading data: {str(e)}")
    
    def load_data_from_database_UserRunOnce(self):
        """Load User Run Once data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM user_run_once")
            rows = cursor.fetchall()
            if hasattr(self, 'UserRunOnce_table'):
                self.UserRunOnce_table.setRowCount(0)
                for row in rows:
                    row_index = self.UserRunOnce_table.rowCount()
                    self.UserRunOnce_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.UserRunOnce_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[UserRunOnce] Error loading data: {str(e)}")
    
    def load_data_from_database_LastUpdate(self):
        """Load Windows Last Update data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Windows_lastupdate")
            rows = cursor.fetchall()
            if hasattr(self, 'LastUpdate_table'):
                self.LastUpdate_table.setRowCount(0)
                for row in rows:
                    row_index = self.LastUpdate_table.rowCount()
                    self.LastUpdate_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.LastUpdate_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[LastUpdate] Error loading data: {str(e)}")
    
    def load_data_from_database_LastUpdate_subkeys(self):
        """Load Windows Last Update subkey info from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Windows_lastupdate")
            rows = cursor.fetchall()
            if hasattr(self, 'LastUpdateInfo_table'):
                self.LastUpdateInfo_table.setRowCount(0)
                for row in rows:
                    row_index = self.LastUpdateInfo_table.rowCount()
                    self.LastUpdateInfo_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.LastUpdateInfo_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[LastUpdateSubkeys] Error loading data: {str(e)}")
    
    def load_data_from_database_shutdowninfo(self):
        """Load Shutdown info from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Windows_lastupdate")  # Note: using same table as original
            rows = cursor.fetchall()
            if hasattr(self, 'ShutDown_table'):
                self.ShutDown_table.setRowCount(0)
                for row in rows:
                    row_index = self.ShutDown_table.rowCount()
                    self.ShutDown_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.ShutDown_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[ShutdownInfo] Error loading data: {str(e)}")
    
    def load_data_from_database_RecentDocs(self):
        """Load Recent Documents data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM RecentDocs")
            rows = cursor.fetchall()
            if hasattr(self, 'RecentDocs_table'):
                self.RecentDocs_table.setRowCount(0)
                for row in rows:
                    row_index = self.RecentDocs_table.rowCount()
                    self.RecentDocs_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.RecentDocs_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[RecentDocs] Error loading data: {str(e)}")
    
    def load_data_from_database_search_explorer_bar(self):
        """Load Search Explorer Bar data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Search_Explorer_bar")
            rows = cursor.fetchall()
            if hasattr(self, 'SearchViaExplorer_table'):
                self.SearchViaExplorer_table.setRowCount(0)
                for row in rows:
                    row_index = self.SearchViaExplorer_table.rowCount()
                    self.SearchViaExplorer_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.SearchViaExplorer_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[SearchExplorerBar] Error loading data: {str(e)}")
    
    def load_data_from_database_OpenSaveMRU(self):
        """Load Open Save MRU data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM OpenSaveMRU")
            rows = cursor.fetchall()
            if hasattr(self, 'OpenSaveMRU_table'):
                self.OpenSaveMRU_table.setRowCount(0)
                for row in rows:
                    row_index = self.OpenSaveMRU_table.rowCount()
                    self.OpenSaveMRU_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.OpenSaveMRU_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[OpenSaveMRU] Error loading data: {str(e)}")
    
    def load_data_from_database_LastSaveMRU(self):
        """Load Last Save MRU data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM lastSaveMRU")
            rows = cursor.fetchall()
            if hasattr(self, 'LastSaveMRU_table'):
                self.LastSaveMRU_table.setRowCount(0)
                for row in rows:
                    row_index = self.LastSaveMRU_table.rowCount()
                    self.LastSaveMRU_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.LastSaveMRU_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[LastSaveMRU] Error loading data: {str(e)}")
    
    def load_data_from_database_TypedPathes(self):
        """Load Typed Paths data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM TypedPaths")
            rows = cursor.fetchall()
            if hasattr(self, 'TypedPath_table'):
                self.TypedPath_table.setRowCount(0)
                for row in rows:
                    row_index = self.TypedPath_table.rowCount()
                    self.TypedPath_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.TypedPath_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[TypedPaths] Error loading data: {str(e)}")
    
    def load_data_from_database_BAM(self):
        """Load BAM (Background Activity Moderator) data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM BAM")
            rows = cursor.fetchall()
            if hasattr(self, 'Bam_table'):
                self.Bam_table.setRowCount(0)
                for row in rows:
                    row_index = self.Bam_table.rowCount()
                    self.Bam_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.Bam_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[BAM] Error loading data: {str(e)}")
    
    def load_data_from_database_DAM(self):
        """Load DAM (Desktop Activity Moderator) data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM DAM")
            rows = cursor.fetchall()
            if hasattr(self, 'Dam_table'):
                self.Dam_table.setRowCount(0)
                for row in rows:
                    row_index = self.Dam_table.rowCount()
                    self.Dam_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.Dam_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[DAM] Error loading data: {str(e)}")
    
    def load_data_from_database_UserAssist(self):
        """Load UserAssist data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT program_path, run_count, last_execution, focus_count, focus_time, user_sid FROM UserAssist ORDER BY last_execution DESC")
            rows = cursor.fetchall()
            if hasattr(self, 'UserAssist_table'):
                self.UserAssist_table.setRowCount(0)
                for row in rows:
                    row_index = self.UserAssist_table.rowCount()
                    self.UserAssist_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                        self.UserAssist_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[UserAssist] Error loading data: {str(e)}")
    
    def load_data_from_database_Shellbags(self):
        """Load Shellbags data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT folder_path, folder_name, shell_item_type, mru_position, access_date, registry_path FROM Shellbags ORDER BY mru_position")
            rows = cursor.fetchall()
            if hasattr(self, 'Shellbags_table'):
                self.Shellbags_table.setRowCount(0)
                for row in rows:
                    row_index = self.Shellbags_table.rowCount()
                    self.Shellbags_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                        self.Shellbags_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[Shellbags] Error loading data: {str(e)}")
    
    def load_data_from_database_RunMRU(self):
        """Load RunMRU data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT command, mru_position, access_date FROM RunMRU ORDER BY mru_position")
            rows = cursor.fetchall()
            if hasattr(self, 'RunMRU_table'):
                self.RunMRU_table.setRowCount(0)
                for row in rows:
                    row_index = self.RunMRU_table.rowCount()
                    self.RunMRU_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                        self.RunMRU_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[RunMRU] Error loading data: {str(e)}")
    
    def load_data_from_database_MUICache(self):
        """Load MUICache data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT app_path, app_name, file_extension FROM MUICache ORDER BY app_name")
            rows = cursor.fetchall()
            if hasattr(self, 'MUICache_table'):
                self.MUICache_table.setRowCount(0)
                for row in rows:
                    row_index = self.MUICache_table.rowCount()
                    self.MUICache_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                        self.MUICache_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[MUICache] Error loading data: {str(e)}")
    
    def load_data_from_database_WordWheelQuery(self):
        """Load WordWheelQuery data from registry database"""
        try:
            db_path = self.get_registry_db_path()
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT search_term, search_type, mru_position, access_date FROM WordWheelQuery ORDER BY mru_position")
            rows = cursor.fetchall()
            if hasattr(self, 'WordWheelQuery_table'):
                self.WordWheelQuery_table.setRowCount(0)
                for row in rows:
                    row_index = self.WordWheelQuery_table.rowCount()
                    self.WordWheelQuery_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                        self.WordWheelQuery_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[WordWheelQuery] Error loading data: {str(e)}")
    
    def load_data_from_database_lnkAJL(self):
        """Load LNK and Automatic Jump List data into their respective tables"""
        try:
            # Use the proper database path based on current case
            db_path = self.get_lnk_db_path()
            
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[LNK/AJL] Database not found at: {db_path}")
                print(f"[LNK/AJL] Please run LNK analysis first to create the database")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if JLCE table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='JLCE'")
            if not cursor.fetchone():
                print(f"[LNK/AJL] JLCE table not found in database: {db_path}")
                conn.close()
                return
            
            # Get column names to identify ID columns
            cursor.execute("PRAGMA table_info(JLCE)")
            columns = [col[1].lower() for col in cursor.fetchall()]
            
            # Identify ID columns (case-insensitive match)
            id_columns = [i for i, col in enumerate(columns) if any(id_key in col for id_key in ['uid', 'guid', 'id', 'uuid'])]
            non_id_columns = [i for i in range(len(columns)) if i not in id_columns]
            
            # Query all records from JLCE table
            cursor.execute("SELECT * FROM JLCE")
            all_rows = cursor.fetchall()
            
            # Separate LNK files and Automatic Jump Lists based on Artifact field
            lnk_rows = []
            ajl_rows = []
            
            for row in all_rows:
                # Check if the row has an Artifact field (typically column 9)
                artifact_type = None
                if len(row) > 9:
                    artifact_type = str(row[9])
                
                if artifact_type and 'JumpList' in artifact_type:
                    ajl_rows.append(row)
                else:
                    lnk_rows.append(row)
            
            # Function to reorder columns with ID columns at the end
            def reorder_columns(row_data, id_cols, non_id_cols):
                # Extract non-ID columns first, then ID columns
                reordered = [row_data[i] for i in non_id_cols]
                reordered.extend([row_data[i] for i in id_cols])
                return reordered
            
            # Load LNK data into LNK table
            if hasattr(self, 'LNK_table'):
                self.LNK_table.setRowCount(0)
                if lnk_rows:
                    # Set column headers with ID columns at the end
                    headers = [columns[i] for i in non_id_columns + id_columns]
                    self.LNK_table.setColumnCount(len(headers))
                    self.LNK_table.setHorizontalHeaderLabels(headers)
                    
                    for row in lnk_rows:
                        row_index = self.LNK_table.rowCount()
                        self.LNK_table.insertRow(row_index)
                        reordered_row = reorder_columns(row, id_columns, non_id_columns)
                        for col_index, value in enumerate(reordered_row):
                            item = QtWidgets.QTableWidgetItem(str(value) if value is not None else '')
                            self.LNK_table.setItem(row_index, col_index, item)
                print(f"[LNK] Successfully loaded {len(lnk_rows)} LNK records from {db_path}")
            
            # Load Automatic Jump List data into AJL table
            if hasattr(self, 'AJL_table'):
                self.AJL_table.setRowCount(0)
                if ajl_rows:
                    # Set column headers with ID columns at the end
                    headers = [columns[i] for i in non_id_columns + id_columns]
                    self.AJL_table.setColumnCount(len(headers))
                    self.AJL_table.setHorizontalHeaderLabels(headers)
                    
                    for row in ajl_rows:
                        row_index = self.AJL_table.rowCount()
                        self.AJL_table.insertRow(row_index)
                        reordered_row = reorder_columns(row, id_columns, non_id_columns)
                        for col_index, value in enumerate(reordered_row):
                            item = QtWidgets.QTableWidgetItem(str(value) if value is not None else '')
                            self.AJL_table.setItem(row_index, col_index, item)
                print(f"[AJL] Successfully loaded {len(ajl_rows)} Automatic Jump List records from {db_path}")
            
            conn.close()
        except Exception as e:
            print(f"[LNK/AJL] Error loading data: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def load_data_from_database_CJL(self):
        """Load Custom Jump List data into the CJL table"""
        try:
            # Use the proper database path based on current case
            db_path = self.get_lnk_db_path()
            
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[CJL] Database not found at: {db_path}")
                print(f"[CJL] Please run LNK analysis first to create the database")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if Custom_JLCE table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='Custom_JLCE'")
            if not cursor.fetchone():
                print(f"[CJL] Custom_JLCE table not found in database: {db_path}")
                conn.close()
                return
            
            # Get column names to identify ID columns
            cursor.execute("PRAGMA table_info(Custom_JLCE)")
            columns = [col[1].lower() for col in cursor.fetchall()]
            
            # Identify ID columns (case-insensitive match)
            id_columns = [i for i, col in enumerate(columns) if any(id_key in col for id_key in ['uid', 'guid', 'id', 'uuid'])]
            non_id_columns = [i for i in range(len(columns)) if i not in id_columns]
            
            cursor.execute("SELECT * FROM Custom_JLCE")
            rows = cursor.fetchall()
            
            if hasattr(self, 'Clj_table') and hasattr(self, 'CJL_subtab'):
                self.Clj_table.setRowCount(0)
                if rows:
                    # Set column headers with ID columns at the end
                    headers = [columns[i] for i in non_id_columns + id_columns]
                    self.Clj_table.setColumnCount(len(headers))
                    self.Clj_table.setHorizontalHeaderLabels(headers)
                    
                    for row in rows:
                        row_index = self.Clj_table.rowCount()
                        self.Clj_table.insertRow(row_index)
                        # Reorder columns with ID columns at the end
                        reordered_row = [row[i] for i in non_id_columns + id_columns]
                        for col_index, value in enumerate(reordered_row):
                            item = QtWidgets.QTableWidgetItem(str(value) if value is not None else '')
                            self.Clj_table.setItem(row_index, col_index, item)
                print(f"[CJL] Successfully loaded {len(rows)} records from {db_path}")
            conn.close()
        except Exception as e:
            print(f"[CJL] Error loading data: {str(e)}")
    
    def load_data_from_SystemLogs(self):
        """Load System Logs data from the log database"""
        try:
            # Use the proper database path based on current case
            db_path = self.get_log_db_path()
            
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[SystemLogs] Database not found at: {db_path}")
                print(f"[SystemLogs] Please run logs analysis first to create the database")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if SystemLogs table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='SystemLogs'")
            if not cursor.fetchone():
                print(f"[SystemLogs] SystemLogs table not found in database: {db_path}")
                conn.close()
                return
                
            cursor.execute("SELECT * FROM SystemLogs")
            rows = cursor.fetchall()
            # Use the correct table name from the UI
            if hasattr(self, 'tableWidget_22'):
                self.tableWidget_22.setRowCount(0)
                for row in rows:
                    row_index = self.tableWidget_22.rowCount()
                    self.tableWidget_22.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.tableWidget_22.setItem(row_index, col_index, item)
                print(f"[SystemLogs] Successfully loaded {len(rows)} records from {db_path}")
            conn.close()
        except Exception as e:
            print(f"[SystemLogs] Error loading data: {str(e)}")
    
    def load_data_from_appsLogs(self):
        """Load Application Logs data from the log database"""
        try:
            # Use the proper database path based on current case
            db_path = self.get_log_db_path()
            
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[AppLogs] Database not found at: {db_path}")
                print(f"[AppLogs] Please run logs analysis first to create the database")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if ApplicationLogs table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='ApplicationLogs'")
            if not cursor.fetchone():
                print(f"[AppLogs] ApplicationLogs table not found in database: {db_path}")
                conn.close()
                return
                
            cursor.execute("SELECT * FROM ApplicationLogs")
            rows = cursor.fetchall()
            if hasattr(self, 'AppLogs_table'):
                self.AppLogs_table.setRowCount(0)
                for row in rows:
                    row_index = self.AppLogs_table.rowCount()
                    self.AppLogs_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.AppLogs_table.setItem(row_index, col_index, item)
                print(f"[AppLogs] Successfully loaded {len(rows)} records from {db_path}")
            conn.close()
        except Exception as e:
            print(f"[AppLogs] Error loading data: {str(e)}")
    
    def load_data_from_SecurityLogs(self):
        """Load Security Logs data from the log database"""
        try:
            # Use the proper database path based on current case
            db_path = self.get_log_db_path()
            
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[SecurityLogs] Database not found at: {db_path}")
                print(f"[SecurityLogs] Please run logs analysis first to create the database")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if SecurityLogs table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='SecurityLogs'")
            if not cursor.fetchone():
                print(f"[SecurityLogs] SecurityLogs table not found in database: {db_path}")
                conn.close()
                return
                
            cursor.execute("SELECT * FROM SecurityLogs")
            rows = cursor.fetchall()
            if hasattr(self, 'SecurityLogs_table'):
                self.SecurityLogs_table.setRowCount(0)
                for row in rows:
                    row_index = self.SecurityLogs_table.rowCount()
                    self.SecurityLogs_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.SecurityLogs_table.setItem(row_index, col_index, item)
                print(f"[SecurityLogs] Successfully loaded {len(rows)} records from {db_path}")
            conn.close()
        except Exception as e:
            print(f"[SecurityLogs] Error loading data: {str(e)}")
    
    def create_amcache_table_tabs(self):
        """Create table tabs for each Amcache table based on the schema"""
        # Import the schema from amcacheparser.py
        try:
            from Artifacts_Collectors.amcacheparser import AMCACHE_SCHEMAS
        except ImportError:
            print("[Amcache] Error importing AMCACHE_SCHEMAS from amcacheparser.py")
            return
            
        # Create a tab for each table in the schema
        for table_name, columns in AMCACHE_SCHEMAS.items():
            # Create a tab for this table
            tab = QtWidgets.QWidget()
            tab.setObjectName(f"Amcache_{table_name}_tab")
            
            # Create a layout for the tab
            layout = QtWidgets.QVBoxLayout(tab)
            layout.setObjectName(f"verticalLayout_Amcache_{table_name}")
            
            # Create a table widget for this table
            table_widget = QtWidgets.QTableWidget(tab)
            table_widget.setObjectName(f"Amcache_{table_name}_table")
            
            # Set table properties
            table_widget.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
            table_widget.setAlternatingRowColors(True)
            table_widget.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
            table_widget.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
            table_widget.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
            table_widget.setSortingEnabled(True)
            
            # Set up columns based on the schema (include 'id' column)
            # Add 'id' as the first column, followed by schema columns
            table_widget.setColumnCount(len(columns) + 1)
            
            # Set 'id' as the first column
            item = QtWidgets.QTableWidgetItem('id')
            table_widget.setHorizontalHeaderItem(0, item)
            
            # Set remaining columns from schema
            for i, column_name in enumerate(columns):
                item = QtWidgets.QTableWidgetItem(column_name)
                table_widget.setHorizontalHeaderItem(i + 1, item)
            
            # Ensure headers are fully visible and resizable
            table_widget.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Interactive)
            table_widget.horizontalHeader().setStretchLastSection(True)
            
            # Store the table widget as an attribute of the class
            setattr(self, f"Amcache_{table_name}_table", table_widget)
            
            # Apply unified table style
            from styles import CrowEyeStyles
            self.apply_table_styles(table_widget)
            
            # Add the table widget to the layout
            layout.addWidget(table_widget)
            
            # Add the tab to the Amcache tab widget
            self.Amcache_tab_widget.addTab(tab, table_name)
            
            # Set a friendly display name for the tab
            friendly_name = table_name
            if table_name.startswith("Inventory"):
                friendly_name = table_name[9:]  # Remove "Inventory" prefix
            self.Amcache_tab_widget.setTabText(
                self.Amcache_tab_widget.indexOf(tab), 
                friendly_name
            )
    
    def create_mft_usn_table_tabs(self):
        """Create table tabs for MFT and USN Journal data"""
        # Create MFT main tab with subtabs
        self.MFT_tab = QtWidgets.QWidget()
        self.MFT_tab.setObjectName("MFT_tab")
        self.verticalLayout_mft = QtWidgets.QVBoxLayout(self.MFT_tab)
        self.verticalLayout_mft.setObjectName("verticalLayout_mft")
        
        # Create MFT subtab widget
        self.MFT_subtab_widget = QtWidgets.QTabWidget(self.MFT_tab)
        self.MFT_subtab_widget.setObjectName("MFT_subtab_widget")
        
        # Apply unified style to the subtab widget
        from styles import CrowEyeStyles
        self.MFT_subtab_widget.setStyleSheet(CrowEyeStyles.UNIFIED_TAB_STYLE)
        
        # Create MFT Records subtab
        self.MFT_records_tab = QtWidgets.QWidget()
        self.MFT_records_tab.setObjectName("MFT_records_tab")
        self.verticalLayout_mft_records = QtWidgets.QVBoxLayout(self.MFT_records_tab)
        
        self.MFT_table = QtWidgets.QTableWidget(self.MFT_records_tab)
        self.MFT_table.setObjectName("MFT_table")
        self.MFT_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.MFT_table.setAlternatingRowColors(True)
        self.MFT_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.MFT_table.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        self.MFT_table.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        self.MFT_table.setSortingEnabled(True)
        
        mft_headers = [
            "Record Number", "Filename", "Flags", "Parent Record Number", "Creation Time", 
            "Modification Time", "MFT Modification Time", "Access Time", 
            "File Size", "Allocated Size", "Full Path", 
            "Extension", "File Attributes", "Resident/Non-resident"
        ]
        self.MFT_table.setColumnCount(len(mft_headers))
        for i, header in enumerate(mft_headers):
            item = QtWidgets.QTableWidgetItem(header)
            self.MFT_table.setHorizontalHeaderItem(i, item)
        
        self.MFT_table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Interactive)
        self.MFT_table.horizontalHeader().setStretchLastSection(True)
        self.apply_table_styles(self.MFT_table)
        
        self.verticalLayout_mft_records.addWidget(self.MFT_table)
        self.MFT_subtab_widget.addTab(self.MFT_records_tab, "MFT Records")
        
        # Create MFT Standard Info subtab
        self.MFT_standard_info_tab = QtWidgets.QWidget()
        self.MFT_standard_info_tab.setObjectName("MFT_standard_info_tab")
        self.verticalLayout_mft_standard = QtWidgets.QVBoxLayout(self.MFT_standard_info_tab)
        
        self.MFT_standard_info_table = QtWidgets.QTableWidget(self.MFT_standard_info_tab)
        self.MFT_standard_info_table.setObjectName("MFT_standard_info_table")
        self.MFT_standard_info_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.MFT_standard_info_table.setAlternatingRowColors(True)
        self.MFT_standard_info_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.MFT_standard_info_table.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        self.MFT_standard_info_table.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        self.MFT_standard_info_table.setSortingEnabled(True)
        self.apply_table_styles(self.MFT_standard_info_table)
        
        self.verticalLayout_mft_standard.addWidget(self.MFT_standard_info_table)
        self.MFT_subtab_widget.addTab(self.MFT_standard_info_tab, "Standard Info")
        
        # Create MFT File Names subtab
        self.MFT_file_names_tab = QtWidgets.QWidget()
        self.MFT_file_names_tab.setObjectName("MFT_file_names_tab")
        self.verticalLayout_mft_filenames = QtWidgets.QVBoxLayout(self.MFT_file_names_tab)
        
        self.MFT_file_names_table = QtWidgets.QTableWidget(self.MFT_file_names_tab)
        self.MFT_file_names_table.setObjectName("MFT_file_names_table")
        self.MFT_file_names_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.MFT_file_names_table.setAlternatingRowColors(True)
        self.MFT_file_names_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.MFT_file_names_table.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        self.MFT_file_names_table.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        self.MFT_file_names_table.setSortingEnabled(True)
        self.apply_table_styles(self.MFT_file_names_table)
        
        self.verticalLayout_mft_filenames.addWidget(self.MFT_file_names_table)
        self.MFT_subtab_widget.addTab(self.MFT_file_names_tab, "File Names")
        
        # Create MFT Data Attributes subtab
        self.MFT_data_attributes_tab = QtWidgets.QWidget()
        self.MFT_data_attributes_tab.setObjectName("MFT_data_attributes_tab")
        self.verticalLayout_mft_data = QtWidgets.QVBoxLayout(self.MFT_data_attributes_tab)
        
        self.MFT_data_attributes_table = QtWidgets.QTableWidget(self.MFT_data_attributes_tab)
        self.MFT_data_attributes_table.setObjectName("MFT_data_attributes_table")
        self.MFT_data_attributes_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.MFT_data_attributes_table.setAlternatingRowColors(True)
        self.MFT_data_attributes_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.MFT_data_attributes_table.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        self.MFT_data_attributes_table.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        self.MFT_data_attributes_table.setSortingEnabled(True)
        self.apply_table_styles(self.MFT_data_attributes_table)
        
        self.verticalLayout_mft_data.addWidget(self.MFT_data_attributes_table)
        self.MFT_subtab_widget.addTab(self.MFT_data_attributes_tab, "Data Attributes")
        
        self.verticalLayout_mft.addWidget(self.MFT_subtab_widget)
        self.MFT_USN_tab_widget.addTab(self.MFT_tab, "MFT")
        
        # Create USN Journal tab
        self.USN_tab = QtWidgets.QWidget()
        self.USN_tab.setObjectName("USN_tab")
        self.verticalLayout_usn = QtWidgets.QVBoxLayout(self.USN_tab)
        self.verticalLayout_usn.setObjectName("verticalLayout_usn")
        
        # Create USN table widget
        self.USN_table = QtWidgets.QTableWidget(self.USN_tab)
        self.USN_table.setObjectName("USN_table")
        self.USN_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.USN_table.setAlternatingRowColors(True)
        self.USN_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.USN_table.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        self.USN_table.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        self.USN_table.setSortingEnabled(True)
        
        # Set USN table columns based on USN_Claw output structure
        usn_headers = [
            "Volume Letter", "Filename", "USN", "Major Version", "FRN", "Parent FRN", 
            "Timestamp", "Reason", "Source Info", "Security ID", "File Attributes", 
            "Record Length", "Inserted At"
        ]
        self.USN_table.setColumnCount(len(usn_headers))
        for i, header in enumerate(usn_headers):
            item = QtWidgets.QTableWidgetItem(header)
            self.USN_table.setHorizontalHeaderItem(i, item)
        
        self.USN_table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Interactive)
        self.USN_table.horizontalHeader().setStretchLastSection(True)
        
        # Apply unified table style
        self.apply_table_styles(self.USN_table)
        
        self.verticalLayout_usn.addWidget(self.USN_table)
        self.MFT_USN_tab_widget.addTab(self.USN_tab, "USN Journal")
        
        # Create Correlated Data tab
        self.Correlated_tab = QtWidgets.QWidget()
        self.Correlated_tab.setObjectName("Correlated_tab")
        self.verticalLayout_correlated = QtWidgets.QVBoxLayout(self.Correlated_tab)
        self.verticalLayout_correlated.setObjectName("verticalLayout_correlated")
        
        # Create Correlated table widget
        self.Correlated_table = QtWidgets.QTableWidget(self.Correlated_tab)
        self.Correlated_table.setObjectName("Correlated_table")
        self.Correlated_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.Correlated_table.setAlternatingRowColors(True)
        self.Correlated_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.Correlated_table.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        self.Correlated_table.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
        self.Correlated_table.setSortingEnabled(True)
        
        # Set Correlated table columns
        correlated_headers = [
            "Filename", "Full Path", "MFT Record Number", "USN Record Number", 
            "Creation Time", "Modification Time", "Access Time", "File Size", 
            "File Attributes", "Change Reasons", "Volume Name", "Correlation Score"
        ]
        self.Correlated_table.setColumnCount(len(correlated_headers))
        for i, header in enumerate(correlated_headers):
            item = QtWidgets.QTableWidgetItem(header)
            self.Correlated_table.setHorizontalHeaderItem(i, item)
        
        self.Correlated_table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Interactive)
        self.Correlated_table.horizontalHeader().setStretchLastSection(True)
        
        # Apply unified table style
        self.apply_table_styles(self.Correlated_table)
        
        self.verticalLayout_correlated.addWidget(self.Correlated_table)
        self.MFT_USN_tab_widget.addTab(self.Correlated_tab, "Correlated Data")
    
    def load_shimcache_data(self):
        """Load ShimCache data from the shimcache database"""
        try:
            # Get the database path from case configuration
            if not hasattr(self, 'case_paths') or not self.case_paths:
                print("[ShimCache] No active case found")
                return
                
            db_path = self.case_paths.get('databases', {}).get('shimcache')
            if not db_path:
                print("[ShimCache] Database path not found in case configuration")
                return
                
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[ShimCache] Database not found at: {db_path}")
                print(f"[ShimCache] Please run ShimCache analysis first to create the database")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if ShimCache table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='ShimCache'")
            if not cursor.fetchone():
                print(f"[ShimCache] ShimCache table not found in database: {db_path}")
                conn.close()
                return
                
            cursor.execute("SELECT * FROM ShimCache")
            rows = cursor.fetchall()
            if hasattr(self, 'ShimCache_table'):
                self.ShimCache_table.setRowCount(0)
                for row in rows:
                    row_index = self.ShimCache_table.rowCount()
                    self.ShimCache_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.ShimCache_table.setItem(row_index, col_index, item)
                print(f"[ShimCache] Successfully loaded {len(rows)} records from {db_path}")
            conn.close()
        except Exception as e:
            print(f"[ShimCache] Error loading data: {str(e)}")
    
    def load_amcache_data(self):
        """Load Amcache data from the amcache database"""
        try:
            # Get the database path from case configuration
            if not hasattr(self, 'case_paths') or not self.case_paths:
                print("[Amcache] No active case found")
                return
                
            # Get the current case name
            case_name = os.path.basename(self.case_paths.get('case_root', ''))
            if not case_name:
                print("[Amcache] Invalid case name, cannot load Amcache data")
                return
                
            # Load the current case configuration
            config_dir, _ = self.get_app_config_dir()
            config_path = os.path.join(config_dir, f"case_{case_name}.json")
            
            try:
                with open(config_path, 'r') as config_file:
                    case_config = json.load(config_file)
                    
                # Get the database path from the case configuration
                db_path = case_config.get('databases', {}).get('amcache')
                if not db_path:
                    print("[Amcache] Database path not found in case configuration")
                    return
            except Exception as e:
                print(f"[Amcache Error] Failed to load case configuration: {str(e)}")
                return
                
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[Amcache] Database not found at: {db_path}")
                print(f"[Amcache] Please run Amcache analysis first to create the database")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Get all tables in the Amcache database
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
            tables = cursor.fetchall()
            
            # Load data for each table
            for table in tables:
                table_name = table[0]
                # Skip sqlite_sequence table
                if table_name == 'sqlite_sequence':
                    continue
                    
                # Get the corresponding table widget attribute name
                table_widget_name = f"Amcache_{table_name}_table"
                
                if hasattr(self, table_widget_name):
                    cursor.execute(f"SELECT * FROM {table_name}")
                    rows = cursor.fetchall()
                    
                    table_widget = getattr(self, table_widget_name)
                    table_widget.setRowCount(0)
                    
                    for row in rows:
                        row_index = table_widget.rowCount()
                        table_widget.insertRow(row_index)
                        for col_index, value in enumerate(row):
                            item = QtWidgets.QTableWidgetItem(str(value))
                            table_widget.setItem(row_index, col_index, item)
                    
                    print(f"[Amcache] Successfully loaded {len(rows)} records from {table_name} table")
                    
                    # Apply unified table style
                    from styles import CrowEyeStyles
                    self.apply_table_styles(table_widget)
            
            conn.close()
        except Exception as e:
            print(f"[Amcache] Error loading data: {str(e)}")

    def _optimize_memory_usage(self):
        """Optimize memory usage by clearing caches and forcing garbage collection"""
        import gc
        # Clear Python object caches
        gc.collect()
        # Clear SQLite cache if available
        if hasattr(self, 'case_paths') and self.case_paths:
            for db_type in ['mft', 'usn', 'mft_usn_correlated']:
                db_path = self.case_paths.get('databases', {}).get(db_type)
                if db_path and os.path.exists(db_path):
                    try:
                        conn = sqlite3.connect(db_path)
                        conn.execute("PRAGMA shrink_memory")
                        conn.close()
                    except:
                        pass
        # Clear Qt caches
        QtWidgets.QApplication.processEvents()

    def _batch_process_data(self, cursor, query, table_widget, total_records, progress_callback, table_name, batch_size=500, page_size=10000, handle_row_errors=False):
        """
        Optimized batch processing for large datasets with memory management
        
        Args:
            cursor: SQLite cursor object
            query: SQL query string (without LIMIT/OFFSET)
            table_widget: QTableWidget to populate
            total_records: Total number of records to load
            progress_callback: Callback function for progress updates
            table_name: Name for progress messages
            batch_size: Size of UI processing batches
            page_size: Size of database query pages
            handle_row_errors: Whether to handle individual row errors gracefully
        """
        offset = 0
        loaded_count = 0
        
        # Pre-allocate table rows for better performance
        table_widget.setRowCount(total_records)
        
        while loaded_count < total_records:
            cursor.execute(f"{query} LIMIT {page_size} OFFSET {offset}")
            rows = cursor.fetchall()
            
            if not rows:
                break
            
            # Process rows in batches for better UI responsiveness
            for batch_start in range(0, len(rows), batch_size):
                batch_end = min(batch_start + batch_size, len(rows))
                batch = rows[batch_start:batch_end]
                
                for i, row in enumerate(batch):
                    row_index = offset + batch_start + i
                    
                    if handle_row_errors:
                        # Handle individual row errors gracefully
                        try:
                            for col_index, value in enumerate(row):
                                item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                                table_widget.setItem(row_index, col_index, item)
                        except Exception as e:
                            error_msg = f"[{table_name}] Error processing row: {str(e)}"
                            print(error_msg)
                            # Continue with next row instead of failing completely
                            continue
                    else:
                        # Standard processing without error handling
                        for col_index, value in enumerate(row):
                            item = QtWidgets.QTableWidgetItem(str(value))
                            table_widget.setItem(row_index, col_index, item)
                
                # Allow UI to process events more frequently
                QtWidgets.QApplication.processEvents()
            
            loaded_count += len(rows)
            offset += page_size
            
            if progress_callback:
                self._call_progress_callback(progress_callback, f"[{table_name}] Loaded {loaded_count:,} of {total_records:,} records")
            
            # Optimize memory usage after each page
            self._optimize_memory_usage()
        
        return loaded_count
    
    def _batch_process_data_with_loader(self, data_loader, load_method, table_widget, progress_callback, table_name, batch_size=500, page_size=10000, handle_row_errors=False, **loader_kwargs):
        """
        Optimized batch processing using data loader's pagination methods
        
        Args:
            data_loader: BaseDataLoader instance (MFTDataLoader, USNDataLoader, etc.)
            load_method: Method to call on the loader (e.g., loader.load_mft_records)
            table_widget: QTableWidget to populate
            progress_callback: Callback function for progress updates
            table_name: Name for progress messages
            batch_size: Size of UI processing batches
            page_size: Size of database query pages
            handle_row_errors: Whether to handle individual row errors gracefully
            **loader_kwargs: Additional keyword arguments to pass to the load method
        """
        # Get first page to determine total count and columns
        result = load_method(page=1, page_size=page_size, **loader_kwargs)
        
        if not result or result['total_count'] == 0:
            print(f"[{table_name}] No records found")
            return 0
        
        total_records = result['total_count']
        total_pages = result['total_pages']
        
        # Set up table columns from first record
        if result['data']:
            columns = list(result['data'][0].keys())
            table_widget.setColumnCount(len(columns))
            table_widget.setHorizontalHeaderLabels(columns)
        
        # Pre-allocate table rows for better performance
        table_widget.setRowCount(total_records)
        
        loaded_count = 0
        current_page = 1
        
        while current_page <= total_pages:
            # Get data for current page (reuse first page result)
            if current_page == 1:
                page_data = result['data']
            else:
                result = load_method(page=current_page, page_size=page_size, **loader_kwargs)
                page_data = result['data']
            
            if not page_data:
                break
            
            # Process rows in batches for better UI responsiveness
            for batch_start in range(0, len(page_data), batch_size):
                batch_end = min(batch_start + batch_size, len(page_data))
                batch = page_data[batch_start:batch_end]
                
                for i, record in enumerate(batch):
                    row_index = loaded_count + i
                    
                    if handle_row_errors:
                        # Handle individual row errors gracefully
                        try:
                            for col_index, column_name in enumerate(columns):
                                value = record.get(column_name)
                                item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                                table_widget.setItem(row_index, col_index, item)
                        except Exception as e:
                            error_msg = f"[{table_name}] Error processing row: {str(e)}"
                            print(error_msg)
                            # Continue with next row instead of failing completely
                            continue
                    else:
                        # Standard processing without error handling
                        for col_index, column_name in enumerate(columns):
                            value = record.get(column_name)
                            item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                            table_widget.setItem(row_index, col_index, item)
                
                # Allow UI to process events more frequently
                QtWidgets.QApplication.processEvents()
            
            loaded_count += len(page_data)
            current_page += 1
            
            if progress_callback:
                self._call_progress_callback(progress_callback, f"[{table_name}] Loaded {loaded_count:,} of {total_records:,} records")
            
            # Optimize memory usage after each page
            self._optimize_memory_usage()
        
        return loaded_count

    def _call_progress_callback(self, progress_callback, message):
        """Helper method to handle both signal objects and direct method calls"""
        if progress_callback:
            if hasattr(progress_callback, 'emit'):
                progress_callback.emit(message)
            else:
                progress_callback(message)
    
    def load_mft_data(self, progress_callback=None):
        """Load MFT data from the MFT database into all subtabs using VirtualTableWidget for efficient memory usage"""
        # Import required modules at runtime to avoid circular imports
        try:
            from data.mft_loader import MFTDataLoader
            from ui.virtual_table_widget import VirtualTableWidget
            from ui.progress_indicator import TableLoadingOverlay
        except ImportError as e:
            error_msg = f"[MFT] Failed to import required modules: {str(e)}"
            print(error_msg)
            self._call_progress_callback(progress_callback, error_msg)
            return
        
        mft_loader = None
        try:
            # Get the database path from case configuration
            if not hasattr(self, 'case_paths') or not self.case_paths:
                error_msg = "[MFT] No active case found"
                print(error_msg)
                self._call_progress_callback(progress_callback, error_msg)
                return
                
            db_path = self.case_paths.get('databases', {}).get('mft')
            if not db_path:
                error_msg = "[MFT] Database path not found in case configuration"
                print(error_msg)
                self._call_progress_callback(progress_callback, error_msg)
                return
                
            # Check if database exists
            if not os.path.exists(db_path):
                error_msg = f"[MFT] Database not found at: {db_path}"
                print(error_msg)
                self._call_progress_callback(progress_callback, error_msg)
                return
            
            # Initialize MFT data loader
            print(f"[MFT] Initializing MFTDataLoader for database: {db_path}")
            mft_loader = MFTDataLoader(db_path)
            
            # Connect to database
            if not mft_loader.connect():
                error_msg = f"[MFT] Failed to connect to database: {db_path}"
                print(error_msg)
                self._call_progress_callback(progress_callback, error_msg)
                return
            
            print(f"[MFT] Successfully connected to database")
            
            # Get database statistics
            stats = mft_loader.get_mft_statistics()
            print(f"[MFT] Database statistics: {len(stats)} tables found")
            
            # Load MFT Records table using VirtualTableWidget for efficient memory usage
            print("[MFT] Loading mft_records table with virtual scrolling...")
            if mft_loader.table_exists('mft_records'):
                try:
                    table_stats = stats.get('mft_records', {})
                    total_records = table_stats.get('row_count', 0)
                    
                    print(f"[MFT] Found {total_records:,} MFT records, using virtual scrolling for efficient loading")
                    self._call_progress_callback(progress_callback, f"[MFT] Initializing virtual table for {total_records:,} MFT records...")
                    
                    if hasattr(self, 'MFT_table') and total_records > 0:
                        # Get columns from the table
                        columns = mft_loader.get_columns('mft_records')
                        
                        # Replace the old table with VirtualTableWidget
                        # First, remove the old table from layout
                        old_table = self.MFT_table
                        layout = self.verticalLayout_mft_records
                        layout.removeWidget(old_table)
                        old_table.deleteLater()
                        
                        # Store the loader so it stays alive for virtual scrolling
                        self.mft_loader = mft_loader
                        
                        # Create new VirtualTableWidget
                        # Use recommended settings: 5000 rows per page, 10000 row buffer
                        self.MFT_table = VirtualTableWidget(
                            data_loader=self.mft_loader,
                            table_name='mft_records',
                            columns=columns,
                            page_size=5000,
                            buffer_size=10000,
                            parent=self.MFT_records_tab
                        )
                        
                        # Set default ordering
                        self.MFT_table.set_order_by('record_number ASC')
                        
                        # Apply Crow Eye table styles
                        from styles import CrowEyeStyles
                        CrowEyeStyles.apply_table_styles(self.MFT_table)
                        
                        # Add to layout
                        layout.addWidget(self.MFT_table)
                        
                        # Create loading overlay
                        if not hasattr(self, 'MFT_loading_overlay'):
                            self.MFT_loading_overlay = TableLoadingOverlay(self.MFT_table)
                        
                        # Connect signals
                        self.MFT_table.loading_started.connect(
                            lambda: self.MFT_loading_overlay.show_loading("Loading MFT data...")
                        )
                        self.MFT_table.loading_finished.connect(
                            lambda: self.MFT_loading_overlay.hide_loading()
                        )
                        
                        # Load initial data
                        self.MFT_loading_overlay.show_loading("Loading MFT records...")
                        success = self.MFT_table.load_initial_data()
                        
                        if success:
                            loaded_rows = self.MFT_table.get_loaded_row_count()
                            print(f"[MFT] Successfully initialized virtual table with {total_records:,} records ({loaded_rows:,} in memory)")
                            self._call_progress_callback(progress_callback, f"[MFT] Loaded {total_records:,} records (virtual scrolling enabled)")
                        else:
                            print("[MFT] Failed to load initial data")
                            self._call_progress_callback(progress_callback, "[MFT] Failed to load data")
                        
                        self.MFT_loading_overlay.hide_loading()
                    else:
                        print("[MFT] MFT_table widget not found or no records to load")
                except Exception as e:
                    error_msg = f"[MFT] Error loading mft_records table: {str(e)}"
                    print(error_msg)
                    import traceback
                    traceback.print_exc()
                    self._call_progress_callback(progress_callback, error_msg)
            else:
                print("[MFT] mft_records table not found in database")
            
            # Load MFT Standard Info table using VirtualTableWidget
            print("[MFT] Loading mft_standard_info table with virtual scrolling...")
            if mft_loader.table_exists('mft_standard_info'):
                try:
                    table_stats = stats.get('mft_standard_info', {})
                    total_records = table_stats.get('row_count', 0)
                    
                    print(f"[MFT] Found {total_records:,} standard info records, using virtual scrolling")
                    self._call_progress_callback(progress_callback, f"[MFT] Initializing virtual table for {total_records:,} standard info records...")
                    
                    if hasattr(self, 'MFT_standard_info_table') and total_records > 0:
                        columns = mft_loader.get_columns('mft_standard_info')
                        
                        # Replace old table with VirtualTableWidget
                        old_table = self.MFT_standard_info_table
                        layout = self.verticalLayout_mft_standard
                        layout.removeWidget(old_table)
                        old_table.deleteLater()
                        
                        self.MFT_standard_info_table = VirtualTableWidget(
                            data_loader=self.mft_loader,
                            table_name='mft_standard_info',
                            columns=columns,
                            page_size=5000,
                            buffer_size=10000,
                            parent=self.MFT_standard_info_tab
                        )
                        
                        # Apply Crow Eye table styles
                        CrowEyeStyles.apply_table_styles(self.MFT_standard_info_table)
                        
                        layout.addWidget(self.MFT_standard_info_table)
                        
                        # Create loading overlay
                        if not hasattr(self, 'MFT_standard_info_loading_overlay'):
                            self.MFT_standard_info_loading_overlay = TableLoadingOverlay(self.MFT_standard_info_table)
                        
                        self.MFT_standard_info_table.loading_started.connect(
                            lambda: self.MFT_standard_info_loading_overlay.show_loading("Loading...")
                        )
                        self.MFT_standard_info_table.loading_finished.connect(
                            lambda: self.MFT_standard_info_loading_overlay.hide_loading()
                        )
                        
                        self.MFT_standard_info_loading_overlay.show_loading("Loading standard info...")
                        success = self.MFT_standard_info_table.load_initial_data()
                        
                        if success:
                            print(f"[MFT] Successfully initialized standard info virtual table with {total_records:,} records")
                        
                        self.MFT_standard_info_loading_overlay.hide_loading()
                except Exception as e:
                    error_msg = f"[MFT] Error loading mft_standard_info table: {str(e)}"
                    print(error_msg)
                    import traceback
                    traceback.print_exc()
                    self._call_progress_callback(progress_callback, error_msg)
            else:
                print("[MFT] mft_standard_info table not found in database")
            
            # Load MFT File Names table using VirtualTableWidget
            print("[MFT] Loading mft_file_names table with virtual scrolling...")
            if mft_loader.table_exists('mft_file_names'):
                try:
                    table_stats = stats.get('mft_file_names', {})
                    total_records = table_stats.get('row_count', 0)
                    
                    print(f"[MFT] Found {total_records:,} file name records, using virtual scrolling")
                    self._call_progress_callback(progress_callback, f"[MFT] Initializing virtual table for {total_records:,} file name records...")
                    
                    if hasattr(self, 'MFT_file_names_table') and total_records > 0:
                        columns = mft_loader.get_columns('mft_file_names')
                        
                        # Replace old table with VirtualTableWidget
                        old_table = self.MFT_file_names_table
                        layout = self.verticalLayout_mft_filenames
                        layout.removeWidget(old_table)
                        old_table.deleteLater()
                        
                        self.MFT_file_names_table = VirtualTableWidget(
                            data_loader=self.mft_loader,
                            table_name='mft_file_names',
                            columns=columns,
                            page_size=5000,
                            buffer_size=10000,
                            parent=self.MFT_file_names_tab
                        )
                        
                        # Apply Crow Eye table styles
                        CrowEyeStyles.apply_table_styles(self.MFT_file_names_table)
                        
                        layout.addWidget(self.MFT_file_names_table)
                        
                        # Create loading overlay
                        if not hasattr(self, 'MFT_file_names_loading_overlay'):
                            self.MFT_file_names_loading_overlay = TableLoadingOverlay(self.MFT_file_names_table)
                        
                        self.MFT_file_names_table.loading_started.connect(
                            lambda: self.MFT_file_names_loading_overlay.show_loading("Loading...")
                        )
                        self.MFT_file_names_table.loading_finished.connect(
                            lambda: self.MFT_file_names_loading_overlay.hide_loading()
                        )
                        
                        self.MFT_file_names_loading_overlay.show_loading("Loading file names...")
                        success = self.MFT_file_names_table.load_initial_data()
                        
                        if success:
                            print(f"[MFT] Successfully initialized file names virtual table with {total_records:,} records")
                        
                        self.MFT_file_names_loading_overlay.hide_loading()
                except Exception as e:
                    error_msg = f"[MFT] Error loading mft_file_names table: {str(e)}"
                    print(error_msg)
                    import traceback
                    traceback.print_exc()
                    self._call_progress_callback(progress_callback, error_msg)
            else:
                print("[MFT] mft_file_names table not found in database")
            
            # Load MFT Data Attributes table using VirtualTableWidget
            print("[MFT] Loading mft_data_attributes table with virtual scrolling...")
            if mft_loader.table_exists('mft_data_attributes'):
                try:
                    table_stats = stats.get('mft_data_attributes', {})
                    total_records = table_stats.get('row_count', 0)
                    
                    print(f"[MFT] Found {total_records:,} data attribute records, using virtual scrolling")
                    self._call_progress_callback(progress_callback, f"[MFT] Initializing virtual table for {total_records:,} data attribute records...")
                    
                    if hasattr(self, 'MFT_data_attributes_table') and total_records > 0:
                        columns = mft_loader.get_columns('mft_data_attributes')
                        
                        # Replace old table with VirtualTableWidget
                        old_table = self.MFT_data_attributes_table
                        layout = self.verticalLayout_mft_data
                        layout.removeWidget(old_table)
                        old_table.deleteLater()
                        
                        self.MFT_data_attributes_table = VirtualTableWidget(
                            data_loader=self.mft_loader,
                            table_name='mft_data_attributes',
                            columns=columns,
                            page_size=5000,
                            buffer_size=10000,
                            parent=self.MFT_data_attributes_tab
                        )
                        
                        # Apply Crow Eye table styles
                        CrowEyeStyles.apply_table_styles(self.MFT_data_attributes_table)
                        
                        layout.addWidget(self.MFT_data_attributes_table)
                        
                        # Create loading overlay
                        if not hasattr(self, 'MFT_data_attributes_loading_overlay'):
                            self.MFT_data_attributes_loading_overlay = TableLoadingOverlay(self.MFT_data_attributes_table)
                        
                        self.MFT_data_attributes_table.loading_started.connect(
                            lambda: self.MFT_data_attributes_loading_overlay.show_loading("Loading...")
                        )
                        self.MFT_data_attributes_table.loading_finished.connect(
                            lambda: self.MFT_data_attributes_loading_overlay.hide_loading()
                        )
                        
                        self.MFT_data_attributes_loading_overlay.show_loading("Loading data attributes...")
                        success = self.MFT_data_attributes_table.load_initial_data()
                        
                        if success:
                            print(f"[MFT] Successfully initialized data attributes virtual table with {total_records:,} records")
                        
                        self.MFT_data_attributes_loading_overlay.hide_loading()
                except Exception as e:
                    error_msg = f"[MFT] Error loading mft_data_attributes table: {str(e)}"
                    print(error_msg)
                    import traceback
                    traceback.print_exc()
                    self._call_progress_callback(progress_callback, error_msg)
            else:
                print("[MFT] mft_data_attributes table not found in database")
            
            success_msg = f"[MFT] All MFT data loaded successfully from {db_path}"
            print(success_msg)
            self._call_progress_callback(progress_callback, success_msg)
            
        except MemoryError as e:
            error_msg = f"[MFT] Memory error - dataset too large: {str(e)}"
            print(error_msg)
            self._call_progress_callback(progress_callback, error_msg)
        except Exception as e:
            error_msg = f"[MFT] Error loading data: {str(e)} (Type: {type(e).__name__})"
            print(error_msg)
            self._call_progress_callback(progress_callback, error_msg)
        finally:
            # NOTE: Do NOT disconnect the loader here!
            # The VirtualTableWidget needs the connection to stay alive
            # to load data on-demand as the user scrolls.
            # The loader will be stored in self.mft_loader and will be
            # disconnected when the case is closed or the application exits.
            pass

    def load_usn_data(self, progress_callback=None):
        """Load USN Journal data from the USN database using VirtualTableWidget for efficient memory usage"""
        # Import required modules
        try:
            from data.usn_loader import USNDataLoader
            from ui.virtual_table_widget import VirtualTableWidget
            from ui.progress_indicator import TableLoadingOverlay
            from styles import CrowEyeStyles
        except ImportError as e:
            error_msg = f"[USN] Failed to import required modules: {str(e)}"
            print(error_msg)
            self._call_progress_callback(progress_callback, error_msg)
            return
        
        try:
            # Get the database path from case configuration
            if not hasattr(self, 'case_paths') or not self.case_paths:
                error_msg = "[USN] No active case found"
                print(error_msg)
                self._call_progress_callback(progress_callback, error_msg)
                return
                
            db_path = self.case_paths.get('databases', {}).get('usn')
            if not db_path:
                error_msg = "[USN] Database path not found in case configuration"
                print(error_msg)
                self._call_progress_callback(progress_callback, error_msg)
                return
                
            # Check if database exists
            if not os.path.exists(db_path):
                error_msg = f"[USN] Database not found at: {db_path}"
                print(error_msg)
                self._call_progress_callback(progress_callback, error_msg)
                return
            
            # Initialize USN data loader
            print(f"[USN] Initializing USNDataLoader for database: {db_path}")
            usn_loader = USNDataLoader(db_path)
            
            # Connect to database
            if not usn_loader.connect():
                error_msg = f"[USN] Failed to connect to database: {db_path}"
                print(error_msg)
                self._call_progress_callback(progress_callback, error_msg)
                return
            
            print(f"[USN] Successfully connected to database")
            
            # Check if table exists
            if not usn_loader.table_exists('journal_events'):
                error_msg = "[USN] journal_events table not found in database"
                print(error_msg)
                self._call_progress_callback(progress_callback, error_msg)
                usn_loader.disconnect()
                return
            
            # Get table statistics
            stats = usn_loader.get_table_statistics('journal_events')
            total_records = stats.get('row_count', 0)
            
            print(f"[USN] Found {total_records:,} USN records, using virtual scrolling for efficient loading")
            self._call_progress_callback(progress_callback, f"[USN] Initializing virtual table for {total_records:,} USN records...")
            
            if hasattr(self, 'USN_table') and total_records > 0:
                # Get columns
                columns = usn_loader.get_columns('journal_events')
                
                # Store the loader so it stays alive for virtual scrolling
                self.usn_loader = usn_loader
                
                # Replace the old table with VirtualTableWidget
                old_table = self.USN_table
                layout = self.verticalLayout_usn
                layout.removeWidget(old_table)
                old_table.deleteLater()
                
                # Create new VirtualTableWidget
                # USN can handle larger pages due to smaller row size
                self.USN_table = VirtualTableWidget(
                    data_loader=self.usn_loader,
                    table_name='journal_events',
                    columns=columns,
                    page_size=10000,
                    buffer_size=20000,
                    parent=self.USN_tab
                )
                
                # Set default ordering
                self.USN_table.set_order_by('usn ASC')
                
                # Apply Crow Eye table styles
                CrowEyeStyles.apply_table_styles(self.USN_table)
                
                # Add to layout
                layout.addWidget(self.USN_table)
                
                # Create loading overlay
                if not hasattr(self, 'USN_loading_overlay'):
                    self.USN_loading_overlay = TableLoadingOverlay(self.USN_table)
                
                # Connect signals
                self.USN_table.loading_started.connect(
                    lambda: self.USN_loading_overlay.show_loading("Loading USN data...")
                )
                self.USN_table.loading_finished.connect(
                    lambda: self.USN_loading_overlay.hide_loading()
                )
                
                # Load initial data
                self.USN_loading_overlay.show_loading("Loading USN records...")
                success = self.USN_table.load_initial_data()
                
                if success:
                    loaded_rows = self.USN_table.get_loaded_row_count()
                    print(f"[USN] Successfully initialized virtual table with {total_records:,} records ({loaded_rows:,} in memory)")
                    self._call_progress_callback(progress_callback, f"[USN] Loaded {total_records:,} records (virtual scrolling enabled)")
                else:
                    print("[USN] Failed to load initial data")
                    self._call_progress_callback(progress_callback, "[USN] Failed to load data")
                
                self.USN_loading_overlay.hide_loading()
            else:
                print("[USN] USN_table widget not found or no records to load")
                
        except Exception as e:
            error_msg = f"[USN] Error loading data: {str(e)}"
            print(error_msg)
            import traceback
            traceback.print_exc()
            self._call_progress_callback(progress_callback, error_msg)

    def load_correlated_data(self, progress_callback=None):
        """Load correlated MFT-USN data from the correlated database using VirtualTableWidget for efficient memory usage"""
        # Import required modules
        try:
            from data.correlated_loader import CorrelatedDataLoader
            from ui.virtual_table_widget import VirtualTableWidget
            from ui.progress_indicator import TableLoadingOverlay
            from styles import CrowEyeStyles
        except ImportError as e:
            error_msg = f"[Correlated] Failed to import required modules: {str(e)}"
            print(error_msg)
            self._call_progress_callback(progress_callback, error_msg)
            return
        
        try:
            # Get the database path from case configuration
            if not hasattr(self, 'case_paths') or not self.case_paths:
                error_msg = "[Correlated] No active case found"
                print(error_msg)
                self._call_progress_callback(progress_callback, error_msg)
                return
                
            db_path = self.case_paths.get('databases', {}).get('mft_usn_correlated')
            if not db_path:
                error_msg = "[Correlated] Database path not found in case configuration"
                print(error_msg)
                self._call_progress_callback(progress_callback, error_msg)
                return
                
            # Check if database exists
            if not os.path.exists(db_path):
                error_msg = f"[Correlated] Database not found at: {db_path}"
                print(error_msg)
                self._call_progress_callback(progress_callback, error_msg)
                return
            
            # Initialize Correlated data loader
            print(f"[Correlated] Initializing CorrelatedDataLoader for database: {db_path}")
            corr_loader = CorrelatedDataLoader(db_path)
            
            # Connect to database
            if not corr_loader.connect():
                error_msg = f"[Correlated] Failed to connect to database: {db_path}"
                print(error_msg)
                self._call_progress_callback(progress_callback, error_msg)
                return
            
            print(f"[Correlated] Successfully connected to database")
            
            # Check if table exists
            if not corr_loader.table_exists('mft_usn_correlated'):
                error_msg = "[Correlated] mft_usn_correlated table not found in database"
                print(error_msg)
                self._call_progress_callback(progress_callback, error_msg)
                corr_loader.disconnect()
                return
            
            # Get table statistics
            stats = corr_loader.get_table_statistics('mft_usn_correlated')
            total_records = stats.get('row_count', 0)
            
            print(f"[Correlated] Found {total_records:,} correlated records, using virtual scrolling for efficient loading")
            self._call_progress_callback(progress_callback, f"[Correlated] Initializing virtual table for {total_records:,} correlated records...")
            
            if hasattr(self, 'Correlated_table') and total_records > 0:
                # Get columns
                columns = corr_loader.get_columns('mft_usn_correlated')
                
                # Store the loader so it stays alive for virtual scrolling
                self.corr_loader = corr_loader
                
                # Replace the old table with VirtualTableWidget
                old_table = self.Correlated_table
                layout = self.verticalLayout_correlated
                layout.removeWidget(old_table)
                old_table.deleteLater()
                
                # Create new VirtualTableWidget
                self.Correlated_table = VirtualTableWidget(
                    data_loader=self.corr_loader,
                    table_name='mft_usn_correlated',
                    columns=columns,
                    page_size=5000,
                    buffer_size=10000,
                    parent=self.Correlated_tab
                )
                
                # Set default ordering - check if timestamp column exists
                if 'timestamp' in columns:
                    self.Correlated_table.set_order_by('timestamp DESC')
                elif 'mft_record_number' in columns:
                    self.Correlated_table.set_order_by('mft_record_number ASC')
                
                # Apply Crow Eye table styles
                CrowEyeStyles.apply_table_styles(self.Correlated_table)
                
                # Add to layout
                layout.addWidget(self.Correlated_table)
                
                # Create loading overlay
                if not hasattr(self, 'Correlated_loading_overlay'):
                    self.Correlated_loading_overlay = TableLoadingOverlay(self.Correlated_table)
                
                # Connect signals
                self.Correlated_table.loading_started.connect(
                    lambda: self.Correlated_loading_overlay.show_loading("Loading correlated data...")
                )
                self.Correlated_table.loading_finished.connect(
                    lambda: self.Correlated_loading_overlay.hide_loading()
                )
                
                # Load initial data
                self.Correlated_loading_overlay.show_loading("Loading correlated records...")
                success = self.Correlated_table.load_initial_data()
                
                if success:
                    loaded_rows = self.Correlated_table.get_loaded_row_count()
                    print(f"[Correlated] Successfully initialized virtual table with {total_records:,} records ({loaded_rows:,} in memory)")
                    self._call_progress_callback(progress_callback, f"[Correlated] Loaded {total_records:,} records (virtual scrolling enabled)")
                else:
                    print("[Correlated] Failed to load initial data")
                    self._call_progress_callback(progress_callback, "[Correlated] Failed to load data")
                
                self.Correlated_loading_overlay.hide_loading()
            else:
                print("[Correlated] Correlated_table widget not found or no records to load")
                
        except Exception as e:
            error_msg = f"[Correlated] Error loading data: {str(e)}"
            print(error_msg)
            import traceback
            traceback.print_exc()
            self._call_progress_callback(progress_callback, error_msg)
    
    # ============================================================================
# ENHANCED GROUPED DATA LOADING METHODS
# ============================================================================

# ============================================================================
# ROW DETAIL DIALOG FUNCTIONALITY
# ============================================================================
    
    def handle_table_double_click(self, item):
        """
        Handle double-click events on table rows.
        
        This method extracts data from the clicked row and displays it in a detail dialog.
        
        Args:
            item: The QTableWidgetItem that was double-clicked
        """
        if not item:
            return
            
        # Get the table widget that contains this item
        table = item.tableWidget()
        if not table:
            return
            
        # Get the table name from its object name
        table_name = table.objectName()
        display_name = table_name.replace("_table", "").replace("_", " ").title()
        
        # Get the row data
        row_data = {}
        row = item.row()
        
        # Extract header labels and row values
        for col in range(table.columnCount()):
            header_item = table.horizontalHeaderItem(col)
            if header_item:
                header_text = header_item.text()
                cell_item = table.item(row, col)
                if cell_item:
                    row_data[header_text] = cell_item.text()
        
        # Create and show the detail dialog
        from ui.row_detail_dialog import RowDetailDialog
        dialog = RowDetailDialog(self, display_name, row_data)
        dialog.show()
        
    def connect_table_double_click_events(self):
        """
        Connect double-click events to all table widgets in the application.
        """
        tables = self.find_all_table_widgets()
        for table in tables:
            # Disconnect any existing connections to avoid duplicates
            try:
                table.itemDoubleClicked.disconnect()
            except:
                pass
            # Connect the double-click event
            table.itemDoubleClicked.connect(self.handle_table_double_click)
    
    def load_enhanced_allReg_data(self):
        """Load all registry data using enhanced methods with cyberpunk loading"""
        def run_registry_loading():
            print("[Registry] Loading Network Lists...")
            self.load_data_from_database_NetworkLists()
            print("[Registry] Loading Network Interfaces...")
            self.load_data_from_database_NetworkInterfaces()
            print("[Registry] Loading Computer Name...")
            self.load_data_from_database_ComputerName()
            print("[Registry] Loading Timezone...")
            self.load_data_from_database_Timezone()
            print("[Registry] Loading Last Update...")
            self.load_data_from_database_LastUpdate()
            print("[Registry] Loading Last Update Subkeys...")
            self.load_data_from_database_LastUpdate_subkeys()
            print("[Registry] Loading Shutdown Info...")
            self.load_data_from_database_shutdowninfo()
            print("[Registry] Loading Machine Run...")
            self.load_data_from_database_MachineRun()
            print("[Registry] Loading Machine Run Once...")
            self.load_data_from_database_MachineRuneOnce()
            print("[Registry] Loading User Run...")
            self.load_data_from_database_UserRun()
            print("[Registry] Loading User Run Once...")
            self.load_data_from_database_UserRunOnce()
            print("[Registry] All registry data loaded successfully")
        
        # Use cyberpunk loading dialog
        self.show_loading_screen_with_function(
            "LOADING REGISTRY DATA",
            run_registry_loading
        )
    
    
    
    def setup_table_headers(self, table, column_count):
        """Helper function to setup table headers - reduces code duplication"""
        try:
            if not table:
                print("Error: Table widget is None")
                return
                
            # First clear existing headers
            table.setColumnCount(0)
            table.setColumnCount(column_count)
            table.setRowCount(0)
            
            # Configure header appearance
            header = table.horizontalHeader()
            if not header:
                print("Error: Could not get horizontal header")
                return
                
            # Default header color variant; can be overridden per-table later
            try:
                header.setObjectName("header_blue")
            except Exception:
                pass
            
            # Set default header items
            for i in range(column_count):
                item = QtWidgets.QTableWidgetItem()
                item.setTextAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
                item.setFont(self.create_standard_font("Segoe UI", 9, True, False))
                table.setHorizontalHeaderItem(i, item)
            
            # Apply header styles
            header.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)

            # Enhanced resizing configuration
            header.setDefaultSectionSize(180)
            header.setMinimumSectionSize(60)
            header.setSectionsClickable(True)
            header.setSortIndicatorShown(True)
            header.setSectionsMovable(True)
            header.setSectionResizeMode(QtWidgets.QHeaderView.Interactive)
            header.setStretchLastSection(False)  # Allow manual resizing of all columns
            
            # Force style update with additional header-specific styling
            header.setAttribute(QtCore.Qt.WA_StyledBackground, True)
            header.style().unpolish(header)
            header.style().polish(header)
            
            # Safely update viewport
            viewport = header.viewport()
            if viewport:
                viewport.update()
            else:
                print("Warning: Header viewport not available")
                
        except Exception as e:
            print(f"Error setting up table: {str(e)}")
            return
    
    def load_registry_data_to_table(self, table_name, table_widget, db_path='registry_data_live.db'):
        """Generic helper function to load data from database to table widget with proper validation"""
        conn = None
        try:
            # Validate database path
            if not os.path.exists(db_path):
                print(f"[Database Error] Database file not found: {db_path}")
                return False
            
            # Disable updates during loading
            was_updates_enabled = table_widget.updatesEnabled()
            table_widget.setUpdatesEnabled(False)
            
            # Clear existing data
            table_widget.setRowCount(0)
            
            # Connect to database
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Schema validation - check if table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?;", (table_name,))
            if not cursor.fetchone():
                print(f"[Database Error] Table '{table_name}' does not exist in database: {db_path}")
                return False
            
            # Get table schema for validation
            cursor.execute(f"PRAGMA table_info({table_name});")
            columns_info = cursor.fetchall()
            if not columns_info:
                print(f"[Database Error] Unable to retrieve schema for table '{table_name}'")
                return False
            
            # Extract column names and identify ID columns to move to end
            columns = [column[1] for column in columns_info]
            
            # Identify ID columns (case-insensitive match)
            id_columns = [col for col in columns if col.lower() in ['uid', 'guid', 'id', 'uuid']]
            other_columns = [col for col in columns if col.lower() not in ['uid', 'guid', 'id', 'uuid']]
            
            # Reorder columns to move ID columns to the end
            reordered_columns = other_columns + id_columns
            
            # Create a mapping from old column index to new column index
            col_mapping = [columns.index(col) for col in reordered_columns]
            
            # Fetch data
            cursor.execute(f"SELECT * FROM {table_name}")
            data = cursor.fetchall()
            
            if not data:
                print(f"[Database Info] No data found in table '{table_name}'")
                table_widget.setUpdatesEnabled(was_updates_enabled) 
                return True  # Empty table is still a success
                
            # Validate data consistency
            if data and len(data[0]) != len(columns):
                print(f"[Database Error] Data column count mismatch in table '{table_name}'")
                return False
            
            # Set column count and headers with reordered columns
            if table_widget.columnCount() != len(reordered_columns):
                table_widget.setColumnCount(len(reordered_columns))
                table_widget.setHorizontalHeaderLabels(reordered_columns)
            
            # Populate data in batches for better performance
            batch_size = 1000
            table_widget.setRowCount(len(data))
            
            for i in range(0, len(data), batch_size):
                batch = data[i:i + batch_size]
                for row_index, row_data in enumerate(batch, start=i):
                    # Reorder the row data according to the new column order
                    reordered_row = [row_data[col_idx] for col_idx in col_mapping]
                    for col_index, cell_data in enumerate(reordered_row):
                        item = QtWidgets.QTableWidgetItem(str(cell_data) if cell_data is not None else "")
                        item.setFlags(item.flags() & ~Qt.ItemIsEditable)  # Make cells read-only
                        table_widget.setItem(row_index, col_index, item)
                
                # Process events periodically to keep UI responsive
                if i % batch_size == 0:
                    QtWidgets.QApplication.processEvents()
            
            # Resize columns to fit content
            table_widget.resizeColumnsToContents()
            
            # Apply styles after data is loaded
            table_widget.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
            table_widget.horizontalHeader().setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
            
            # Force style update
            table_widget.style().unpolish(table_widget)
            table_widget.style().polish(table_widget)
            
            # Restore updates state
            table_widget.setUpdatesEnabled(was_updates_enabled)
            
            # Trigger a repaint
            table_widget.viewport().update()
            
            print(f"[Database Success] Loaded {len(data)} records from '{table_name}'")
            return True
            
        except sqlite3.DatabaseError as e:
            print(f"[Database Error] SQLite error loading '{table_name}': {str(e)}")
            return False
        except Exception as e:
            print(f"[Database Error] Unexpected error loading '{table_name}': {str(e)}")
            return False
        finally:
            # Ensure connection is always closed
            if conn:
                try:
                    conn.close()
                except:
                    pass
            
            # Restore updates state even if there was an error
            if 'was_updates_enabled' in locals():
                table_widget.setUpdatesEnabled(was_updates_enabled)
    
    def show_database_error(self, title, db_path, error_msg=None):
        """Helper function to show database error messages - reduces code duplication"""
        if error_msg:
            message = f"Failed to load {title.lower()}: {error_msg}"
            print(f"[{title} Error] {message}")
        else:
            message = f"Database file not found: {db_path}"
            print(f"[{title} Error] {message}")
        
        self.show_error_message(title, message, "warning")
    
    def load_data_with_error_handling(self, db_path, table_name, table_widget, title):
        """Generic helper for loading data with consistent error handling"""
        try:
            print(f"[{title}] Loading from database: {db_path}")
            if not os.path.exists(db_path):
                self.show_database_error(title, db_path)
                return
            
            self.load_registry_data_to_table(table_name, table_widget, db_path)
            print(f"[{title}] Successfully loaded records")
        except Exception as e:
            self.show_database_error(title, db_path, str(e))
    
    def get_log_db_path(self):
        """Helper function to get Log_Claw.db path - reduces code duplication"""
        db_path = 'Log_Claw.db'
        if hasattr(self, 'case_paths') and self.case_paths:
            artifacts_dir = self.case_paths.get('artifacts_dir')
            if artifacts_dir and os.path.exists(artifacts_dir):
                db_path = os.path.join(artifacts_dir, 'Log_Claw.db')
        return db_path
    
    def get_registry_db_path(self):
        """Helper function to get registry_data.db path based on current case"""
        db_path = 'registry_data.db'
        if hasattr(self, 'case_paths') and self.case_paths:
            artifacts_dir = self.case_paths.get('artifacts_dir')
            if artifacts_dir and os.path.exists(artifacts_dir):
                db_path = os.path.join(artifacts_dir, 'registry_data.db')
        return db_path
    
    def get_lnk_db_path(self):
        """Helper function to get LnkDB.db path - reduces code duplication"""
        db_path = 'LnkDB.db'
        if hasattr(self, 'case_paths') and self.case_paths:
            artifacts_dir = self.case_paths.get('artifacts_dir')
            if artifacts_dir and os.path.exists(artifacts_dir):
                db_path = os.path.join(artifacts_dir, 'LnkDB.db')
        return db_path
        
    def get_shimcache_db_path(self):
        """Helper function to get shimcache.db path based on current case"""
        db_path = 'shimcache.db'
        if hasattr(self, 'case_paths') and self.case_paths:
            artifacts_dir = self.case_paths.get('artifacts_dir')
            if artifacts_dir and os.path.exists(artifacts_dir):
                db_path = os.path.join(artifacts_dir, 'shimcache.db')
        return db_path
        
    def load_shimcache_data(self):
        """Load ShimCache data from database to table"""
        try:
            # Get the database path based on current case
            db_path = self.get_shimcache_db_path()
            
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[ShimCache] Database not found at: {db_path}")
                print(f"[ShimCache] Please run ShimCache analysis first to create the database")
                return
            
            # Connect to database
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if shimcache_entries table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='shimcache_entries'")
            if not cursor.fetchone():
                print(f"[ShimCache] shimcache_entries table not found in database: {db_path}")
                conn.close()
                return
                
            # Query to get all ShimCache entries
            cursor.execute("""SELECT filename, path, last_modified, last_modified_readable, parsed_timestamp 
                          FROM shimcache_entries ORDER BY last_modified DESC""")
            rows = cursor.fetchall()
            
            # Load data into the main ShimCache table
            if hasattr(self, 'ShimCache_main_table'):
                # Disable updates during loading for performance
                was_updates_enabled = self.ShimCache_main_table.updatesEnabled()
                self.ShimCache_main_table.setUpdatesEnabled(False)
                
                # Set column headers if not already set
                if self.ShimCache_main_table.columnCount() != 5:
                    self.ShimCache_main_table.setColumnCount(5)
                    headers = ["Filename", "Path", "Last Modified (Epoch)", "Last Modified", "Parsed Timestamp"]
                    self.ShimCache_main_table.setHorizontalHeaderLabels(headers)
                
                # Clear existing rows
                self.ShimCache_main_table.setRowCount(0)
                
                # Add data in batches for better performance
                batch_size = 100
                for i, row in enumerate(rows):
                    row_index = self.ShimCache_main_table.rowCount()
                    self.ShimCache_main_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                        item.setFlags(item.flags() & ~Qt.ItemIsEditable)  # Make cells read-only
                        self.ShimCache_main_table.setItem(row_index, col_index, item)
                    
                    # Process events periodically to keep UI responsive
                    if (i + 1) % batch_size == 0:
                        QtWidgets.QApplication.processEvents()
                
                # Re-enable updates and resize columns to content
                self.ShimCache_main_table.setUpdatesEnabled(was_updates_enabled)
                self.ShimCache_main_table.resizeColumnsToContents()
                
                print(f"[ShimCache] Loaded {len(rows)} records into main ShimCache table")
            
            conn.close()
        except Exception as e:
            print(f"[ShimCache] Error loading data: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def create_crow_eye_dialog(self, title, style_sheet=None):
        """Helper function to create standardized Crow Eye dialogs - reduces code duplication"""
        dialog = QtWidgets.QDialog(self.main_window)
        dialog.setWindowTitle(f"Crow Eye - {title}")
        dialog.setWindowIcon(QtGui.QIcon(":/Icons/CrowEye.ico"))
        dialog.setModal(True)
        
        if style_sheet:
            dialog.setStyleSheet(style_sheet)
        
        return dialog
    
    def add_logo_section(self, layout, logo_size=(100, 100)):
        """Helper function to add logo section to dialogs - reduces code duplication"""
        # Logo section
        logo_frame = QtWidgets.QFrame()
        logo_frame.setObjectName("logo_frame")
        logo_layout = QtWidgets.QHBoxLayout(logo_frame)
        logo_layout.setAlignment(Qt.AlignCenter)
        
        # Add Crow Eye logo
        logo_label = QtWidgets.QLabel()
        logo_label.setAlignment(Qt.AlignCenter)
        
        # Load logo using helper function
        logo_pixmap = self.load_logo_pixmap(logo_size)
        logo_pixmap = logo_pixmap.scaled(logo_size[0], logo_size[1], Qt.KeepAspectRatio, Qt.SmoothTransformation)
        logo_label.setPixmap(logo_pixmap)
        logo_layout.addWidget(logo_label)
        
        layout.addWidget(logo_frame)
        return logo_frame
    
    def create_standard_font(self, family="MS Shell Dlg 2", size=10, bold=True, italic=False):
        """Helper function to create standardized fonts - reduces code duplication"""
        font = QtGui.QFont()
        font.setFamily(family)
        font.setPointSize(size)
        font.setBold(bold)
        font.setItalic(italic)
        if bold:
            font.setWeight(75)
        return font
    
    def create_rockwell_font(self, size=8, bold=False):
        """Helper function to create Rockwell Extra Bold fonts - reduces code duplication"""
        font = QtGui.QFont()
        font.setFamily("Rockwell Extra Bold")
        font.setPointSize(size)
        font.setBold(bold)
        return font
    
    def setup_sidebar_button(self, button, checkable=True, checked=True, default=False):
        """Helper function to setup sidebar buttons with consistent configuration - reduces code duplication"""
        button.setStyleSheet(CrowEyeStyles.SIDEBAR_BUTTON)
        button.setCheckable(checkable)
        button.setChecked(checked)
        if default:
            button.setDefault(True)
        return button
    
    def setup_parse_button(self, button, checkable=True, checked=False, default=False, style='green'):
        """Helper function to setup parse buttons (LNK, Logs, offline analysis) with consistent styling
        
        Args:
            button: The button widget to style
            checkable: Whether the button is checkable
            checked: Initial checked state
            default: Whether this is the default button
            style: Button style ('green' or 'red')
        """
        # Apply appropriate style based on the style parameter
        if style.lower() == 'red':
            button.setStyleSheet(CrowEyeStyles.RED_BUTTON)
        else:  # Default to parser button style (Blue)
            button.setStyleSheet(CrowEyeStyles.PARSER_BUTTON)
            
        button.setCheckable(checkable)
        button.setChecked(checked)
        button.setDefault(default)
        button.setCursor(QtCore.Qt.PointingHandCursor)
        
        # Set font
        font = QtGui.QFont()
        font.setFamily("MS Shell Dlg 2")
        font.setPointSize(9)
        font.setBold(True)
        button.setFont(font)
        
        # Set size policy
        size_policy = QtWidgets.QSizePolicy(
            QtWidgets.QSizePolicy.Preferred,
            QtWidgets.QSizePolicy.Preferred
        )
        size_policy.setHorizontalStretch(0)
        size_policy.setVerticalStretch(0)
        size_policy.setHeightForWidth(button.sizePolicy().hasHeightForWidth())
        button.setSizePolicy(size_policy)
        button.setMinimumSize(QtCore.QSize(100, 30))
        button.setMaximumSize(QtCore.QSize(200, 16777215))
        
        # Set focus policy
        button.setFocusPolicy(QtCore.Qt.StrongFocus)
        
        # Set tooltip
        button.setToolTip("Click to parse data")
        
        # Force style update
        button.style().unpolish(button)
        button.style().polish(button)
        button.update()
        
        return button
    
    def refresh_all_tables(self):
        """Refresh all tables in the application with current styles"""
        try:
            # Find all table widgets
            tables = [getattr(self, name) for name in dir(self) 
                     if isinstance(getattr(self, name), QtWidgets.QTableWidget)]
            
            # Process each table with a small delay between them
            for i, table in enumerate(tables):
                QtCore.QTimer.singleShot(i * 100, lambda t=table: self._refresh_table(t))
                
        except Exception as e:
            print(f"Error in refresh_all_tables: {str(e)}")
    
    def _refresh_table(self, table):
        """Internal method to refresh a single table's styles"""
        if not table or not table.isVisible():
            return
            
        # Store current state
        was_updates_enabled = table.updatesEnabled()
        h_scroll = table.horizontalScrollBar().value()
        v_scroll = table.verticalScrollBar().value()
        
        # Disable updates during refresh
        table.setUpdatesEnabled(False)
        
        # Define restore_scroll function before try block
        def restore_scroll():
            try:
                if not table:
                    return
                    
                # Update geometry first
                table.updateGeometry()
                
                # Restore scroll positions
                if h_scroll < table.horizontalScrollBar().maximum():
                    table.horizontalScrollBar().setValue(h_scroll)
                if v_scroll < table.verticalScrollBar().maximum():
                    table.verticalScrollBar().setValue(v_scroll)
                
                # Final style refresh
                table.style().unpolish(table)
                table.style().polish(table)
                
                # Update viewport
                viewport = table.viewport()
                if viewport:
                    viewport.update()
                    
                # Force a complete repaint
                table.update()
            except Exception as e:
                print(f"Error in restore_scroll: {str(e)}")
            finally:
                table.setUpdatesEnabled(was_updates_enabled)
        
        try:
            # Clear and reapply styles
            table.setStyleSheet('')
            
            # Apply base table style using unified style
            table.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
            
            # Apply styles to header
            header = table.horizontalHeader()
            if header:
                header.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
                header.setDefaultAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            
            # Apply styles to viewport
            viewport = table.viewport()
            if viewport:
                viewport.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
            
            # Force style update
            table.style().unpolish(table)
            table.style().polish(table)
            
            # Update all items' styles
            for row in range(table.rowCount()):
                for col in range(table.columnCount()):
                    item = table.item(row, col)
                    if item:
                        item.setFlags(item.flags() & ~Qt.ItemIsEditable)
            
            # Ensure proper rendering
            table.update()
            # Get viewport after table is set up
            viewport = table.viewport()
            if viewport:
                viewport.update()
            
            # Schedule the scroll restoration
            QtCore.QTimer.singleShot(50, restore_scroll)
            
        except Exception as e:
            print(f"Error refreshing table: {str(e)}")
            table.setUpdatesEnabled(was_updates_enabled)
    
    def apply_table_styles(self, table):
        """Apply styles to the table after it has been populated"""
        if not table:
            return
            
        try:
            # Store current update state
            was_updates_enabled = table.updatesEnabled()
            table.setUpdatesEnabled(False)
            
            # Apply base styles using the new unified style
            table.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
            
            # Update header styles
            header = table.horizontalHeader()
            if header:
                header.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
                header.setDefaultAlignment(Qt.AlignLeft | Qt.AlignVCenter)
                # Preserve existing per-table resize behavior (e.g., ResizeToContents)
                # Do not override section resize mode here
                header.setAttribute(Qt.WA_StyledBackground, True)
                header.setVisible(True)
                header.style().unpolish(header)
                header.style().polish(header)
                header.update()
            
            # Make vertical header resizable too
            vertical_header = table.verticalHeader()
            if vertical_header:
                vertical_header.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
                vertical_header.setSectionResizeMode(QtWidgets.QHeaderView.Interactive)
                vertical_header.setAttribute(Qt.WA_StyledBackground, True)
                vertical_header.setVisible(True)
                # Ensure the vertical header (row numbers) fits big numbers
                try:
                    total_rows = max(1, table.rowCount())
                    # Calculate width based on number of digits
                    digits = len(str(total_rows))
                    fm = table.fontMetrics()
                    # Base width on widest digit string plus padding
                    widest_text = "9" * digits
                    text_width = fm.horizontalAdvance(widest_text)
                    padding = 16  # extra padding for style and spacing
                    vheader_width = text_width + padding
                    # Apply a reasonable min/max guard
                    vheader_width = max(40, min(vheader_width, 140))
                    vertical_header.setMinimumWidth(vheader_width)
                    vertical_header.setMaximumWidth(vheader_width)
                    vertical_header.setDefaultAlignment(Qt.AlignRight | Qt.AlignVCenter)
                except Exception:
                    # Fallback to a safe default width
                    try:
                        vertical_header.setMinimumWidth(60)
                        vertical_header.setMaximumWidth(100)
                        vertical_header.setDefaultAlignment(Qt.AlignRight | Qt.AlignVCenter)
                    except:
                        pass
                vertical_header.style().unpolish(vertical_header)
                vertical_header.style().polish(vertical_header)
                vertical_header.update()
            
            # Update viewport styles
            viewport = table.viewport()
            if viewport:
                viewport.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
                viewport.update()
            
            # Force style updates
            table.style().unpolish(table)
            table.style().polish(table)
            
            # Update all items' styles and make them read-only
            for row in range(table.rowCount()):
                for col in range(table.columnCount()):
                    item = table.item(row, col)
                    if item:
                        item.setFlags((item.flags() & ~Qt.ItemIsEditable) | Qt.ItemIsEnabled)
            
            # Ensure proper rendering
            table.update()
            if viewport:
                viewport.update()
                
        except Exception as e:
            print(f"Error applying table styles: {str(e)}")
            
        finally:
            # Always restore update state
            table.setUpdatesEnabled(was_updates_enabled)

    # --- Sidebar toggle animation ---
    def toggle_sidebar(self, checked=False):
        try:
            if not hasattr(self, "_sidebar_anim"):
                self._sidebar_anim = QtCore.QPropertyAnimation(self.side_fram, b"maximumWidth")
                self._sidebar_anim.setDuration(260)
                self._sidebar_anim.setEasingCurve(QtCore.QEasingCurve.InOutCubic)
                # After animation completes, normalize min width to the target to avoid re-collapse by layout
                def _on_sidebar_anim_finished():
                    try:
                        target = getattr(self, "_sidebar_target", None)
                        if target is not None:
                            if target > 0:
                                self.side_fram.setMinimumWidth(target)
                                self.side_fram.setMaximumWidth(target)
                                self.side_fram.setVisible(True)
                            else:
                                # Fully collapsed: set max to 0 and hide
                                self.side_fram.setMinimumWidth(0)
                                self.side_fram.setMaximumWidth(0)
                                self.side_fram.setVisible(False)
                    except Exception:
                        pass
                self._sidebar_anim.finished.connect(_on_sidebar_anim_finished)
                # During animation, keep min/max synced to current value so it can reach 0 exactly
                def _on_sidebar_anim_value_changed(value):
                    try:
                        w = int(value)
                        self.side_fram.setMinimumWidth(w)
                        self.side_fram.setMaximumWidth(w)
                    except Exception:
                        pass
                try:
                    self._sidebar_anim.valueChanged.connect(_on_sidebar_anim_value_changed)
                except Exception:
                    pass

            # Define collapsed/expanded sizes (fully collapse to 0)
            collapsed = 0
            # Determine full width based on sizeHint if available
            if not hasattr(self, "_sidebar_full_width") or not self._sidebar_full_width:
                hint = max(240, self.side_fram.sizeHint().width())
                self._sidebar_full_width = hint
            expanded = self._sidebar_full_width

            # Ensure current constraints
            self.side_fram.setMinimumWidth(0)
            # Do not clamp max to current width; allow full expansion target
            # We'll animate the maximumWidth property between collapsed and expanded

            current = self.side_fram.maximumWidth()
            if not current:
                current = self.side_fram.width()
            end = expanded if (checked or not hasattr(self, "_sidebar_expanded") or not self._sidebar_expanded) else collapsed

            self._sidebar_anim.stop()
            # Ensure frame is visible before expanding, so animation is seen
            if end > 0:
                self.side_fram.setVisible(True)
            self._sidebar_anim.setStartValue(current)
            self._sidebar_anim.setEndValue(end)
            self._sidebar_target = end
            self._sidebar_anim.start()

            # Track state
            self._sidebar_expanded = (end == expanded)
        except Exception as e:
            print(f"Sidebar toggle error: {e}")
    
    def setup_standard_tab_widget(self, tab_widget, style_sheet=None, tab_button_style=None):
        """Helper function to setup tab widgets with consistent configuration"""
        try:
            if not tab_widget:
                return
                
            # Standard tab widget configuration
            tab_widget.setTabPosition(QtWidgets.QTabWidget.North)
            tab_widget.setTabShape(QtWidgets.QTabWidget.Rounded)
            tab_widget.setElideMode(Qt.ElideRight)
            tab_widget.setTabsClosable(False)
            tab_widget.setMovable(True)
            tab_widget.setTabBarAutoHide(False)  # Keep tabs always visible for consistency
            
            # Combine both style_sheet and tab_button_style if both are provided
            combined_style = ""
            if style_sheet:
                combined_style += style_sheet
            if tab_button_style:
                if combined_style:
                    combined_style += "\n" + tab_button_style
                else:
                    combined_style = tab_button_style
                    
            if combined_style:
                tab_widget.setStyleSheet(combined_style)
                
            # Make tabs expand to utilize available width
            try:
                tab_widget.tabBar().setExpanding(True)
            except Exception:
                pass
                
            # Force style update
            tab_widget.style().unpolish(tab_widget)
            tab_widget.style().polish(tab_widget)
            tab_widget.update()
                
        except Exception as e:
            print(f"Tab widget setup error: {e}")
    
    def setup_standard_tab_background(self, tab_widget):
        """Apply consistent background styling to all tab pages in a tab widget"""
        try:
            if not tab_widget:
                return
                
            for i in range(tab_widget.count()):
                tab_page = tab_widget.widget(i)
                if tab_page and not tab_page.styleSheet():
                    # Only apply if no custom styling is already set
                    tab_page.setStyleSheet(CrowEyeStyles.TAB_BACKGROUND)
                    
        except Exception as e:
            print(f"Tab background setup error: {e}")
    
    def apply_custom_tab_style(self, tab_widget, style_name=None):
        """Apply unified tab style to a tab widget"""
        try:
            if not tab_widget:
                return
                
            # Apply the unified style to all tabs
            tab_widget.setStyleSheet(CrowEyeStyles.UNIFIED_TAB_STYLE)
                
        except Exception as e:
            print(f"Custom tab style application error: {e}")
    
    def setup_standard_table(self, table, column_count, auto_fill=True, default_section_size=300, min_section_size=None):
        """Helper function to setup tables with consistent configuration"""
        try:
            if not table:
                return
                
            # Disable updates during setup
            was_updates_enabled = table.updatesEnabled()
            table.setUpdatesEnabled(False)
            
            # Store current scroll positions
            h_scroll = table.horizontalScrollBar().value()
            v_scroll = table.verticalScrollBar().value()
            
            # Initialize viewport variable
            viewport = None
            
            # Clear existing items and reset
            table.clear()
            table.setRowCount(0)
            table.setColumnCount(0)
            
            # Set column count
            table.setColumnCount(column_count)
            
            # Enable sorting
            table.setSortingEnabled(True)
            
            # Enable alternating row colors
            table.setAlternatingRowColors(True)
            
            # Set selection behavior
            table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
            table.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
            
            # Configure headers
            header = table.horizontalHeader()
            if header:
                header.setStretchLastSection(True)
                header.setDefaultAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
                header.setSectionsClickable(True)
                header.setSortIndicatorShown(True)
                header.setHighlightSections(True)
                header.setAttribute(QtCore.Qt.WA_StyledBackground, True)
                
                # Apply style to header
                header_style = """
                    QHeaderView::section {
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                                stop:0 #1E293B, stop:1 #111827);
                        color: #E5E7EB;
                        padding: 12px 8px;
                        border: none;
                        border-right: 1px solid #334155;
                        border-bottom: 2px solid #334155;
                        font-weight: bold;
                        font-size: 13px;
                        text-transform: uppercase;
                        letter-spacing: 1px;
                    }
                    QHeaderView::section:hover {
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                                stop:0 #334155, stop:1 #1E293B);
                        color: #00FFFF;
                    }
                    QHeaderView::section:checked {
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                                stop:0 #0EA5E9, stop:1 #007ACC);
                        color: #FFFFFF;
                        border-bottom: 2px solid #00FFFF;
                    }
                """
    
                header.style().unpolish(header)
                header.style().polish(header)
                header.update()
            
            # Configure vertical header
            vheader = table.verticalHeader()
            if vheader:
                vheader.setVisible(True)
                vheader.setDefaultSectionSize(30)
                vheader.setMinimumSectionSize(24)
            
            # Apply table style
            table.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
            
            # Force style updates
            table.setAttribute(QtCore.Qt.WA_StyledBackground, True)
            table.style().unpolish(table)
            table.style().polish(table)
            
            # Apply auto-fill if needed
            if auto_fill:
                table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
            else:
                table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Interactive)
                if default_section_size:
                    table.horizontalHeader().setDefaultSectionSize(default_section_size)
                if min_section_size:
                    table.horizontalHeader().setMinimumSectionSize(min_section_size)
                    
                # Ensure table has reasonable minimum size
                table.setMinimumHeight(200)
                table.setMinimumWidth(400)
            
            # Ensure proper rendering
            table.update()
            if viewport:
                viewport.update()
            
            # Restore scroll positions after a short delay
            def restore_scroll():
                try:
                    if not table:
                        return
                        
                    # Update geometry first
                    table.updateGeometry()
                    
                    # Restore scroll positions if they're within valid range
                    if h_scroll < table.horizontalScrollBar().maximum():
                        table.horizontalScrollBar().setValue(h_scroll)
                    if v_scroll < table.verticalScrollBar().maximum():
                        table.verticalScrollBar().setValue(v_scroll)
                    
                    # Final style refresh
                    table.style().unpolish(table)
                    table.style().polish(table)
                    
                    # Update viewport
                    viewport = table.viewport()
                    if viewport:
                        viewport.update()
                    
                    # Force a complete repaint
                    table.update()
                except Exception as e:
                    print(f"Error in restore_scroll: {str(e)}")
                finally:
                    table.setUpdatesEnabled(was_updates_enabled)
            
            QtCore.QTimer.singleShot(50, restore_scroll)
            
        except Exception as e:
            print(f"Error setting up table: {str(e)}")
            if 'was_updates_enabled' in locals():
                table.setUpdatesEnabled(was_updates_enabled)
            return table
    
    def create_crow_eye_title_label(self, style_sheet=None):
        """Helper function to create standardized 'CROW EYE SYSTEM' title labels - reduces code duplication"""
        title_label = QtWidgets.QLabel("CROW EYE SYSTEM")
        if style_sheet:
            title_label.setStyleSheet(style_sheet)
        else:
            title_label.setStyleSheet(CrowEyeStyles.LOADING_TITLE)
        title_label.setAlignment(Qt.AlignCenter)
        return title_label
    
    def create_progress_bar(self, indeterminate=True, height=25):
        """Helper function to create standardized progress bars - reduces code duplication"""
        progress_bar = QtWidgets.QProgressBar()
        if indeterminate:
            progress_bar.setRange(0, 0)  # Indeterminate progress
        else:
            progress_bar.setRange(0, 100)
            progress_bar.setValue(0)
        progress_bar.setMinimumHeight(height)
        progress_bar.setMaximumHeight(height)
        return progress_bar
    
    def center_dialog_on_parent(self, dialog, parent=None):
        """Helper function to center dialogs on parent window - reduces code duplication"""
        if not parent:
            parent = self.main_window
        if parent:
            dialog.move(
                parent.frameGeometry().center() - dialog.frameGeometry().center()
            )
    
    def show_error_message(self, title, message, error_type="critical"):
        """Helper function to show standardized error messages - reduces code duplication"""
        if error_type == "critical":
            QtWidgets.QMessageBox.critical(self.main_window, title, message)
        elif error_type == "warning":
            QtWidgets.QMessageBox.warning(self.main_window, title, message)
        elif error_type == "information":
            QtWidgets.QMessageBox.information(self.main_window, title, message)
    
    def show_input_dialog(self, title, prompt, default_text=""):
        """Helper function to show standardized input dialogs - reduces code duplication"""
        return QtWidgets.QInputDialog.getText(
            self.main_window,
            title,
            prompt,
            QtWidgets.QLineEdit.Normal,
            default_text
        )
    
    def show_directory_dialog(self, title, default_dir=""):
        """Helper function to show standardized directory selection dialogs - reduces code duplication"""
        return QtWidgets.QFileDialog.getExistingDirectory(
            self.main_window,
            title,
            default_dir,
            QtWidgets.QFileDialog.ShowDirsOnly
        )
    
    def run_analysis_with_loading(self, title, analysis_function, *, run_in_thread=False):
        """Helper to run analysis with loading screen.
        Set run_in_thread=False if analysis_function touches GUI widgets.
        """
        self.show_loading_screen_with_function(title, analysis_function, run_in_thread=run_in_thread)
        
    def load_files_activity(self):
        """Load file activity related tables from the registry DB"""
        # Call all individual loading functions for file activity artifacts
        self.load_data_from_database_search_explorer_bar()
        self.load_data_from_database_RecentDocs()
        self.load_data_from_database_TypedPathes()
        self.load_data_from_database_OpenSaveMRU()
        self.load_data_from_database_LastSaveMRU()
        self.load_data_from_database_BAM()
        self.load_data_from_database_DAM()
        self.load_data_from_database_UserAssist()
        self.load_data_from_database_Shellbags()
        self.load_data_from_database_MUICache()
        self.load_data_from_database_WordWheelQuery()
        self.load_data_from_database_lnkAJL()
        self.load_data_from_database_CJL()
        print("[File Activity] All file activity data loaded")
        
    def load_all_logs(self):
        """Load all Windows event logs into their tables"""
        db_path = self.get_log_db_path()
        self.load_data_with_error_handling(db_path, "SystemLogs", self.SystemLogs_table, "System Logs")
        self.load_data_with_error_handling(db_path, "ApplicationLogs", self.AppLogs_table, "Application Logs")
        self.load_data_with_error_handling(db_path, "SecurityLogs", self.SecurityLogs_table, "Security Logs")
        
    def load_data_from_Prefetch(self):
        """Load Prefetch database into the Prefetch table"""
        try:
            # Get proper database path based on case configuration
            if hasattr(self, 'case_paths') and self.case_paths:
                case_root = self.case_paths.get('case_root')
                artifacts_dir = self.case_paths.get('artifacts_dir')
                if artifacts_dir and os.path.exists(artifacts_dir):
                    db_path = os.path.join(artifacts_dir, 'prefetch_data.db')
                elif case_root:
                    db_path = os.path.join(case_root, 'Target_Artifacts', 'prefetch_data.db')
                else:
                    db_path = 'prefetch_data.db'
            else:
                db_path = 'prefetch_data.db'
            
            if not os.path.exists(db_path):
                print(f"[Prefetch Error] Database file not found: {db_path}")
                self.show_error_message(
                    "Prefetch Data",
                    f"Prefetch database not found at: {db_path}\nPlease collect prefetch data first.",
                    "warning"
                )
                return False
            
            success = self.load_registry_data_to_table("prefetch_data", self.Prefetch_table, db_path)
            if success:
                print(f"[Prefetch] Successfully loaded records from prefetch_data")
                
                # Format JSON columns for better display
                for row in range(self.Prefetch_table.rowCount()):
                    # Format Run Times column (index 5)
                    run_times_item = self.Prefetch_table.item(row, 5)
                    if run_times_item and run_times_item.text():
                        try:
                            run_times = json.loads(run_times_item.text())
                            formatted_times = " | ".join(run_times)
                            run_times_item.setText(formatted_times)
                        except json.JSONDecodeError:
                            pass
                    
                    # Format Volumes column (index 6)
                    volumes_item = self.Prefetch_table.item(row, 6)
                    if volumes_item and volumes_item.text():
                        try:
                            volumes = json.loads(volumes_item.text())
                            volume_details = []
                            for v in volumes:
                                vol_id = v.get('volume_id', 'Unknown')
                                device_name = v.get('device_name', '')
                                creation_time = v.get('creation_time', '')
                                serial_num = v.get('serial_number', '')
                                
                                # Format creation time if available
                                creation_str = ''
                                if creation_time and creation_time.lower() != 'none':
                                    try:
                                        # Try to parse and format the datetime
                                        creation_dt = datetime.datetime.fromisoformat(creation_time)
                                        creation_str = f", Created: {creation_dt.strftime('%Y-%m-%d')}"
                                    except:
                                        creation_str = f", Created: {creation_time}"
                                
                                # Format volume info with all available details in a more compact way
                                vol_info = f"{vol_id}"
                                if device_name:
                                    # Extract just the volume name without the full path
                                    device_short = device_name.split('\\')[-1] if '\\' in device_name else device_name
                                    vol_info += f" ({device_short})"
                                if serial_num:
                                    vol_info += f", SN:{serial_num}"
                                vol_info += creation_str
                                
                                volume_details.append(vol_info)
                            formatted_volumes = " | ".join(volume_details)
                            volumes_item.setText(formatted_volumes)
                        except json.JSONDecodeError:
                            pass
                    
                    # Format Directories column (index 7)
                    dirs_item = self.Prefetch_table.item(row, 7)
                    if dirs_item and dirs_item.text():
                        try:
                            dirs = json.loads(dirs_item.text())
                            formatted_dirs = " | ".join(dirs)
                            dirs_item.setText(formatted_dirs)
                        except json.JSONDecodeError:
                            pass
                    
                    # Format Resources column (index 8)
                    resources_item = self.Prefetch_table.item(row, 8)
                    if resources_item and resources_item.text():
                        try:
                            resources = json.loads(resources_item.text())
                            formatted_resources = " | ".join(resources)
                            resources_item.setText(formatted_resources)
                        except json.JSONDecodeError:
                            pass
            else:
                self.show_error_message(
                    "Prefetch Data",
                    "Failed to load prefetch data from database.",
                    "warning"
                )
            return success
            
        except Exception as e:
            print(f"[Prefetch Error] Error loading prefetch data: {str(e)}")
            self.show_error_message(
                "Prefetch Data",
                f"Unexpected error loading prefetch data: {str(e)}",
                "critical"
            )
            return False
        
    def load_registry_data_from_db(self):
        """Load all registry data from the registry DB into GUI tables"""
        try:
            print("[Registry] Starting to load all registry data...")
            db_path = self.get_registry_db_path() if hasattr(self, 'get_registry_db_path') else 'registry_data_live.db'
            if not os.path.exists(db_path):
                print(f"[Registry Error] Database file not found: {db_path}")
                self.show_error_message(
                    "Registry Data",
                    f"Registry database not found at: {db_path}\nPlease collect registry data first.",
                    "warning"
                )
                return False
            table_mapping = {
                "computer_Name": self.computerName_table,
                "time_zone": self.TimeZone_table,
                "TimeZoneInfo": self.TimeZone_table,
                "network_interfaces": self.NetworkInterface_table,
                "NetworkInterfacesInfo": self.NetworkInterface_table,
                "Network_list": self.NetworkLists_table,
                "SystemServices": self.SystemServices_table,
                "machine_run": self.MachineRun_table,
                "machine_run_once": self.MachineRunOnce_tabel,
                "user_run": self.UserRun_table,
                "user_run_once": self.UserRunOnce_table,
                "RunMRU": self.RunMRU_table,
                "Windows_lastupdate": self.LastUpdate_table,
                "WindowsUpdateInfo": self.LastUpdateInfo_table,
                "ShutdownInfo": self.ShutDown_table,
                "BrowserHistory": self.Browser_history_table,
                "USBDevices": self.USBDevices_table,
                "USBInstances": self.USBInstances_table,
                "USBProperties": self.USBProperties_table,
                "USBStorageDevices": self.USBStorageDevices_table,
                "USBStorageVolumes": self.USBStorageVolumes_table,
                "RecentDocs": self.RecentDocs_table,
                "Search_Explorer_bar": self.SearchViaExplorer_table,
                "OpenSaveMRU": self.OpenSaveMRU_table,
                "lastSaveMRU": self.LastSaveMRU_table,
                "TypedPaths": self.TypedPath_table,
                "BAM": self.Bam_table,
                "DAM": self.Dam_table,
                "InstalledSoftware": self.tableWidget,
            }
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
            available_tables = [table[0] for table in cursor.fetchall()]
            for db_table, gui_table in table_mapping.items():
                if db_table in available_tables:
                    try:
                        cursor.execute(f"SELECT * FROM {db_table}")
                        rows = cursor.fetchall()
                        if rows:
                            # Ensure headers match table structure
                            cursor.execute(f"PRAGMA table_info({db_table})")
                            columns_info = cursor.fetchall()
                            columns = [col[1] for col in columns_info]
                            
                            # Reorder columns to move UID and GUID to the end
                            uid_cols = [col for col in columns if col.lower() in ['uid', 'guid', 'id', 'uuid']]
                            other_cols = [col for col in columns if col.lower() not in ['uid', 'guid', 'id', 'uuid']]
                            reordered_columns = other_cols + uid_cols
                            
                            # Create a mapping from old column index to new column index
                            col_mapping = [columns.index(col) for col in reordered_columns]
                            
                            if gui_table.columnCount() != len(reordered_columns):
                                gui_table.setColumnCount(len(reordered_columns))
                                gui_table.setHorizontalHeaderLabels(reordered_columns)
                            
                            gui_table.setRowCount(len(rows))
                            for r_idx, row in enumerate(rows):
                                # Reorder the row data according to the new column order
                                reordered_row = [row[i] for i in col_mapping]
                                for c_idx, value in enumerate(reordered_row):
                                    item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                                    item.setFlags(item.flags() & ~Qt.ItemIsEditable)
                                    gui_table.setItem(r_idx, c_idx, item)
                            
                            gui_table.resizeColumnsToContents()
                    except Exception as e:
                        print(f"[Registry Error] Failed to load {db_table}: {str(e)}")
            conn.close()
            return True
        except Exception as e:
            print(f"[Registry Error] Couldn't load registry data: {str(e)}")
            return False
        
    def setupUi(self, Crow_Eye):
        # Import styles at the beginning of setupUi
        from styles import CrowEyeStyles
        
        self.main_window = Crow_Eye
        # Store search results
        self.search_results = []  # Will store tuples of (table, row, column)
        self.current_result_index = -1  # Current position in search results
        self.highlight_queue = collections.deque()
        self.highlight_timer = QtCore.QTimer()
        self.highlight_timer.setInterval(50)  # Process queue every 50ms
        self.highlight_timer.timeout.connect(self.process_highlight_queue)
        self.highlight_timer.start()
        self.is_processing_highlight = False
        # Initialize loading overlay
        self.loading_overlay = QtWidgets.QWidget(self.main_window)
        self.loading_overlay.hide()  # Hide by default
        self.loading_overlay.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)
        self.loading_overlay.setAttribute(Qt.WA_TranslucentBackground)
        self.loading_overlay.setStyleSheet("background-color: rgba(0, 0, 0, 180);")
        Crow_Eye.setObjectName("Crow_Eye")
        Crow_Eye.setSizeIncrement(QtCore.QSize(15, 0))
        # Apply main window style
        Crow_Eye.setStyleSheet(CrowEyeStyles.MAIN_WINDOW)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(":/Icons/CrowEye.ico"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        Crow_Eye.setWindowIcon(icon)
        self.centralwidget = QtWidgets.QWidget(Crow_Eye)
        self.centralwidget.setObjectName("centralwidget")
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.centralwidget.sizePolicy().hasHeightForWidth())
        self.centralwidget.setSizePolicy(sizePolicy)
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setSpacing(0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.top_frame = QtWidgets.QFrame(self.centralwidget)
        self.top_frame.setStyleSheet(CrowEyeStyles.TOP_FRAME)
        self.top_frame.setFrameShape(QtWidgets.QFrame.NoFrame)
        self.top_frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.top_frame.setObjectName("top_frame")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.top_frame)
        self.horizontalLayout_3.setContentsMargins(8, 4, 8, 4)
        self.horizontalLayout_3.setSpacing(6)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        
        # Left section: Menu button and case buttons
        self.left_section = QtWidgets.QHBoxLayout()
        self.left_section.setSpacing(6)
        self.left_section.setObjectName("left_section")
        
        # Menu button
        self.main_menu = QtWidgets.QPushButton(self.top_frame)
        self.main_menu.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.main_menu.sizePolicy().hasHeightForWidth())
        self.main_menu.setSizePolicy(sizePolicy)
        self.main_menu.setMinimumSize(QtCore.QSize(42, 42))
        self.main_menu.setMaximumSize(QtCore.QSize(42, 42))
        self.main_menu.setFont(self.create_rockwell_font(8, False))
        self.main_menu.setToolTip("Toggle Sidebar")
        self.main_menu.setAutoFillBackground(False)
        self.main_menu.setStyleSheet(CrowEyeStyles.MAIN_MENU_BUTTON)
        self.main_menu.setText("")
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(":/Icons/icons/menu-icon.svg"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.main_menu.setIcon(icon1)
        self.main_menu.setIconSize(QtCore.QSize(42, 42))
        self.main_menu.setCheckable(True)
        self.main_menu.setChecked(True)
        self.main_menu.setFlat(False)
        self.main_menu.setObjectName("main_menu")
        self.left_section.addWidget(self.main_menu)
        
        # Small spacing after menu button
        self.left_section.addSpacing(10)
        
        # Create Case button
        self.Creat_case = QtWidgets.QPushButton(self.top_frame)
        self.Creat_case.setStyleSheet(CrowEyeStyles.CASE_BUTTON)
        self.Creat_case.setObjectName("Creat_case")
        self.Creat_case.setMaximumHeight(32)
        icon_new_case = QtGui.QIcon()
        icon_new_case.addPixmap(QtGui.QPixmap(":/Icons/icons/new-case-icon.svg"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.Creat_case.setIcon(icon_new_case)
        self.Creat_case.setIconSize(QtCore.QSize(20, 20))
        self.left_section.addWidget(self.Creat_case)
        
        # Open Case button
        self.open_case_btn = QtWidgets.QPushButton(self.top_frame)
        self.open_case_btn.setStyleSheet(CrowEyeStyles.CASE_BUTTON)
        self.open_case_btn.setObjectName("pushButton_2")
        self.open_case_btn.setMaximumHeight(32)
        icon_open_case = QtGui.QIcon()
        icon_open_case.addPixmap(QtGui.QPixmap(":/Icons/icons/open-case-icon.svg"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.open_case_btn.setIcon(icon_open_case)
        self.open_case_btn.setIconSize(QtCore.QSize(20, 20))
        self.left_section.addWidget(self.open_case_btn)
        
        # Add left section to main layout
        self.horizontalLayout_3.addLayout(self.left_section)
        
        # Center section: Case name label
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem)
        
        self.label = QtWidgets.QLabel(self.top_frame)
        self.label.setEnabled(True)
        self.label.setFont(self.create_rockwell_font(10, False))
        self.label.setAutoFillBackground(False)
        self.label.setStyleSheet(CrowEyeStyles.MAIN_LABEL)
        self.label.setAlignment(QtCore.Qt.AlignCenter)
        self.label.setObjectName("label")
        self.label.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        self.label.setMaximumWidth(500)
        self.horizontalLayout_3.addWidget(self.label)
        
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem1)
        
        # Animate sidebar on main menu toggle
        self.main_menu.toggled.connect(self.toggle_sidebar)
        
        # Add search bar to the top frame
        self.search_frame = QtWidgets.QFrame(self.top_frame)
        self.search_frame.setStyleSheet(CrowEyeStyles.SEARCH_FRAME)
        self.search_frame.setFrameShape(QtWidgets.QFrame.NoFrame)
        self.search_frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.search_frame.setObjectName("search_frame")
        self.horizontalLayout_search = QtWidgets.QHBoxLayout(self.search_frame)
        self.horizontalLayout_search.setContentsMargins(4, 0, 4, 0)
        self.horizontalLayout_search.setSpacing(4)
        self.horizontalLayout_search.setObjectName("horizontalLayout_search")
        
        # Search button - opens database search dialog
        self.search_button = QtWidgets.QPushButton(self.search_frame)
        self.search_button.setStyleSheet(CrowEyeStyles.SEARCH_BUTTON_MAIN)
        self.search_button.setText("Database Search")
        self.search_button.setObjectName("search_button")
        self.search_button.setToolTip("Open database search dialog (Ctrl+Shift+F)")
        icon_search = QtGui.QIcon()
        icon_search.addPixmap(QtGui.QPixmap(":/Icons/icons/search-icon.svg"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.search_button.setIcon(icon_search)
        self.search_button.setIconSize(QtCore.QSize(16, 16))
        self.search_button.clicked.connect(self._show_database_search)
        self.horizontalLayout_search.addWidget(self.search_button)
        
        self.timeline_search_button = QtWidgets.QPushButton(self.search_frame)
        self.timeline_search_button.setStyleSheet(CrowEyeStyles.VISUALIZATION_BUTTON)
        self.timeline_search_button.setText("Timeline Visualization")
        # Add visualization icon
        icon_viz = QtGui.QIcon()
        icon_viz.addPixmap(QtGui.QPixmap("GUI Resources/icons/visualization.svg"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.timeline_search_button.setIcon(icon_viz)
        self.timeline_search_button.setIconSize(QtCore.QSize(16, 16))
        self.timeline_search_button.setObjectName("timeline_search_button")
        self.timeline_search_button.setToolTip("Open timeline visualization")
        self.timeline_search_button.clicked.connect(self.open_timeline_dialog)
        self.horizontalLayout_search.addWidget(self.timeline_search_button)
        
        # Add the search frame to the top frame layout
        self.horizontalLayout_3.addWidget(self.search_frame)
        
        self.verticalLayout_2.addWidget(self.top_frame)
        self.Main_frame = QtWidgets.QFrame(self.centralwidget)
        self.Main_frame.setAutoFillBackground(False)
        self.Main_frame.setStyleSheet(CrowEyeStyles.MAIN_FRAME)
        self.Main_frame.setFrameShape(QtWidgets.QFrame.NoFrame)
        self.Main_frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.Main_frame.setObjectName("Main_frame")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.Main_frame)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        # Remove gaps so sidebar can reduce to exact 0 width
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setSpacing(0)
        self.side_fram = QtWidgets.QFrame(self.Main_frame)
        self.side_fram.setStyleSheet(CrowEyeStyles.SIDEBAR_FRAME)
        self.side_fram.setFrameShape(QtWidgets.QFrame.NoFrame)
        self.side_fram.setFrameShadow(QtWidgets.QFrame.Raised)
        self.side_fram.setObjectName("side_fram")
        # Fixed horizontal policy allows full collapse to 0
        try:
            sp = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Expanding)
            self.side_fram.setSizePolicy(sp)
            # Remove inner margins so it can collapse flush to 0
            self.side_fram.setContentsMargins(0, 0, 0, 0)
        except Exception:
            pass
        # Set initial sidebar size and state based on sizeHint
        try:
            self._sidebar_full_width = max(240, self.side_fram.sizeHint().width())
            self.side_fram.setMinimumWidth(self._sidebar_full_width)
            self.side_fram.setMaximumWidth(self._sidebar_full_width)
            self._sidebar_expanded = True
        except Exception:
            pass
        # Keep menu button state in sync with sidebar initial state
        try:
            self.main_menu.setChecked(True)
        except Exception:
            pass
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.side_fram)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        # Add proper spacing between sidebar elements for better visual separation
        try:
            self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
            self.verticalLayout_3.setSpacing(8)  # Increased spacing between green buttons
        except Exception:
            pass
        self.exprot_json_CSV = QtWidgets.QPushButton(self.side_fram)
        self.exprot_json_CSV.setStyleSheet(CrowEyeStyles.EXPORT_BUTTON)
        # Add export icon
        icon_export = QtGui.QIcon()
        icon_export.addPixmap(QtGui.QPixmap("GUI Resources/icons/export.svg"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.exprot_json_CSV.setIcon(icon_export)
        self.exprot_json_CSV.setIconSize(QtCore.QSize(16, 16))
        self.exprot_json_CSV.setText("Export Data") # Ensure text is set
        self.exprot_json_CSV.setObjectName("loadData")
        self.verticalLayout_3.addWidget(self.exprot_json_CSV)
        

        
        
        
        
        
        spacerItem2 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_3.addItem(spacerItem2)
        self.Live_analysis = QtWidgets.QLabel(self.side_fram)
        self.Live_analysis.setAutoFillBackground(False)
        self.Live_analysis.setStyleSheet(CrowEyeStyles.LIVE_ANALYSIS_LABEL)
        self.Live_analysis.setObjectName("Live_analysis")
        self.verticalLayout_3.addWidget(self.Live_analysis)
        # Small spacer after section label
        spacerItem_live = QtWidgets.QSpacerItem(20, 8, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        self.verticalLayout_3.addItem(spacerItem_live)
        self.parse_all = QtWidgets.QPushButton(self.side_fram)
        self.parse_all.setStyleSheet(CrowEyeStyles.PARSE_ALL_BUTTON)
        self.parse_all.setObjectName("parse_all")
        self.verticalLayout_3.addWidget(self.parse_all)
        self.registrybutton = QtWidgets.QPushButton(self.side_fram)
        self.registrybutton.setAutoFillBackground(False)
        self.setup_parse_button(self.registrybutton, True, True, True)
        self.registrybutton.setObjectName("registrybutton")
        self.verticalLayout_3.addWidget(self.registrybutton)
        self.lnkbutton = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.lnkbutton, True, True, False)
        self.lnkbutton.setObjectName("lnkbutton")
        self.verticalLayout_3.addWidget(self.lnkbutton)


        self.Prefetchbutton = QtWidgets.QPushButton(self.side_fram)
        # ... existing code ...
        self.setup_parse_button(self.Prefetchbutton, True, True, True)
        self.Prefetchbutton.setObjectName("Prefetchbutton")
        self.verticalLayout_3.addWidget(self.Prefetchbutton)
        
        self.ShimCacheButton = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.ShimCacheButton, True, True, True)
        self.ShimCacheButton.setObjectName("ShimCacheButton")
        self.verticalLayout_3.addWidget(self.ShimCacheButton)
        
        self.AmcacheButton = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.AmcacheButton, True, True, True)
        self.AmcacheButton.setObjectName("AmcacheButton")
        self.verticalLayout_3.addWidget(self.AmcacheButton)
        
        self.MFT_USN_CorrelateButton = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.MFT_USN_CorrelateButton, True, True, True)
        self.MFT_USN_CorrelateButton.setObjectName("MFT_USN_CorrelateButton")
        self.verticalLayout_3.addWidget(self.MFT_USN_CorrelateButton)
        
        self.logbutton = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.logbutton, True, True, False)
        self.logbutton.setObjectName("logbutton")
        self.verticalLayout_3.addWidget(self.logbutton)
        
        self.RecycleBinButton = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.RecycleBinButton, True, True, True)
        self.RecycleBinButton.setObjectName("RecycleBinButton")
        self.verticalLayout_3.addWidget(self.RecycleBinButton)
        
        self.SRUMButton = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.SRUMButton, True, True, True)
        self.SRUMButton.setObjectName("SRUMButton")
        self.verticalLayout_3.addWidget(self.SRUMButton)
        
        spacerItem3 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_3.addItem(spacerItem3)
        self.Offline_analysis = QtWidgets.QLabel(self.side_fram)
        self.Offline_analysis.setStyleSheet(CrowEyeStyles.LIVE_ANALYSIS_LABEL)
        self.Offline_analysis.setObjectName("Offline_analysis")
        self.verticalLayout_3.addWidget(self.Offline_analysis)
        # Small spacer after section label
        spacerItem_offline = QtWidgets.QSpacerItem(20, 8, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        self.verticalLayout_3.addItem(spacerItem_offline)
        self.registry_offline = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.registry_offline, True, True, False)
        self.registry_offline.setObjectName("registry_offline")
        self.verticalLayout_3.addWidget(self.registry_offline)
        self.offline_LNK_JL = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.offline_LNK_JL, True, True, False)
        self.offline_LNK_JL.setObjectName("offline_LNK_JL")
        self.verticalLayout_3.addWidget(self.offline_LNK_JL)
        self.offline_prefetch = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.offline_prefetch, True, True, False)
        self.offline_prefetch.setObjectName("offline_prefetch")
        self.verticalLayout_3.addWidget(self.offline_prefetch)
        spacerItem4 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_3.addItem(spacerItem4)
        self.horizontalLayout_2.addWidget(self.side_fram)
        self.info_frame = QtWidgets.QFrame(self.Main_frame)
        self.info_frame.setFont(self.create_standard_font("MS Shell Dlg 2", 10, True, False))
        self.info_frame.setStyleSheet(CrowEyeStyles.TAB_BACKGROUND)
        self.info_frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.info_frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.info_frame.setObjectName("info_frame")
        # Ensure main content expands to take available space
        try:
            sp2 = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
            self.info_frame.setSizePolicy(sp2)
        except Exception:
            pass
        self.verticalLayout = QtWidgets.QVBoxLayout(self.info_frame)
        self.verticalLayout.setObjectName("verticalLayout")
        self.main_tab = QtWidgets.QTabWidget(self.info_frame)
        self.main_tab.setMinimumSize(QtCore.QSize(874, 750))
        self.main_tab.setBaseSize(QtCore.QSize(3000, 0))
        self.main_tab.setAutoFillBackground(False)
        self.main_tab.setIconSize(QtCore.QSize(30, 16))
        # Apply styles to tab widgets
        CrowEyeStyles.apply_tab_styles(self.main_tab)

        # Set object names for specific styling
        self.main_tab.setObjectName("main_tab")
        # Apply standard tab configuration with unified style
        self.setup_standard_tab_widget(self.main_tab, style_sheet=CrowEyeStyles.UNIFIED_TAB_STYLE)
        self.apply_custom_tab_style(self.main_tab)
        self.Registry_Tab = QtWidgets.QWidget()
        self.Registry_Tab.setObjectName("Registry_Tab")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.Registry_Tab)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.Registry_widget = QtWidgets.QTabWidget(self.Registry_Tab)
        self.Registry_widget.setObjectName("Registry_widget")
        CrowEyeStyles.apply_tab_styles(self.Registry_widget)
        # Apply standard tab configuration with unified sub-tab styling
        self.setup_standard_tab_widget(self.Registry_widget, style_sheet=CrowEyeStyles.UNIFIED_TAB_STYLE)
        self.apply_custom_tab_style(self.Registry_widget)
        self.computer_Name = QtWidgets.QWidget()
        self.computer_Name.setAutoFillBackground(False)
        self.computer_Name.setObjectName("computer_Name")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.computer_Name)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.computerName_table = QtWidgets.QTableWidget(self.computer_Name)
        self.setup_standard_table(self.computerName_table, 3, False, 300, 190)
        self.computerName_table.setObjectName("computerName_table")
        self.verticalLayout_6.addWidget(self.computerName_table)
        self.Registry_widget.addTab(self.computer_Name, "")
        self.Time_Zone = QtWidgets.QWidget()
        self.Time_Zone.setObjectName("Time_Zone")
        self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.Time_Zone)
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.TimeZone_table = QtWidgets.QTableWidget(self.Time_Zone)
        self.setup_standard_table(self.TimeZone_table, 3, False, 300, 190)
        self.TimeZone_table.setObjectName("TimeZone_table")
        self.verticalLayout_7.addWidget(self.TimeZone_table)
        self.Registry_widget.addTab(self.Time_Zone, "")
        self.NetworkInterfaces_tab = QtWidgets.QWidget()
        self.NetworkInterfaces_tab.setObjectName("NetworkInterfaces_tab")
        self.verticalLayout_8 = QtWidgets.QVBoxLayout(self.NetworkInterfaces_tab)
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.NetworkInterface_table = QtWidgets.QTableWidget(self.NetworkInterfaces_tab)
        self.setup_standard_table(self.NetworkInterface_table, 4, False, 300, 190)
        self.NetworkInterface_table.setObjectName("NetworkInterface_table")
        self.verticalLayout_8.addWidget(self.NetworkInterface_table)
        self.Registry_widget.addTab(self.NetworkInterfaces_tab, "")
        self.Networklists = QtWidgets.QWidget()
        self.Networklists.setObjectName("Networklists")
        self.verticalLayout_9 = QtWidgets.QVBoxLayout(self.Networklists)
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.NetworkLists_table = QtWidgets.QTableWidget(self.Networklists)
        self.setup_standard_table(self.NetworkLists_table, 4, False, 300, 190)
        self.NetworkLists_table.setObjectName("NetworkLists_table")
        self.verticalLayout_9.addWidget(self.NetworkLists_table)
        self.Registry_widget.addTab(self.Networklists, "")
        self.SystemServices = QtWidgets.QWidget()
        self.SystemServices.setObjectName("SystemServices")
        self.verticalLayout_33 = QtWidgets.QVBoxLayout(self.SystemServices)
        self.verticalLayout_33.setObjectName("verticalLayout_33")
        self.SystemServices_table = QtWidgets.QTableWidget(self.SystemServices)
        self.setup_standard_table(self.SystemServices_table, 9, False, 300, 190)
        self.SystemServices_table.setObjectName("SystemServices_table")
        self.verticalLayout_33.addWidget(self.SystemServices_table)
        self.Registry_widget.addTab(self.SystemServices, "")
        self.MachineRun = QtWidgets.QWidget()
        self.MachineRun.setObjectName("MachineRun")
        self.verticalLayout_11 = QtWidgets.QVBoxLayout(self.MachineRun)
        self.verticalLayout_11.setObjectName("verticalLayout_11")
        self.MachineRun_table = QtWidgets.QTableWidget(self.MachineRun)
        self.setup_standard_table(self.MachineRun_table, 3, False, 300, 190)
        self.MachineRun_table.setObjectName("MachineRun_table")
        self.verticalLayout_11.addWidget(self.MachineRun_table)
        self.Registry_widget.addTab(self.MachineRun, "")
        self.Machine_run_once = QtWidgets.QWidget()
        self.Machine_run_once.setObjectName("Machine_run_once")
        self.verticalLayout_12 = QtWidgets.QVBoxLayout(self.Machine_run_once)
        self.verticalLayout_12.setObjectName("verticalLayout_12")
        self.MachineRunOnce_tabel = QtWidgets.QTableWidget(self.Machine_run_once)
        self.setup_standard_table(self.MachineRunOnce_tabel, 3, False, 300, 190)
        self.MachineRunOnce_tabel.setObjectName("MachineRunOnce_tabel")
        self.verticalLayout_12.addWidget(self.MachineRunOnce_tabel)
        self.Registry_widget.addTab(self.Machine_run_once, "")



        self.User_run = QtWidgets.QWidget()
        self.User_run.setObjectName("User_run")
        self.verticalLayout_13 = QtWidgets.QVBoxLayout(self.User_run)
        self.verticalLayout_13.setObjectName("verticalLayout_13")
        self.UserRun_table = QtWidgets.QTableWidget(self.User_run)
        self.UserRun_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.UserRun_table, 3, False, 300, 190)
        self.UserRun_table.setObjectName("UserRun_table")
        self.verticalLayout_13.addWidget(self.UserRun_table)
        self.Registry_widget.addTab(self.User_run, "")
        
        # ShimCache tab was moved to main tab
        
        self.User_run_once = QtWidgets.QWidget()
        self.User_run_once.setObjectName("User_run_once")
        self.verticalLayout_14 = QtWidgets.QVBoxLayout(self.User_run_once)
        self.verticalLayout_14.setObjectName("verticalLayout_14")
        self.UserRunOnce_table = QtWidgets.QTableWidget(self.User_run_once)
        self.UserRunOnce_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.UserRunOnce_table, 3, False, 300, 190)
        self.UserRunOnce_table.setObjectName("UserRunOnce_table")
        self.verticalLayout_14.addWidget(self.UserRunOnce_table)
        self.Registry_widget.addTab(self.User_run_once, "")
        self.Last_update = QtWidgets.QWidget()
        self.Last_update.setObjectName("Last_update")
        self.verticalLayout_15 = QtWidgets.QVBoxLayout(self.Last_update)
        self.verticalLayout_15.setObjectName("verticalLayout_15")
        self.LastUpdate_table = QtWidgets.QTableWidget(self.Last_update)
        self.setup_standard_table(self.LastUpdate_table, 3, False, 300, 190)
        self.LastUpdate_table.setObjectName("LastUpdate_table")
        self.verticalLayout_15.addWidget(self.LastUpdate_table)
        self.Registry_widget.addTab(self.Last_update, "")
        self.Lstupdate_info = QtWidgets.QWidget()
        self.Lstupdate_info.setObjectName("Lstupdate_info")
        self.verticalLayout_16 = QtWidgets.QVBoxLayout(self.Lstupdate_info)
        self.verticalLayout_16.setObjectName("verticalLayout_16")
        self.LastUpdateInfo_table = QtWidgets.QTableWidget(self.Lstupdate_info)
        self.setup_standard_table(self.LastUpdateInfo_table, 4, False, 300, 190)
        self.LastUpdateInfo_table.setObjectName("LastUpdateInfo_table")
        self.verticalLayout_16.addWidget(self.LastUpdateInfo_table)
        self.Registry_widget.addTab(self.Lstupdate_info, "")
        self.ShutDown_tab = QtWidgets.QWidget()
        self.ShutDown_tab.setObjectName("ShutDown_tab")
        self.verticalLayout_18 = QtWidgets.QVBoxLayout(self.ShutDown_tab)
        self.verticalLayout_18.setObjectName("verticalLayout_18")
        self.ShutDown_table = QtWidgets.QTableWidget(self.ShutDown_tab)
        self.setup_standard_table(self.ShutDown_table, 3, False, 300, 190)
        self.ShutDown_table.setObjectName("ShutDown_table")
        self.verticalLayout_18.addWidget(self.ShutDown_table)
        self.Registry_widget.addTab(self.ShutDown_tab, "")
        self.Browser_history = QtWidgets.QWidget()
        self.Browser_history.setObjectName("Browser_history")
        self.verticalLayout_31 = QtWidgets.QVBoxLayout(self.Browser_history)
        self.verticalLayout_31.setObjectName("verticalLayout_31")
        self.Browser_history_table = QtWidgets.QTableWidget(self.Browser_history)
        self.Browser_history_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.Browser_history_table, 6, False, 300, 190)
        self.Browser_history_table.setObjectName("Browser_history_table")
        self.verticalLayout_31.addWidget(self.Browser_history_table)
        self.Registry_widget.addTab(self.Browser_history, "")
        
        # ShimCache tab was moved to main tab
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout(self.tab)
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.USBDevices_table = QtWidgets.QTableWidget(self.tab)
        self.USBDevices_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.USBDevices_table, 5, False, 300, 190)
        self.USBDevices_table.setObjectName("USBDevices_table")
        self.horizontalLayout_4.addWidget(self.USBDevices_table)
        self.Registry_widget.addTab(self.tab, "")
        self.USBInstance_tab = QtWidgets.QWidget()
        self.USBInstance_tab.setObjectName("USBInstance_tab")
        self.verticalLayout_34 = QtWidgets.QVBoxLayout(self.USBInstance_tab)
        self.verticalLayout_34.setObjectName("verticalLayout_34")
        self.USBInstances_table = QtWidgets.QTableWidget(self.USBInstance_tab)
        self.USBInstances_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.USBInstances_table, 5, False, 300, 190)
        self.USBInstances_table.setObjectName("USBInstances_table")
        self.verticalLayout_34.addWidget(self.USBInstances_table)
        self.Registry_widget.addTab(self.USBInstance_tab, "")
        self.USBProperties_tab = QtWidgets.QWidget()
        self.USBProperties_tab.setObjectName("USBProperties_tab")
        self.verticalLayout_35 = QtWidgets.QVBoxLayout(self.USBProperties_tab)
        self.verticalLayout_35.setObjectName("verticalLayout_35")
        self.USBProperties_table = QtWidgets.QTableWidget(self.USBProperties_tab)
        self.setup_standard_table(self.USBProperties_table, 4, False, 300, 190)
        self.USBProperties_table.setObjectName("USBProperties_table")
        self.verticalLayout_35.addWidget(self.USBProperties_table)
        self.Registry_widget.addTab(self.USBProperties_tab, "")
        self.USBStorageDevices_tab = QtWidgets.QWidget()
        self.USBStorageDevices_tab.setObjectName("USBStorageDevices_tab")
        self.verticalLayout_36 = QtWidgets.QVBoxLayout(self.USBStorageDevices_tab)
        self.verticalLayout_36.setObjectName("verticalLayout_36")
        self.USBStorageDevices_table = QtWidgets.QTableWidget(self.USBStorageDevices_tab)
        self.setup_standard_table(self.USBStorageDevices_table, 10, False, 300, 190)
        self.USBStorageDevices_table.setObjectName("USBStorageDevices_table")
        self.verticalLayout_36.addWidget(self.USBStorageDevices_table)
        self.Registry_widget.addTab(self.USBStorageDevices_tab, "")
        self.USBStorageVolumes_tab = QtWidgets.QWidget()
        self.USBStorageVolumes_tab.setObjectName("USBStorageVolumes_tab")
        self.verticalLayout_37 = QtWidgets.QVBoxLayout(self.USBStorageVolumes_tab)
        self.verticalLayout_37.setObjectName("verticalLayout_37")
        self.USBStorageVolumes_table = QtWidgets.QTableWidget(self.USBStorageVolumes_tab)
        self.setup_standard_table(self.USBStorageVolumes_table, 5, False, 300, 190)
        self.USBStorageVolumes_table.setObjectName("USBStorageVolumes_table")
        self.verticalLayout_37.addWidget(self.USBStorageVolumes_table)
        self.Registry_widget.addTab(self.USBStorageVolumes_tab, "")
        
        # RunMRU tab (moved from File Activity to Registry)
        self.RunMRU_tab = QtWidgets.QWidget()
        self.RunMRU_tab.setObjectName("RunMRU_tab")
        self.verticalLayout_runmru = QtWidgets.QVBoxLayout(self.RunMRU_tab)
        self.verticalLayout_runmru.setObjectName("verticalLayout_runmru")
        self.RunMRU_table = QtWidgets.QTableWidget(self.RunMRU_tab)
        self.setup_standard_table(self.RunMRU_table, 3, False, 300, 190)
        self.RunMRU_table.setObjectName("RunMRU_table")
        self.verticalLayout_runmru.addWidget(self.RunMRU_table)
        self.Registry_widget.addTab(self.RunMRU_tab, "")
        
        self.verticalLayout_4.addWidget(self.Registry_widget)
        self.main_tab.addTab(self.Registry_Tab, "")
        self.filesActivity_tab = QtWidgets.QWidget()
        self.filesActivity_tab.setObjectName("filesActivity_tab")
        self.verticalLayout_17 = QtWidgets.QVBoxLayout(self.filesActivity_tab)
        self.verticalLayout_17.setObjectName("verticalLayout_17")
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.verticalLayout_17.addLayout(self.horizontalLayout_5)
        self.filesActivityTab_tables = QtWidgets.QTabWidget(self.filesActivity_tab)
        self.filesActivityTab_tables.setObjectName("filesActivityTab_tables")
        CrowEyeStyles.apply_tab_styles(self.filesActivityTab_tables)
        # Apply standard tab configuration with unified sub-tab styling
        self.setup_standard_tab_widget(self.filesActivityTab_tables, style_sheet=CrowEyeStyles.UNIFIED_TAB_STYLE)
        self.apply_custom_tab_style(self.filesActivityTab_tables)
        self.Recent_docs_tab = QtWidgets.QWidget()
        self.Recent_docs_tab.setObjectName("Recent_docs_tab")
        self.verticalLayout_19 = QtWidgets.QVBoxLayout(self.Recent_docs_tab)
        self.verticalLayout_19.setObjectName("verticalLayout_19")
        self.RecentDocs_table = QtWidgets.QTableWidget(self.Recent_docs_tab)
        self.RecentDocs_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.RecentDocs_table, 4, False, 300, 190)
        self.RecentDocs_table.setObjectName("RecentDocs_table")
        self.verticalLayout_19.addWidget(self.RecentDocs_table)
        self.filesActivityTab_tables.addTab(self.Recent_docs_tab, "")
        self.SearchViaExplorerbar_tab = QtWidgets.QWidget()
        self.SearchViaExplorerbar_tab.setObjectName("SearchViaExplorerbar_tab")
        self.verticalLayout_20 = QtWidgets.QVBoxLayout(self.SearchViaExplorerbar_tab)
        self.verticalLayout_20.setObjectName("verticalLayout_20")
        self.SearchViaExplorer_table = QtWidgets.QTableWidget(self.SearchViaExplorerbar_tab)
        self.SearchViaExplorer_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.SearchViaExplorer_table, 3, False, 300, 190)
        self.SearchViaExplorer_table.setObjectName("SearchViaExplorer_table")
        self.verticalLayout_20.addWidget(self.SearchViaExplorer_table)
        self.filesActivityTab_tables.addTab(self.SearchViaExplorerbar_tab, "")
        self.OpenSaveMru = QtWidgets.QWidget()
        self.OpenSaveMru.setObjectName("OpenSaveMru")
        self.verticalLayout_21 = QtWidgets.QVBoxLayout(self.OpenSaveMru)
        self.verticalLayout_21.setObjectName("verticalLayout_21")
        self.OpenSaveMRU_table = QtWidgets.QTableWidget(self.OpenSaveMru)
        self.OpenSaveMRU_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.OpenSaveMRU_table, 4, False, 300, 190)
        self.OpenSaveMRU_table.setObjectName("OpenSaveMRU_table")
        self.verticalLayout_21.addWidget(self.OpenSaveMRU_table)
        self.filesActivityTab_tables.addTab(self.OpenSaveMru, "")
        self.LastSaveMRU_tab = QtWidgets.QWidget()
        self.LastSaveMRU_tab.setObjectName("LastSaveMRU_tab")
        self.verticalLayout_22 = QtWidgets.QVBoxLayout(self.LastSaveMRU_tab)
        self.verticalLayout_22.setObjectName("verticalLayout_22")
        self.LastSaveMRU_table = QtWidgets.QTableWidget(self.LastSaveMRU_tab)
        self.LastSaveMRU_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.LastSaveMRU_table, 4, False, 300, 190)
        self.LastSaveMRU_table.setObjectName("LastSaveMRU_table")
        self.verticalLayout_22.addWidget(self.LastSaveMRU_table)
        self.filesActivityTab_tables.addTab(self.LastSaveMRU_tab, "")
        self.TypedPathes_tab = QtWidgets.QWidget()
        self.TypedPathes_tab.setObjectName("TypedPathes_tab")
        self.verticalLayout_23 = QtWidgets.QVBoxLayout(self.TypedPathes_tab)
        self.verticalLayout_23.setObjectName("verticalLayout_23")
        self.TypedPath_table = QtWidgets.QTableWidget(self.TypedPathes_tab)
        self.TypedPath_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.TypedPath_table, 3, False, 300, 190)
        self.TypedPath_table.setObjectName("TypedPath_table")
        self.verticalLayout_23.addWidget(self.TypedPath_table)
        self.filesActivityTab_tables.addTab(self.TypedPathes_tab, "")
        self.BAM_tab = QtWidgets.QWidget()
        self.BAM_tab.setObjectName("BAM_tab")
        self.verticalLayout_25 = QtWidgets.QVBoxLayout(self.BAM_tab)
        self.verticalLayout_25.setObjectName("verticalLayout_25")
        self.Bam_table = QtWidgets.QTableWidget(self.BAM_tab)
        self.setup_standard_table(self.Bam_table, 4, False, 300, 190)
        self.Bam_table.setObjectName("Bam_table")
        self.verticalLayout_25.addWidget(self.Bam_table)
        self.filesActivityTab_tables.addTab(self.BAM_tab, "")
        self.Dam_tab = QtWidgets.QWidget()
        self.Dam_tab.setObjectName("Dam_tab")
        self.verticalLayout_24 = QtWidgets.QVBoxLayout(self.Dam_tab)
        self.verticalLayout_24.setObjectName("verticalLayout_24")
        self.Dam_table = QtWidgets.QTableWidget(self.Dam_tab)
        self.setup_standard_table(self.Dam_table, 4, False, 300, 190)
        self.Dam_table.setObjectName("Dam_table")
        self.verticalLayout_24.addWidget(self.Dam_table)
        self.filesActivityTab_tables.addTab(self.Dam_tab, "")
        
        # UserAssist tab
        self.UserAssist_tab = QtWidgets.QWidget()
        self.UserAssist_tab.setObjectName("UserAssist_tab")
        self.verticalLayout_userassist = QtWidgets.QVBoxLayout(self.UserAssist_tab)
        self.verticalLayout_userassist.setObjectName("verticalLayout_userassist")
        self.UserAssist_table = QtWidgets.QTableWidget(self.UserAssist_tab)
        self.setup_standard_table(self.UserAssist_table, 6, False, 300, 190)
        self.UserAssist_table.setObjectName("UserAssist_table")
        self.verticalLayout_userassist.addWidget(self.UserAssist_table)
        self.filesActivityTab_tables.addTab(self.UserAssist_tab, "")
        
        # Shellbags tab
        self.Shellbags_tab = QtWidgets.QWidget()
        self.Shellbags_tab.setObjectName("Shellbags_tab")
        self.verticalLayout_shellbags = QtWidgets.QVBoxLayout(self.Shellbags_tab)
        self.verticalLayout_shellbags.setObjectName("verticalLayout_shellbags")
        self.Shellbags_table = QtWidgets.QTableWidget(self.Shellbags_tab)
        self.setup_standard_table(self.Shellbags_table, 6, False, 300, 190)
        self.Shellbags_table.setObjectName("Shellbags_table")
        self.verticalLayout_shellbags.addWidget(self.Shellbags_table)
        self.filesActivityTab_tables.addTab(self.Shellbags_tab, "")
        
        # MUICache tab
        self.MUICache_tab = QtWidgets.QWidget()
        self.MUICache_tab.setObjectName("MUICache_tab")
        self.verticalLayout_muicache = QtWidgets.QVBoxLayout(self.MUICache_tab)
        self.verticalLayout_muicache.setObjectName("verticalLayout_muicache")
        self.MUICache_table = QtWidgets.QTableWidget(self.MUICache_tab)
        self.setup_standard_table(self.MUICache_table, 3, False, 300, 190)
        self.MUICache_table.setObjectName("MUICache_table")
        self.verticalLayout_muicache.addWidget(self.MUICache_table)
        self.filesActivityTab_tables.addTab(self.MUICache_tab, "")
        
        # WordWheelQuery tab
        self.WordWheelQuery_tab = QtWidgets.QWidget()
        self.WordWheelQuery_tab.setObjectName("WordWheelQuery_tab")
        self.verticalLayout_wordwheelquery = QtWidgets.QVBoxLayout(self.WordWheelQuery_tab)
        self.verticalLayout_wordwheelquery.setObjectName("verticalLayout_wordwheelquery")
        self.WordWheelQuery_table = QtWidgets.QTableWidget(self.WordWheelQuery_tab)
        self.setup_standard_table(self.WordWheelQuery_table, 4, False, 300, 190)
        self.WordWheelQuery_table.setObjectName("WordWheelQuery_table")
        self.verticalLayout_wordwheelquery.addWidget(self.WordWheelQuery_table)
        self.filesActivityTab_tables.addTab(self.WordWheelQuery_tab, "")
        
        self.Installed_sowftare = QtWidgets.QWidget()
        self.Installed_sowftare.setObjectName("Installed_sowftare")
        self.verticalLayout_32 = QtWidgets.QVBoxLayout(self.Installed_sowftare)
        self.verticalLayout_32.setObjectName("verticalLayout_32")
        self.tableWidget = QtWidgets.QTableWidget(self.Installed_sowftare)
        self.setup_standard_table(self.tableWidget, 7, False, 400, 190)
        self.tableWidget.setObjectName("tableWidget")
        self.verticalLayout_32.addWidget(self.tableWidget)
        self.filesActivityTab_tables.addTab(self.Installed_sowftare, "")
        self.verticalLayout_17.addWidget(self.filesActivityTab_tables)
        self.main_tab.addTab(self.filesActivity_tab, "")
        self.Prefetch_tab = QtWidgets.QWidget()
        self.Prefetch_tab.setObjectName("Prefetch_tab")
        self.verticalLayout_26 = QtWidgets.QVBoxLayout(self.Prefetch_tab)
        self.verticalLayout_26.setObjectName("verticalLayout_26")
        self.Prefetch_table = QtWidgets.QTableWidget(self.Prefetch_tab)
        self.Prefetch_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.Prefetch_table, 31, False, 300, 190)
        self.Prefetch_table.setObjectName("Prefetch_table")
        self.verticalLayout_26.addWidget(self.Prefetch_table)
        # Use purple header for Prefetch table
        try:
            pref_hdr = self.Prefetch_table.horizontalHeader()
            pref_hdr.setObjectName("header_purple")
            pref_hdr.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
        except Exception:
            pass
        self.main_tab.addTab(self.Prefetch_tab, "")
        # Create the main LNK and Jump List tab
        self.LNK_JL_Tab = QtWidgets.QWidget()
        self.LNK_JL_Tab.setStyleSheet(CrowEyeStyles.TAB_BACKGROUND)
        self.LNK_JL_Tab.setObjectName("LNK_JL_Tab")
        self.verticalLayout_lnk_jl = QtWidgets.QVBoxLayout(self.LNK_JL_Tab)
        self.verticalLayout_lnk_jl.setObjectName("verticalLayout_lnk_jl")
        
        # Create subtab widget for LNK and Jump Lists
        self.lnk_jl_subtabs = QtWidgets.QTabWidget(self.LNK_JL_Tab)
        self.lnk_jl_subtabs.setObjectName("lnk_jl_subtabs")
        CrowEyeStyles.apply_tab_styles(self.lnk_jl_subtabs)
        self.setup_standard_tab_widget(self.lnk_jl_subtabs, style_sheet=CrowEyeStyles.UNIFIED_TAB_STYLE)
        self.apply_custom_tab_style(self.lnk_jl_subtabs)
        self.setup_standard_tab_background(self.lnk_jl_subtabs)
        
        # Create LNK subtab
        self.LNK_subtab = QtWidgets.QWidget()
        self.LNK_subtab.setObjectName("LNK_subtab")
        self.verticalLayout_lnk = QtWidgets.QVBoxLayout(self.LNK_subtab)
        self.verticalLayout_lnk.setObjectName("verticalLayout_lnk")
        self.LNK_table = QtWidgets.QTableWidget(self.LNK_subtab)
        self.LNK_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.LNK_table, 33, False, 300, 190)
        self.LNK_table.setObjectName("LNK_table")
        self.verticalLayout_lnk.addWidget(self.LNK_table)
        self.lnk_jl_subtabs.addTab(self.LNK_subtab, "")
        
        # Create Automatic Jump List subtab
        self.AJL_subtab = QtWidgets.QWidget()
        self.AJL_subtab.setObjectName("AJL_subtab")
        self.verticalLayout_ajl = QtWidgets.QVBoxLayout(self.AJL_subtab)
        self.verticalLayout_ajl.setObjectName("verticalLayout_ajl")
        self.AJL_table = QtWidgets.QTableWidget(self.AJL_subtab)
        self.AJL_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.AJL_table, 33, False, 300, 190)
        self.AJL_table.setObjectName("AJL_table")
        self.verticalLayout_ajl.addWidget(self.AJL_table)
        self.lnk_jl_subtabs.addTab(self.AJL_subtab, "")
        
        # Create Custom Jump List subtab
        self.CJL_subtab = QtWidgets.QWidget()
        self.CJL_subtab.setObjectName("CJL_subtab")
        self.verticalLayout_cjl = QtWidgets.QVBoxLayout(self.CJL_subtab)
        self.verticalLayout_cjl.setObjectName("verticalLayout_cjl")
        self.Clj_table = QtWidgets.QTableWidget(self.CJL_subtab)
        self.Clj_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.Clj_table, 33, False, 300, 190)
        self.Clj_table.setObjectName("Clj_table")
        self.verticalLayout_cjl.addWidget(self.Clj_table)
        self.lnk_jl_subtabs.addTab(self.CJL_subtab, "")
        
        # Add the subtab widget to the main tab
        self.verticalLayout_lnk_jl.addWidget(self.lnk_jl_subtabs)
        self.main_tab.addTab(self.LNK_JL_Tab, "")
        self.Logs_tab = QtWidgets.QWidget()
        self.Logs_tab.setObjectName("Logs_tab")
        self.verticalLayout_27 = QtWidgets.QVBoxLayout(self.Logs_tab)
        self.verticalLayout_27.setObjectName("verticalLayout_27")
        # Create and configure the tab widget
        self.tabWidget = QtWidgets.QTabWidget(self.Logs_tab)
        self.tabWidget.setObjectName("tabWidget")
        CrowEyeStyles.apply_tab_styles(self.tabWidget)
        
        # Apply standard configuration with unified tab style
        self.setup_standard_tab_widget(self.tabWidget, style_sheet=CrowEyeStyles.UNIFIED_TAB_STYLE)
        self.apply_custom_tab_style(self.tabWidget)
        self.setup_standard_tab_background(self.tabWidget)
        self.AppLogs_tab = QtWidgets.QWidget()
        self.AppLogs_tab.setObjectName("AppLogs_tab")
        self.verticalLayout_28 = QtWidgets.QVBoxLayout(self.AppLogs_tab)
        self.verticalLayout_28.setObjectName("verticalLayout_28")
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.verticalLayout_28.addLayout(self.horizontalLayout_7)
        self.AppLogs_table = QtWidgets.QTableWidget(self.AppLogs_tab)
        self.AppLogs_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.AppLogs_table, 9, False, 300, 190)
        self.AppLogs_table.setObjectName("AppLogs_table")
        self.verticalLayout_28.addWidget(self.AppLogs_table)
        self.tabWidget.addTab(self.AppLogs_tab, "")
        self.SecurityLogs_tab = QtWidgets.QWidget()
        self.SecurityLogs_tab.setObjectName("SecurityLogs_tab")
        self.verticalLayout_29 = QtWidgets.QVBoxLayout(self.SecurityLogs_tab)
        self.verticalLayout_29.setObjectName("verticalLayout_29")
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.verticalLayout_29.addLayout(self.horizontalLayout_8)
        self.SecurityLogs_table = QtWidgets.QTableWidget(self.SecurityLogs_tab)
        self.SecurityLogs_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.SecurityLogs_table, 10, False, 300, 190)
        self.SecurityLogs_table.setObjectName("SecurityLogs_table")
        self.verticalLayout_29.addWidget(self.SecurityLogs_table)
        self.tabWidget.addTab(self.SecurityLogs_tab, "")
        self.SystemLogs_tab = QtWidgets.QWidget()
        self.SystemLogs_tab.setObjectName("SystemLogs_tab")
        self.verticalLayout_30 = QtWidgets.QVBoxLayout(self.SystemLogs_tab)
        self.verticalLayout_30.setObjectName("verticalLayout_30")
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.verticalLayout_30.addLayout(self.horizontalLayout_9)
        self.SystemLogs_table = QtWidgets.QTableWidget(self.SystemLogs_tab)
        self.SystemLogs_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.SystemLogs_table, 9, False, 300, 190)
        self.SystemLogs_table.setObjectName("SystemLogs_table")
        self.verticalLayout_30.addWidget(self.SystemLogs_table)
        self.tabWidget.addTab(self.SystemLogs_tab, "")
        self.verticalLayout_27.addWidget(self.tabWidget)
        self.main_tab.addTab(self.Logs_tab, "")
        
        # Create ShimCache main tab
        self.ShimCache_main_tab = QtWidgets.QWidget()
        self.ShimCache_main_tab.setObjectName("ShimCache_main_tab")
        self.verticalLayout_shimcache_main = QtWidgets.QVBoxLayout(self.ShimCache_main_tab)
        self.verticalLayout_shimcache_main.setObjectName("verticalLayout_shimcache_main")
        
        # Create ShimCache table
        self.ShimCache_main_table = QtWidgets.QTableWidget(self.ShimCache_main_tab)
        self.ShimCache_main_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.ShimCache_main_table, 5, False, 300, 190)
        self.ShimCache_main_table.setObjectName("ShimCache_main_table")
        self.verticalLayout_shimcache_main.addWidget(self.ShimCache_main_table)
        
        # Add ShimCache tab to main tab widget
        self.main_tab.addTab(self.ShimCache_main_tab, "")
        
        # Create Amcache main tab
        self.Amcache_main_tab = QtWidgets.QWidget()
        self.Amcache_main_tab.setObjectName("Amcache_main_tab")
        self.verticalLayout_amcache_main = QtWidgets.QVBoxLayout(self.Amcache_main_tab)
        self.verticalLayout_amcache_main.setObjectName("verticalLayout_amcache_main")
        
        # Create Amcache tab widget to hold all table tabs
        self.Amcache_tab_widget = QtWidgets.QTabWidget(self.Amcache_main_tab)
        self.Amcache_tab_widget.setObjectName("Amcache_tab_widget")
        
        # Apply unified style to the tab widget
        from styles import CrowEyeStyles
        self.Amcache_tab_widget.setStyleSheet(CrowEyeStyles.UNIFIED_TAB_STYLE)
        
        # Create tabs for each Amcache table
        self.create_amcache_table_tabs()
        
        self.verticalLayout_amcache_main.addWidget(self.Amcache_tab_widget)
        self.main_tab.addTab(self.Amcache_main_tab, "")
        
        # Create MFT/USN Journal main tab
        self.MFT_USN_main_tab = QtWidgets.QWidget()
        self.MFT_USN_main_tab.setObjectName("MFT_USN_main_tab")
        self.verticalLayout_mft_usn_main = QtWidgets.QVBoxLayout(self.MFT_USN_main_tab)
        self.verticalLayout_mft_usn_main.setObjectName("verticalLayout_mft_usn_main")
        
        # Create MFT/USN tab widget to hold all table tabs
        self.MFT_USN_tab_widget = QtWidgets.QTabWidget(self.MFT_USN_main_tab)
        self.MFT_USN_tab_widget.setObjectName("MFT_USN_tab_widget")
        
        # Apply unified style to the tab widget
        from styles import CrowEyeStyles
        self.MFT_USN_tab_widget.setStyleSheet(CrowEyeStyles.UNIFIED_TAB_STYLE)
        
        # Create tabs for MFT and USN data
        self.create_mft_usn_table_tabs()
        
        self.verticalLayout_mft_usn_main.addWidget(self.MFT_USN_tab_widget)
        self.main_tab.addTab(self.MFT_USN_main_tab, "")
        
        # Create RecycleBin main tab
        self.RecycleBin_main_tab = QtWidgets.QWidget()
        self.RecycleBin_main_tab.setObjectName("RecycleBin_main_tab")
        self.verticalLayout_recyclebin_main = QtWidgets.QVBoxLayout(self.RecycleBin_main_tab)
        self.verticalLayout_recyclebin_main.setObjectName("verticalLayout_recyclebin_main")
        
        # Create RecycleBin table
        self.RecycleBin_main_table = QtWidgets.QTableWidget(self.RecycleBin_main_tab)
        self.RecycleBin_main_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.RecycleBin_main_table, 12, False, 300, 190)
        self.RecycleBin_main_table.setObjectName("RecycleBin_main_table")
        self.verticalLayout_recyclebin_main.addWidget(self.RecycleBin_main_table)
        
        # Add RecycleBin tab to main tab widget
        self.main_tab.addTab(self.RecycleBin_main_tab, "")
        
        # Create SRUM main tab
        self.SRUM_main_tab = QtWidgets.QWidget()
        self.SRUM_main_tab.setObjectName("SRUM_main_tab")
        self.verticalLayout_srum_main = QtWidgets.QVBoxLayout(self.SRUM_main_tab)
        self.verticalLayout_srum_main.setObjectName("verticalLayout_srum_main")
        
        # Create SRUM tab widget to hold all SRUM table tabs
        self.SRUM_tab_widget = QtWidgets.QTabWidget(self.SRUM_main_tab)
        self.SRUM_tab_widget.setObjectName("SRUM_tab_widget")
        
        # Apply unified style to the tab widget
        from styles import CrowEyeStyles
        self.SRUM_tab_widget.setStyleSheet(CrowEyeStyles.UNIFIED_TAB_STYLE)
        
        # Create Application Usage sub-tab
        self.SRUM_app_usage_tab = QtWidgets.QWidget()
        self.SRUM_app_usage_tab.setObjectName("SRUM_app_usage_tab")
        self.verticalLayout_srum_app = QtWidgets.QVBoxLayout(self.SRUM_app_usage_tab)
        self.verticalLayout_srum_app.setObjectName("verticalLayout_srum_app")
        
        self.SRUM_application_usage_table = QtWidgets.QTableWidget(self.SRUM_app_usage_tab)
        self.SRUM_application_usage_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.SRUM_application_usage_table, 20, False, 300, 190)
        self.SRUM_application_usage_table.setObjectName("SRUM_application_usage_table")
        self.verticalLayout_srum_app.addWidget(self.SRUM_application_usage_table)
        self.SRUM_tab_widget.addTab(self.SRUM_app_usage_tab, "")
        
        # Create Network Connectivity sub-tab
        self.SRUM_network_conn_tab = QtWidgets.QWidget()
        self.SRUM_network_conn_tab.setObjectName("SRUM_network_conn_tab")
        self.verticalLayout_srum_net_conn = QtWidgets.QVBoxLayout(self.SRUM_network_conn_tab)
        self.verticalLayout_srum_net_conn.setObjectName("verticalLayout_srum_net_conn")
        
        self.SRUM_network_connectivity_table = QtWidgets.QTableWidget(self.SRUM_network_conn_tab)
        self.SRUM_network_connectivity_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.SRUM_network_connectivity_table, 10, False, 300, 190)
        self.SRUM_network_connectivity_table.setObjectName("SRUM_network_connectivity_table")
        self.verticalLayout_srum_net_conn.addWidget(self.SRUM_network_connectivity_table)
        self.SRUM_tab_widget.addTab(self.SRUM_network_conn_tab, "")
        
        # Create Network Data Usage sub-tab
        self.SRUM_network_data_tab = QtWidgets.QWidget()
        self.SRUM_network_data_tab.setObjectName("SRUM_network_data_tab")
        self.verticalLayout_srum_net_data = QtWidgets.QVBoxLayout(self.SRUM_network_data_tab)
        self.verticalLayout_srum_net_data.setObjectName("verticalLayout_srum_net_data")
        
        self.SRUM_network_data_table = QtWidgets.QTableWidget(self.SRUM_network_data_tab)
        self.SRUM_network_data_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.SRUM_network_data_table, 10, False, 300, 190)
        self.SRUM_network_data_table.setObjectName("SRUM_network_data_table")
        self.verticalLayout_srum_net_data.addWidget(self.SRUM_network_data_table)
        self.SRUM_tab_widget.addTab(self.SRUM_network_data_tab, "")
        
        # Create Energy Usage sub-tab
        self.SRUM_energy_usage_tab = QtWidgets.QWidget()
        self.SRUM_energy_usage_tab.setObjectName("SRUM_energy_usage_tab")
        self.verticalLayout_srum_energy = QtWidgets.QVBoxLayout(self.SRUM_energy_usage_tab)
        self.verticalLayout_srum_energy.setObjectName("verticalLayout_srum_energy")
        
        self.SRUM_energy_usage_table = QtWidgets.QTableWidget(self.SRUM_energy_usage_tab)
        self.SRUM_energy_usage_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.SRUM_energy_usage_table, 10, False, 300, 190)
        self.SRUM_energy_usage_table.setObjectName("SRUM_energy_usage_table")
        self.verticalLayout_srum_energy.addWidget(self.SRUM_energy_usage_table)
        self.SRUM_tab_widget.addTab(self.SRUM_energy_usage_tab, "")
        
        self.verticalLayout_srum_main.addWidget(self.SRUM_tab_widget)
        self.main_tab.addTab(self.SRUM_main_tab, "")
        
        self.verticalLayout.addWidget(self.main_tab)
        self.horizontalLayout_2.addWidget(self.info_frame)
        # Give all stretch to content and none to sidebar
        try:
            self.horizontalLayout_2.setStretch(0, 0)
            self.horizontalLayout_2.setStretch(1, 1)
        except Exception:
            pass
        self.verticalLayout_2.addWidget(self.Main_frame)
        self.verticalLayout_2.setStretch(0, 1)
        self.verticalLayout_2.setStretch(1, 30)
        Crow_Eye.setCentralWidget(self.centralwidget)

        self.retranslateUi(Crow_Eye)
        self.main_tab.setCurrentIndex(2)
        self.Registry_widget.setCurrentIndex(0)
        self.filesActivityTab_tables.setCurrentIndex(5)
        self.tabWidget.setCurrentIndex(2)
        # Remove conflicting hide/show connections; animation handles visibility/width
        QtCore.QMetaObject.connectSlotsByName(Crow_Eye)
        Crow_Eye.setTabOrder(self.lnkbutton, self.logbutton)
        Crow_Eye.setTabOrder(self.logbutton, self.main_tab)
        Crow_Eye.setTabOrder(self.main_tab, self.main_menu)
        Crow_Eye.setTabOrder(self.main_menu, self.LNK_table)
        Crow_Eye.setTabOrder(self.LNK_table, self.registrybutton)

   



    def retranslateUi(self, Crow_Eye):
        _translate = QtCore.QCoreApplication.translate
        Crow_Eye.setWindowTitle(_translate("Crow_Eye", "Crow Eye"))
        
        # Refresh all tables to apply styles
        QtCore.QTimer.singleShot(100, self.refresh_all_tables)
        # Enable sorting for all tables
        self.enable_sorting_for_all_tables()
        self.label.setText(_translate("Crow_Eye", "Case:"))
        self.open_case_btn.setText(_translate("Crow_Eye", "Open case"))
        self.Creat_case.setText(_translate("Crow_Eye", "Creat case"))
        self.exprot_json_CSV.setText(_translate("Crow_Eye", "exprot as json and CSV"))
        
        self.Live_analysis.setText(_translate("Crow_Eye", "Live analysis "))
        self.parse_all.setText(_translate("Crow_Eye", "parse all Artifacts"))
        self.registrybutton.setText(_translate("Crow_Eye", "Registry"))
        self.lnkbutton.setText(_translate("Crow_Eye", "LNK and JUMPLIST"))

        self.Prefetchbutton.setText(_translate("Crow_Eye", "Prefetch"))
        self.ShimCacheButton.setText(_translate("Crow_Eye", "ShimCache"))
        self.AmcacheButton.setText(_translate("Crow_Eye", "Amcache"))
        self.MFT_USN_CorrelateButton.setText(_translate("Crow_Eye", "MFT and USN"))
        self.logbutton.setText(_translate("Crow_Eye", "Event Logs"))
        self.RecycleBinButton.setText(_translate("Crow_Eye", "Recycle Bin"))
        self.SRUMButton.setText(_translate("Crow_Eye", "SRUM"))
        self.Offline_analysis.setText(_translate("Crow_Eye", "offline analysis"))
        self.registry_offline.setText(_translate("Crow_Eye", "Registry offline"))
        self.offline_LNK_JL.setText(_translate("Crow_Eye", "Lnk and JL offline"))
        self.offline_prefetch.setText(_translate("Crow_Eye", "offline_Prefetch"))

        # Initialize computerName_table headers
        if hasattr(self, 'computerName_table'):
            self.computerName_table.setColumnCount(3)
            for i, header in enumerate(["Name", "Data", "Data Type"]):
                item = QtWidgets.QTableWidgetItem()
                self.computerName_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        if hasattr(self, 'computer_Name'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.computer_Name), 
                _translate("Crow_Eye", "Computer name")
            )
            
        # Initialize TimeZone_table headers
        if hasattr(self, 'TimeZone_table'):
            self.TimeZone_table.setColumnCount(3)
            for i, header in enumerate(["Name", "Data", "Data Type"]):
                item = QtWidgets.QTableWidgetItem()
                self.TimeZone_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        # Set tab text for Time Zone tab
        if hasattr(self, 'Time_Zone') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.Time_Zone),
                _translate("Crow_Eye", "Time Zone")
            )
            
        # Initialize NetworkInterface_table headers
        if hasattr(self, 'NetworkInterface_table'):
            self.NetworkInterface_table.setColumnCount(4)
            headers = ["Sub Key name", "Service", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.NetworkInterface_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
                
        # Set tab text for Network Interfaces tab
        if hasattr(self, 'NetworkInterfaces_tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.NetworkInterfaces_tab),
                _translate("Crow_Eye", "Network Interfaces")
            )
        # Initialize NetworkLists_table headers
        if hasattr(self, 'NetworkLists_table'):
            self.NetworkLists_table.setColumnCount(4)
            headers = ["Sub Key Name", "Service", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.NetworkLists_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
                
        # Set tab text for Network Lists tab
        if hasattr(self, 'Networklists') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.Networklists),
                _translate("Crow_Eye", "Network Lists")
            )
            
        # Initialize SystemServices_table headers if it exists
        # Initialize SystemServices_table headers if it exists
        if hasattr(self, 'SystemServices_table'):
            headers = [
                "Service Name", "Display Name", "Description",
                "Image Path", "Start type", "Service Type",
                "Error Control", "Status", "Analysis time"
            ]
            self.SystemServices_table.setColumnCount(len(headers))
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.SystemServices_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for System Services tab
        if hasattr(self, 'SystemServices') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.SystemServices),
                _translate("Crow_Eye", "System services")
            )
        
        # Initialize MachineRun_table headers if it exists
        if hasattr(self, 'MachineRun_table'):
            self.MachineRun_table.setColumnCount(3)
            headers = ["Name", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.MachineRun_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header.strip()))
        
        # Set tab text for Machine Run tab
        if hasattr(self, 'MachineRun') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.MachineRun),
                _translate("Crow_Eye", "Machine_Run")
            )
        
        # Initialize MachineRunOnce_table headers if it exists
        if hasattr(self, 'MachineRunOnce_tabel'):
            self.MachineRunOnce_tabel.setColumnCount(3)
            for i, header in enumerate(["Name", "Data", "Data Type"]):
                item = QtWidgets.QTableWidgetItem()
                self.MachineRunOnce_tabel.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Machine Run Once tab
        if hasattr(self, 'Machine_run_once') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.Machine_run_once),
                _translate("Crow_Eye", "Machine_run_once")
            )
        
        # Initialize UserRun_table headers if it exists
        if hasattr(self, 'UserRun_table'):
            self.UserRun_table.setColumnCount(3)
            for i, header in enumerate(["Name", "Data", "Data Type"]):
                item = QtWidgets.QTableWidgetItem()
                self.UserRun_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for User Run tab
        if hasattr(self, 'User_run') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.User_run),
                _translate("Crow_Eye", "User_Run")
            )
            
        # Initialize ShimCache_table headers if it exists (for Registry widget)
        if hasattr(self, 'ShimCache_table'):
            self.ShimCache_table.setColumnCount(5)
            headers = ["Filename", "Path", "Last Modified (Epoch)", "Last Modified", "Parsed Timestamp"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.ShimCache_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Initialize ShimCache_main_table headers for main tab
        if hasattr(self, 'ShimCache_main_table'):
            self.ShimCache_main_table.setColumnCount(5)
            headers = ["Filename", "Path", "Last Modified (Epoch)", "Last Modified", "Parsed Timestamp"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.ShimCache_main_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for ShimCache main tab
        if hasattr(self, 'ShimCache_main_tab') and hasattr(self, 'main_tab'):
            self.main_tab.setTabText(
                self.main_tab.indexOf(self.ShimCache_main_tab),
                _translate("Crow_Eye", "ShimCache")
            )
            
        # Set tab text for Amcache main tab
        if hasattr(self, 'Amcache_main_tab') and hasattr(self, 'main_tab'):
            self.main_tab.setTabText(
                self.main_tab.indexOf(self.Amcache_main_tab),
                _translate("Crow_Eye", "Amcache")
            )
            
        # Set tab text for MFT/USN main tab
        if hasattr(self, 'MFT_USN_main_tab') and hasattr(self, 'main_tab'):
            self.main_tab.setTabText(
                self.main_tab.indexOf(self.MFT_USN_main_tab),
                _translate("Crow_Eye", "MFT/USN")
            )
            
        # Initialize RecycleBin_main_table headers for main tab
        if hasattr(self, 'RecycleBin_main_table'):
            self.RecycleBin_main_table.setColumnCount(12)
            headers = ["Original Filename", "Original Path", "Deletion Time", "File Size", 
                      "User SID", "Recycle Bin Path", "R File Path", "I Filename", 
                      "R Filename", "File Signature", "Recovery Status", "Parsed At"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.RecycleBin_main_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for RecycleBin main tab
        if hasattr(self, 'RecycleBin_main_tab') and hasattr(self, 'main_tab'):
            self.main_tab.setTabText(
                self.main_tab.indexOf(self.RecycleBin_main_tab),
                _translate("Crow_Eye", "Recycle Bin")
            )
        
        # Initialize SRUM Application Usage table headers
        if hasattr(self, 'SRUM_application_usage_table'):
            self.SRUM_application_usage_table.setColumnCount(20)
            headers = [
                "ID", "Timestamp", "App Name", "App Path", "User SID", "User Name",
                "Foreground Cycle Time", "Background Cycle Time", "Face Time",
                "Foreground Context Switches", "Background Context Switches",
                "Foreground Bytes Read", "Foreground Bytes Written",
                "Foreground Read Operations", "Foreground Write Operations",
                "Foreground Flushes", "Background Bytes Read", "Background Bytes Written",
                "Background Read Operations", "Background Write Operations"
            ]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.SRUM_application_usage_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Initialize SRUM Network Connectivity table headers
        if hasattr(self, 'SRUM_network_connectivity_table'):
            self.SRUM_network_connectivity_table.setColumnCount(10)
            headers = [
                "ID", "Timestamp", "App Name", "App Path", "User SID", "User Name",
                "Interface LUID", "L2 Profile ID", "Connected Time", "Connect Start Time"
            ]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.SRUM_network_connectivity_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Initialize SRUM Network Data Usage table headers
        if hasattr(self, 'SRUM_network_data_table'):
            self.SRUM_network_data_table.setColumnCount(10)
            headers = [
                "ID", "Timestamp", "App Name", "App Path", "User SID", "User Name",
                "Interface LUID", "L2 Profile ID", "Bytes Sent", "Bytes Received"
            ]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.SRUM_network_data_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Initialize SRUM Energy Usage table headers
        if hasattr(self, 'SRUM_energy_usage_table'):
            self.SRUM_energy_usage_table.setColumnCount(10)
            headers = [
                "ID", "Timestamp", "App Name", "App Path", "User SID", "User Name",
                "Event Timestamp", "State Transition", "Charge Level", "Cycle Count"
            ]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.SRUM_energy_usage_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for SRUM main tab
        if hasattr(self, 'SRUM_main_tab') and hasattr(self, 'main_tab'):
            self.main_tab.setTabText(
                self.main_tab.indexOf(self.SRUM_main_tab),
                _translate("Crow_Eye", "SRUM")
            )
        
        # Set tab text for SRUM sub-tabs
        if hasattr(self, 'SRUM_tab_widget'):
            if hasattr(self, 'SRUM_app_usage_tab'):
                self.SRUM_tab_widget.setTabText(
                    self.SRUM_tab_widget.indexOf(self.SRUM_app_usage_tab),
                    _translate("Crow_Eye", "Application Usage")
                )
            if hasattr(self, 'SRUM_network_conn_tab'):
                self.SRUM_tab_widget.setTabText(
                    self.SRUM_tab_widget.indexOf(self.SRUM_network_conn_tab),
                    _translate("Crow_Eye", "Network Conn")
                )
            if hasattr(self, 'SRUM_network_data_tab'):
                self.SRUM_tab_widget.setTabText(
                    self.SRUM_tab_widget.indexOf(self.SRUM_network_data_tab),
                    _translate("Crow_Eye", "Network Usage")
                )
            if hasattr(self, 'SRUM_energy_usage_tab'):
                self.SRUM_tab_widget.setTabText(
                    self.SRUM_tab_widget.indexOf(self.SRUM_energy_usage_tab),
                    _translate("Crow_Eye", "Energy Usage")
                )
            
        # Set tab text for ShimCache tab (in Registry widget)
        if hasattr(self, 'ShimCache_tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.ShimCache_tab),
                _translate("Crow_Eye", "ShimCache")
            )
        
        # Initialize UserRunOnce_table headers if it exists
        if hasattr(self, 'UserRunOnce_table'):
            self.UserRunOnce_table.setColumnCount(3)
            for i, header in enumerate(["Name", "Data", "Data Type"]):
                item = QtWidgets.QTableWidgetItem()
                self.UserRunOnce_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for User Run Once tab
        if hasattr(self, 'User_run_once') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.User_run_once),
                _translate("Crow_Eye", "User_run_once")
            )
        
        # Initialize LastUpdate_table headers if it exists
        if hasattr(self, 'LastUpdate_table'):
            self.LastUpdate_table.setColumnCount(3)
            for i, header in enumerate(["Name", "Data", "Data Type"]):
                item = QtWidgets.QTableWidgetItem()
                self.LastUpdate_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Last Update tab
        if hasattr(self, 'Last_update') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.Last_update),
                _translate("Crow_Eye", "Last Update")
            )
        
        # Initialize LastUpdateInfo_table headers if it exists
        if hasattr(self, 'LastUpdateInfo_table'):
            self.LastUpdateInfo_table.setSortingEnabled(True)
            self.LastUpdateInfo_table.setColumnCount(4)
            headers = ["Sub key Name", "Service", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.LastUpdateInfo_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Last Update Info tab
        if hasattr(self, 'Lstupdate_info') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.Lstupdate_info),
                _translate("Crow_Eye", "Last update info")
            )
        
        # Initialize ShutDown_table headers if it exists
        if hasattr(self, 'ShutDown_table'):
            self.ShutDown_table.setColumnCount(3)
            for i, header in enumerate(["Name", "Data", "Data Type"]):
                item = QtWidgets.QTableWidgetItem()
                self.ShutDown_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Shutdown info tab
        if hasattr(self, 'ShutDown_tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.ShutDown_tab),
                _translate("Crow_Eye", "Shutdown info")
            )
        
        # Initialize Browser_history_table headers if it exists
        if hasattr(self, 'Browser_history_table'):
            self.Browser_history_table.setColumnCount(6)
            headers = ["Browser", "URL", "Title", "Visit count", "Last visit", "Time stamp"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.Browser_history_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Browser History tab
        if hasattr(self, 'Browser_history') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.Browser_history),
                _translate("Crow_Eye", "Browser History")
            )
            
        # Initialize ShimCache_table headers if it exists
        if hasattr(self, 'ShimCache_table'):
            self.ShimCache_table.setColumnCount(5)
            headers = ["Filename", "Path", "Last Modified", "Last Modified (Readable)", "Parsed Timestamp"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.ShimCache_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for ShimCache tab
        if hasattr(self, 'ShimCache_tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.ShimCache_tab),
                _translate("Crow_Eye", "ShimCache")
            )
        
        # Initialize USBDevices_table headers if it exists (USB Devices)
        if hasattr(self, 'USBDevices_table'):
            self.USBDevices_table.setColumnCount(5)
            headers = ["Device ID", "Description", "Manufacture", "Name of the USB", "Last Connected"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.USBDevices_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for USB Devices tab
        if hasattr(self, 'tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.tab),
                _translate("Crow_Eye", "USB Devices")
            )
        
        # Initialize USBInstances_table headers if it exists (USB Instance)
        if hasattr(self, 'USBInstances_table'):
            self.USBInstances_table.setColumnCount(6)
            headers = ["Device ID", "Instance ID", "Parent ID", "Service", "Status", "Description"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.USBInstances_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for USB Instance tab
        if hasattr(self, 'USBInstance_tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.USBInstance_tab),
                _translate("Crow_Eye", "USB Instance")
            )
        
        # Initialize USBProperties_table headers if it exists (USB Properties)
        if hasattr(self, 'USBProperties_table'):
            self.USBProperties_table.setColumnCount(4)
            headers = ["Device ID", "Property Name", "Property Value", "Property Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.USBProperties_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for USB Properties tab
        if hasattr(self, 'USBProperties_tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.USBProperties_tab),
                _translate("Crow_Eye", "USB Properties")
            )
        
        # Initialize USBStorageDevices_table headers if it exists (USB History)
        if hasattr(self, 'USBStorageDevices_table'):
            self.USBStorageDevices_table.setColumnCount(10)
            headers = [
                "Device ID", "Friendly Name", "Serial Number",
                "Vendor ID", "Product ID", "Revision",
                "First Connected", "Last connected", "Last Removed", "Analyzing Time"
            ]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.USBStorageDevices_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for USB Devices tab (formerly USB Storage Devices)
        if hasattr(self, 'USBStorageDevices_tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.USBStorageDevices_tab),
                _translate("Crow_Eye", "USB Devices")
            )
        
        # Initialize USBStorageVolumes_table headers if it exists (USB Storage Volumes)
        if hasattr(self, 'USBStorageVolumes_table'):
            self.USBStorageVolumes_table.setColumnCount(5)
            headers = ["Device ID", "Volume GUID", "Volume Name", "Drive Letter", "Time Stamp"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.USBStorageVolumes_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for USB Volume tab (formerly USB Storage Volumes)
        if hasattr(self, 'USBStorageVolumes_tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.USBStorageVolumes_tab),
                _translate("Crow_Eye", "USB Volume")
            )
        
        # Set main tab text for Registry
        if hasattr(self, 'main_tab') and hasattr(self, 'Registry_Tab'):
            self.main_tab.setTabText(
                self.main_tab.indexOf(self.Registry_Tab),
                _translate("Crow_Eye", "Registry")
            )
        
        # Initialize RecentDocs_table headers if it exists
        if hasattr(self, 'RecentDocs_table'):
            self.RecentDocs_table.setColumnCount(4)
            headers = ["Sub Key Name", "Service", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.RecentDocs_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Recent Docs tab
        if hasattr(self, 'Recent_docs_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.Recent_docs_tab),
                _translate("Crow_Eye", "Recent Docs")
            )
        
        # Initialize SearchViaExplorer_table headers if it exists
        if hasattr(self, 'SearchViaExplorer_table'):
            self.SearchViaExplorer_table.setColumnCount(3)
            headers = ["Name", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.SearchViaExplorer_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header.strip()))
        
        # Set tab text for Search via Explorer bar tab
        if hasattr(self, 'SearchViaExplorerbar_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.SearchViaExplorerbar_tab),
                _translate("Crow_Eye", "Explorer Search")
            )
        
        # Initialize OpenSaveMRU_table headers if it exists
        if hasattr(self, 'OpenSaveMRU_table'):
            self.OpenSaveMRU_table.setColumnCount(7)
            headers = ["Sub key Name", "Service", "Data", "Data Type", "File Path", "Extension", "Access Date"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.OpenSaveMRU_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header.strip()))
        
        # Set tab text for Open Save MRU tab
        if hasattr(self, 'OpenSaveMru') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.OpenSaveMru),
                _translate("Crow_Eye", "Open Save MRU")
            )
        
        # Initialize LastSaveMRU_table headers if it exists
        if hasattr(self, 'LastSaveMRU_table'):
            self.LastSaveMRU_table.setColumnCount(6)
            headers = ["Name", "Data", "Data Type", "Folder Path", "Application", "Access Date"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.LastSaveMRU_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Last Save MRU tab
        if hasattr(self, 'LastSaveMRU_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.LastSaveMRU_tab),
                _translate("Crow_Eye", "Last Save MRU")
            )
        
        # Initialize TypedPath_table headers if it exists
        if hasattr(self, 'TypedPath_table'):
            self.TypedPath_table.setColumnCount(3)
            headers = ["Name", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.TypedPath_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header.strip()))
        
        # Set tab text for Typed Paths tab
        if hasattr(self, 'TypedPathes_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.TypedPathes_tab),
                _translate("Crow_Eye", "Typed Paths")
            )
        
        # Initialize Bam_table headers if it exists (BAM)
        if hasattr(self, 'Bam_table'):
            self.Bam_table.setColumnCount(10)
            headers = ["Sub Key Name", "Service", "Data", "Data Type", "App Name", "Process Path", "SID", "Last Execution", "Execution Flags", "Timestamp"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.Bam_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header.strip()))
        
        # Set tab text for BAM tab
        if hasattr(self, 'BAM_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.BAM_tab),
                _translate("Crow_Eye", "BAM")
            )
        
        # Initialize Dam_table headers if it exists (DAM)
        if hasattr(self, 'Dam_table'):
            self.Dam_table.setColumnCount(10)
            headers = ["Sub Key Name", "Service", "Data", "Data Type", "App Name", "Process Path", "SID", "Last Execution", "Execution Count", "Timestamp"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.Dam_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header.strip()))
        
        # Set tab text for DAM tab
        if hasattr(self, 'Dam_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.Dam_tab),
                _translate("Crow_Eye", "DAM")
            )
        
        # Initialize UserAssist_table headers if it exists
        if hasattr(self, 'UserAssist_table'):
            self.UserAssist_table.setColumnCount(6)
            headers = ["Program Path", "Run Count", "Last Execution", "Focus Count", "Focus Time (ms)", "User SID"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.UserAssist_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for UserAssist tab
        if hasattr(self, 'UserAssist_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.UserAssist_tab),
                _translate("Crow_Eye", "UserAssist")
            )
        
        # Initialize Shellbags_table headers if it exists
        if hasattr(self, 'Shellbags_table'):
            self.Shellbags_table.setColumnCount(6)
            headers = ["Folder Path", "Folder Name", "Type", "MRU Position", "Access Date", "Registry Path"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.Shellbags_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Shellbags tab
        if hasattr(self, 'Shellbags_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.Shellbags_tab),
                _translate("Crow_Eye", "Shellbags")
            )
        
        # Initialize RunMRU_table headers if it exists
        if hasattr(self, 'RunMRU_table'):
            self.RunMRU_table.setColumnCount(3)
            headers = ["Command", "MRU Position", "Access Date"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.RunMRU_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for RunMRU tab
        if hasattr(self, 'RunMRU_tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.RunMRU_tab),
                _translate("Crow_Eye", "RunMRU")
            )
        
        # Initialize MUICache_table headers if it exists
        if hasattr(self, 'MUICache_table'):
            self.MUICache_table.setColumnCount(3)
            headers = ["Application Path", "Application Name", "File Extension"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.MUICache_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for MUICache tab
        if hasattr(self, 'MUICache_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.MUICache_tab),
                _translate("Crow_Eye", "MUICache")
            )
        
        # Initialize WordWheelQuery_table headers if it exists
        if hasattr(self, 'WordWheelQuery_table'):
            self.WordWheelQuery_table.setColumnCount(4)
            headers = ["Search Term", "Search Type", "MRU Position", "Access Date"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.WordWheelQuery_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for WordWheelQuery tab
        if hasattr(self, 'WordWheelQuery_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.WordWheelQuery_tab),
                _translate("Crow_Eye", "WordWheelQuery")
            )
        
        # Set tooltip for Installed Software
        if hasattr(self, 'Installed_sowftare'):
            self.Installed_sowftare.setToolTip(_translate(
                "Crow_Eye",
                "<html><head/><body><p>Installed Software</p><p><br/></p></body></html>"
            ))
        
        # Initialize tableWidget headers if it exists (Installed Software)
        if hasattr(self, 'tableWidget'):
            self.tableWidget.setColumnCount(7)
            headers = [
                "Name", "Version", "Publisher", "Install Date",
                "Install Location", "Uninstall String", "Analyzing Date"
            ]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.tableWidget.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Installed Software tab
        if hasattr(self, 'Installed_sowftare') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.Installed_sowftare),
                _translate("Crow_Eye", "Installed Software")
            )
        
        # Set main tab text for Files Activity
        if hasattr(self, 'main_tab') and hasattr(self, 'filesActivity_tab'):
            self.main_tab.setTabText(
                self.main_tab.indexOf(self.filesActivity_tab),
                _translate("Crow_Eye", "Files Activity")
            )
        
        # Initialize Prefetch_table headers if it exists
        if hasattr(self, 'Prefetch_table'):
            self.Prefetch_table.setColumnCount(12)  # Updated column count to match new database structure
            headers = [
                "Filename", "Executable Name", "Hash", "Run Count", "Last Executed",
                "Run Times", "Volumes", "Directories", "Resources",
                "Created On", "Modified On", "Accessed On"
            ]
            for i, header in enumerate(headers):
                if i < self.Prefetch_table.columnCount():  # Ensure we don't exceed column count
                    item = QtWidgets.QTableWidgetItem()
                    self.Prefetch_table.setHorizontalHeaderItem(i, item)
                    item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Prefetch tab if it exists
        if hasattr(self, 'tab_9') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.tab_9),
                _translate("Crow_Eye", "Prefetch")
            )
        
        # Set main tab text for Prefetch tab
        if hasattr(self, 'main_tab') and hasattr(self, 'Prefetch_tab'):
            self.main_tab.setTabText(
                self.main_tab.indexOf(self.Prefetch_tab),
                _translate("Crow_Eye", "Prefetch")
            )
        
        # Initialize LNK_table headers if it exists
        if hasattr(self, 'LNK_table'):
            self.LNK_table.setSortingEnabled(True)
            self.LNK_table.setColumnCount(33)  # Total number of columns in the table
            headers = [
                "Source_Name", "Source_path", "Owner UID", "Owner GID", "Time_Access",
                "Time_Creation", "Time_modefication", "app_Type", "App_ID",
                "Artifact", "Dataflag", "Local_Path", "Common Path", "Location_Flags",
                "Volume_Label", "Local_Base_Path", "Relative_Path", "Working_Dir",
                "Command_Line_Arguments", "Icon_Location", "Show_Window_Command",
                "Hot_Key_Flags", "Hot_Key_Value", "File_Attributes_Flags",
                "File_Size", "Drive_Type", "Drive_Serial_Number", "Volume_Name",
                "Network_Providers", "Network_share_Flags", "Network_Share_Name",
                "Network_Share_Name_UNI", "File_Permission", "Number of the hardlinks",
                "Device_ID", "Inode number"
            ]
            for i, header in enumerate(headers):
                if i < self.LNK_table.columnCount():  # Ensure we don't exceed column count
                    item = QtWidgets.QTableWidgetItem()
                    self.LNK_table.setHorizontalHeaderItem(i, item)
                    item.setText(_translate("Crow_Eye", header))
            
            # Set main tab text for LNK and Jump List tab if it exists
            if hasattr(self, 'main_tab') and hasattr(self, 'LNK_JL_Tab'):
                self.main_tab.setTabText(
                    self.main_tab.indexOf(self.LNK_JL_Tab),
                    _translate("Crow_Eye", "LNK and JL")
                )
                
            # Set subtab texts for LNK and Jump List subtabs
            if hasattr(self, 'lnk_jl_subtabs'):
                if hasattr(self, 'LNK_subtab'):
                    self.lnk_jl_subtabs.setTabText(
                        self.lnk_jl_subtabs.indexOf(self.LNK_subtab),
                        _translate("Crow_Eye", "LNK Files")
                    )
                    
                if hasattr(self, 'AJL_subtab'):
                    self.lnk_jl_subtabs.setTabText(
                        self.lnk_jl_subtabs.indexOf(self.AJL_subtab),
                        _translate("Crow_Eye", "Automatic Jump Lists")
                    )
                    
                if hasattr(self, 'CJL_subtab'):
                    self.lnk_jl_subtabs.setTabText(
                        self.lnk_jl_subtabs.indexOf(self.CJL_subtab),
                        _translate("Crow_Eye", "Custom Jump Lists")
                    )
        # Initialize AJL_table headers if it exists
        if hasattr(self, 'AJL_table'):
            self.AJL_table.setSortingEnabled(True)
            self.AJL_table.setColumnCount(33)  # Same columns as LNK table
            headers = [
                "Source_Name", "Source_path", "Owner UID", "Owner GID", "Time_Access",
                "Time_Creation", "Time_modefication", "app_Type", "App_ID",
                "Artifact", "Dataflag", "Local_Path", "Common Path", "Location_Flags",
                "Volume_Label", "Local_Base_Path", "Relative_Path", "Working_Dir",
                "Command_Line_Arguments", "Icon_Location", "Show_Window_Command",
                "Hot_Key_Flags", "Hot_Key_Value", "File_Attributes_Flags",
                "File_Size", "Drive_Type", "Drive_Serial_Number", "Volume_Name",
                "Network_Providers", "Network_share_Flags", "Network_Share_Name",
                "Network_Share_Name_UNI", "File_Permission", "Number of the hardlinks",
                "Device_ID", "Inode number"
            ]
            for i, header in enumerate(headers):
                if i < self.AJL_table.columnCount():  # Ensure we don't exceed column count
                    item = QtWidgets.QTableWidgetItem()
                    self.AJL_table.setHorizontalHeaderItem(i, item)
                    item.setText(_translate("Crow_Eye", header))
        
        # Initialize Clj_table headers if it exists
        if hasattr(self, 'Clj_table'):
            self.Clj_table.setSortingEnabled(True)
            self.Clj_table.setColumnCount(13)  # Total number of columns in the table
            headers = [
                "File name", "File Directory", "Owner UID", "Owner GID", "Access time",
                "Creation Time", "Modification Time", "File Size", "File permission", "File Type",
                "numbers_hard_links", "Device_id", "Inode number", "Artifact"
            ]
            for i, header in enumerate(headers):
                if i < self.Clj_table.columnCount():  # Ensure we don't exceed column count
                    item = QtWidgets.QTableWidgetItem()
                    self.Clj_table.setHorizontalHeaderItem(i, item)
                    item.setText(_translate("Crow_Eye", header))
            
            # CJL tab text is now set as part of the LNK_JL_Tab subtabs
        # Initialize AppLogs_table headers if it exists
        if hasattr(self, 'AppLogs_table'):
            self.AppLogs_table.setSortingEnabled(True)
            self.AppLogs_table.setColumnCount(9)  # Total number of columns in the table
            headers = [
                "Event ID", "Source", "Event Type", "Category", "Time",
                "Computer Name", "User", "Key words", "Event Description"
            ]
            for i, header in enumerate(headers):
                if i < self.AppLogs_table.columnCount():  # Ensure we don't exceed column count
                    item = QtWidgets.QTableWidgetItem()
                    self.AppLogs_table.setHorizontalHeaderItem(i, item)
                    item.setText(_translate("Crow_Eye", header))
            
            # Set tab text for AppLogs tab if it exists
            if hasattr(self, 'tabWidget') and hasattr(self, 'AppLogs_tab'):
                self.tabWidget.setTabText(
                    self.tabWidget.indexOf(self.AppLogs_tab),
                    _translate("Crow_Eye", "Application Logs")
                )
        # Initialize SecurityLogs_table headers if it exists
        if hasattr(self, 'SecurityLogs_table'):
            self.SecurityLogs_table.setSortingEnabled(True)
            self.SecurityLogs_table.setColumnCount(10)  # Total number of columns in the table
            headers = [
                "Event ID", "Source", "Event Type", "Category", "Time",
                "Computer Name", "User", "Key words", "Task Level", "Event Description"
            ]
            for i, header in enumerate(headers):
                if i < self.SecurityLogs_table.columnCount():  # Ensure we don't exceed column count
                    item = QtWidgets.QTableWidgetItem()
                    self.SecurityLogs_table.setHorizontalHeaderItem(i, item)
                    item.setText(_translate("Crow_Eye", header))
            
            # Set tab text for Security Logs tab if it exists
            if hasattr(self, 'tabWidget') and hasattr(self, 'SecurityLogs_tab'):
                self.tabWidget.setTabText(
                    self.tabWidget.indexOf(self.SecurityLogs_tab),
                    _translate("Crow_Eye", "Security Logs")
                )
        # Initialize SystemLogs_table headers if it exists
        if hasattr(self, 'SystemLogs_table'):
            self.SystemLogs_table.setSortingEnabled(True)
            self.SystemLogs_table.setColumnCount(9)  # Total number of columns in the table
            headers = [
                "Event ID", "Source", "Event Type", "Category", "Time",
                "Computer Name", "User", "Key words", "Event Description"
            ]
            for i, header in enumerate(headers):
                if i < self.SystemLogs_table.columnCount():  # Ensure we don't exceed column count
                    item = QtWidgets.QTableWidgetItem()
                    self.SystemLogs_table.setHorizontalHeaderItem(i, item)
                    item.setText(_translate("Crow_Eye", header))
            
            # Set tab text for System Logs tab if it exists
            if hasattr(self, 'tabWidget') and hasattr(self, 'SystemLogs_tab'):
                self.tabWidget.setTabText(
                    self.tabWidget.indexOf(self.SystemLogs_tab),
                    _translate("Crow_Eye", "System Logs")
                )
        
        # Set main tab text for Logs tab if it exists
        if hasattr(self, 'main_tab') and hasattr(self, 'Logs_tab'):
            self.main_tab.setTabText(
                self.main_tab.indexOf(self.Logs_tab),
                _translate("Crow_Eye", "Logs")
            )



               

                
        # Connect data loading buttons with enhanced cyberpunk loading
        self.lnkbutton.clicked.connect(lambda: self.show_loading_screen_with_function(
            "LOADING LNK DATA", self.load_data_from_database_lnkAJL))

        self.logbutton.clicked.connect(self.load_all_logs)
        
        # Keep existing analysis button connections
        self.lnkbutton.clicked.connect(self.run_lnk_analysis)
        self.registrybutton.clicked.connect(self.run_registry_analysis)
        self.logbutton.clicked.connect(self.run_logs_analysis)
        self.Prefetchbutton.clicked.connect(self.run_prefetch_analysis)
        self.ShimCacheButton.clicked.connect(self.run_shimcache_analysis)
        self.AmcacheButton.clicked.connect(self.run_amcache_analysis)
        self.MFT_USN_CorrelateButton.clicked.connect(self.run_mft_usn_correlation)
        self.RecycleBinButton.clicked.connect(self.run_recyclebin_analysis)
        self.SRUMButton.clicked.connect(self.run_srum_analysis)
        self.exprot_json_CSV.clicked.connect(self.export_all_tables)
        
        self.Creat_case.clicked.connect(self.create_directory)
        self.open_case_btn.clicked.connect(self.open_existing_case)
        # Connect parse_all button to live artifacts collection
        self.parse_all.clicked.connect(lambda: self.run_analysis_with_loading(
            "Running All Live Artifacts Analysis...", self.parse_all_live_artifacts))

        self.offline_prefetch.clicked.connect(self.run_offline_prefetch_analysis)
        self.offline_LNK_JL.clicked.connect(self.run_offline_lnk_analysis)
        self.registry_offline.clicked.connect(self.run_offline_registry_analysis)
        
        # Initialize database search integration
        self._init_database_search()



    def _init_database_search(self):
        """Initialize database search functionality"""
        try:
            print("[Info] Initializing database search...")
            
            # Import with detailed error reporting
            try:
                from ui.database_search_integration import DatabaseSearchIntegration
                print("[Info] DatabaseSearchIntegration imported successfully")
            except ImportError as ie:
                print(f"[Error] Failed to import DatabaseSearchIntegration: {ie}")
                return
            
            from PyQt5.QtWidgets import QShortcut
            from PyQt5.QtGui import QKeySequence
            
            # Create database search integration
            self.db_search_integration = DatabaseSearchIntegration(self)
            print("[Info] DatabaseSearchIntegration instance created")
            
            # Create shortcut for database search (Ctrl+Shift+F)
            self.db_search_shortcut = QShortcut(QKeySequence("Ctrl+Shift+F"), self.main_window)
            self.db_search_shortcut.activated.connect(self._show_database_search)
            
            print("[Info] Database search initialized - Press Ctrl+Shift+F to search")
        except Exception as e:
            print(f"[Error] Failed to initialize database search: {str(e)}")
            import traceback
            traceback.print_exc()
    

    
    def _show_database_search(self):
        """Show database search dialog"""
        try:
            # Check if a case is loaded
            if not hasattr(self, 'case_paths') or not self.case_paths:
                QtWidgets.QMessageBox.warning(
                    self.main_window,
                    "No Case Loaded",
                    "Please open or create a case before using database search.\n\n"
                    "Use 'Create case' or 'Open case' buttons to get started."
                )
                return
            
            # Check if artifacts directory exists
            artifacts_dir = self.case_paths.get('artifacts_dir')
            if not artifacts_dir or not os.path.exists(artifacts_dir):
                QtWidgets.QMessageBox.warning(
                    self.main_window,
                    "No Artifacts Directory",
                    "The case artifacts directory does not exist.\n\n"
                    "Please collect forensic artifacts first."
                )
                return
            
            print("[Info] Opening database search dialog...")
            if hasattr(self, 'db_search_integration'):
                # Get artifacts directory from case_paths (where databases are stored)
                case_directory = self.case_paths.get('artifacts_dir', '')
                self.db_search_integration.show_search_dialog(case_directory)
            else:
                print("[Error] Database search integration not initialized")
                QtWidgets.QMessageBox.warning(
                    self.main_window,
                    "Database Search",
                    "Database search is not available. Please check the console for errors."
                )
        except Exception as e:
            print(f"[Error] Failed to show database search: {str(e)}")
            import traceback
            traceback.print_exc()
            QtWidgets.QMessageBox.critical(
                self.main_window,
                "Database Search Error",
                f"An error occurred:\n{str(e)}"
            )

    def get_app_config_dir(self):
        """Get the configuration and default case directories"""
        app_dir = os.path.dirname(os.path.abspath(__file__))
        config_dir = os.path.join(app_dir, 'config')
        os.makedirs(config_dir, exist_ok=True)
        # Use user's Documents\CrowEye as default cases root if available, fallback to current directory
        user_docs = os.path.join(os.path.expanduser('~'), 'Documents', 'CrowEye')
        default_dir = user_docs if os.path.isdir(os.path.dirname(user_docs)) else os.path.dirname(os.path.abspath(__file__))
        os.makedirs(default_dir, exist_ok=True)
        return config_dir, default_dir

    def save_last_case(self, case_config):
        """Persist the last opened/created case info."""
        config_dir, _ = self.get_app_config_dir()
        last_case_path = os.path.join(config_dir, 'last_case.json')
        try:
            with open(last_case_path, 'w') as f:
                json.dump(case_config, f, indent=4)
        except Exception as e:
            print(f"[Error] Failed to save last case: {str(e)}")

    def load_last_case(self):
        """Load the last used case by delegating to open_case()."""
        config_dir, _ = self.get_app_config_dir()
        last_case_file = os.path.join(config_dir, 'last_case.json')
        if not os.path.exists(last_case_file):
            return False
        try:
            with open(last_case_file, 'r') as f:
                case_config = json.load(f)
            directory_path = case_config.get('paths', {}).get('case_root')
            if not directory_path or not os.path.exists(directory_path):
                return False
            self.open_case(directory_path)
            return True
        except Exception as e:
            print(f"[Error] Failed to load last case: {str(e)}")
            return False

    def open_case(self, directory_path=None):
        """Open and load a case.
        If directory_path is None, prompt the user to pick a directory.
        """
        # Ask for directory if not provided
        config_dir, default_cases_dir = self.get_app_config_dir()
        if directory_path is None:
            directory_path = QFileDialog.getExistingDirectory(
                self.main_window,
                "Select Case Directory",
                default_cases_dir,
                QFileDialog.ShowDirsOnly
            )
            if not directory_path:
                return None

        try:
            # Clear any existing data from tables and ensure DB connections are closed
            try:
                self.clear_all_tables()
            except Exception:
                pass
            try:
                self.close_all_database_connections()
            except Exception:
                pass
            # Ensure artifacts directory exists
            artifacts_dir = os.path.join(directory_path, "Target_Artifacts")
            os.makedirs(artifacts_dir, exist_ok=True)
            # Store paths
            self.case_paths = {
                'case_root': directory_path,
                'artifacts_dir': artifacts_dir,
                'c_ajl_lnk_dir': os.path.join(artifacts_dir, "C_AJL_Lnk"),
                'registry_dir': os.path.join(artifacts_dir, "Registry_Hives"),
                'prefetch_dir': os.path.join(artifacts_dir, "Prefetch"),
                'mft_dir': os.path.join(artifacts_dir, "MFT"),
                'usn_dir': os.path.join(artifacts_dir, "USN_Journal"),
                'databases': {
                    'registry': os.path.join(artifacts_dir, 'registry_data.db'),
                    'lnk': os.path.join(artifacts_dir, 'LnkDB.db'),
                    'logs': os.path.join(artifacts_dir, 'Log_Claw.db'),
                    'prefetch': os.path.join(artifacts_dir, 'prefetch_data.db'),
                    'shimcache': os.path.join(artifacts_dir, 'shimcache.db'),
                    'amcache': os.path.join(artifacts_dir, 'amcache.db'),
                    'recyclebin': os.path.join(artifacts_dir, 'recyclebin_analysis.db'),
                    'mft': os.path.join(artifacts_dir, 'mft_claw_analysis.db'),
                    'usn': os.path.join(artifacts_dir, 'USN_journal.db'),
                    'mft_usn_correlated': os.path.join(artifacts_dir, 'mft_usn_correlated_analysis.db')
                }
            }
            # Create directories (excluding databases dictionary)
            for key, path in self.case_paths.items():
                if key != 'databases' and isinstance(path, str):
                    os.makedirs(path, exist_ok=True)
            # Update UI
            case_name = os.path.basename(directory_path)
            self.label.setText(f"Case: {case_name}")
            
            # Save case config and mark as last
            case_config = {
                'case_name': case_name,
                'opened_date': datetime.datetime.now().isoformat(),
                'paths': self.case_paths,
                'databases': {
                    'registry': os.path.join(self.case_paths['artifacts_dir'], 'registry_data.db'),
                    'lnk': os.path.join(self.case_paths['artifacts_dir'], 'LnkDB.db'),
                    'logs': os.path.join(self.case_paths['artifacts_dir'], 'Log_Claw.db'),
                    'prefetch': os.path.join(self.case_paths['artifacts_dir'], 'prefetch_data.db'),
                    'shimcache': os.path.join(self.case_paths['artifacts_dir'], 'shimcache.db'),
                    'amcache': os.path.join(self.case_paths['artifacts_dir'], 'amcache.db'),
                    'recyclebin': os.path.join(self.case_paths['artifacts_dir'], 'recyclebin_analysis.db'),
                    'mft': os.path.join(self.case_paths['artifacts_dir'], 'mft_claw_analysis.db'),
                    'usn': os.path.join(self.case_paths['artifacts_dir'], 'USN_journal.db'),
                    'mft_usn_correlated': os.path.join(self.case_paths['artifacts_dir'], 'mft_usn_correlated_analysis.db')
                }
            }
            config_path = os.path.join(config_dir, f"case_{case_name}.json")
            with open(config_path, 'w') as f:
                json.dump(case_config, f, indent=4)
            self.save_last_case(case_config)
        
            # Check if this is a new case (no database files exist yet)
            db_files_exist = any(os.path.exists(db_path) for db_path in case_config['databases'].values())
        
            if not db_files_exist:
                # Only run full analysis for new cases
                print(f"[Open Case] New case detected, running full analysis for case: {case_name}")
                self.run_analysis_with_loading("Running All Analyses...", self.parse_all_live_artifacts)
            else:
                # For existing cases, just load the existing data
                print(f"[Open Case] Loading existing case data for: {case_name}")
                self.run_analysis_with_loading("Loading Case Data...", self.load_all_data)
        
            print(f"[Open Case] Successfully opened case: {case_name}")
            return self.case_paths
        except Exception as e:
            QMessageBox.critical(
                self.main_window,
                "Error",
                f"Failed to open case:\n{str(e)}"
            )
            return None

    def animate_progress_bar(self, progress_bar):
        """Animate the progress bar to make it more visible"""
        # For indeterminate progress bars, we can change the text to show activity
        current_text = progress_bar.text()
        if not current_text:
            progress_bar.setText("Processing")
        elif current_text == "Processing":
            progress_bar.setText("Processing.")
        elif current_text == "Processing.":
            progress_bar.setText("Processing..")
        elif current_text == "Processing..":
            progress_bar.setText("Processing...")
        else:
            progress_bar.setText("Processing")

    def load_case_config(self, case_name):
        """Load case configuration from file"""
        config_dir, _ = self.get_app_config_dir()  # Get config dir only
        config_path = os.path.join(config_dir, f"case_{case_name}.json")
        
        try:
            with open(config_path, 'r') as config_file:
                return json.load(config_file)
        except Exception as e:
            QMessageBox.critical(
                self.main_window,
                "Error",
                f"Failed to load case configuration:\n{str(e)}"
            )
            return None
            
    def save_case_config(self):
        """Save current case configuration to file"""
        if not hasattr(self, 'case_paths') or not self.case_paths:
            print("[Warning] No case paths available to save configuration")
            return
            
        case_name = os.path.basename(self.case_paths.get('case_root', ''))
        if not case_name:
            print("[Warning] Invalid case name, cannot save configuration")
            return
            
        config_dir, _ = self.get_app_config_dir()  # Get config dir only
        config_path = os.path.join(config_dir, f"case_{case_name}.json")
        
        try:
            # Load existing config first
            with open(config_path, 'r') as config_file:
                case_config = json.load(config_file)
                
            # Update the config with current paths and databases
            case_config['paths'] = self.case_paths
            
            # Write back the updated config
            with open(config_path, 'w') as config_file:
                json.dump(case_config, config_file, indent=4)
                
            # Update last case file
            self.save_last_case(case_config)
            print(f"[Info] Case configuration saved for: {case_name}")
        except Exception as e:
            print(f"[Error] Failed to save case configuration: {str(e)}")
            return None

    def clear_all_tables(self):
        """Clear all table widgets in the GUI"""
        # Clear all tables in the GUI
        tables_to_clear = [
            # Registry tables
            self.computerName_table, self.TimeZone_table, self.NetworkInterface_table,
            self.NetworkLists_table, self.MachineRun_table, self.UserRun_table,
            self.UserRunOnce_table, self.LastUpdate_table, self.LastUpdateInfo_table,
            self.ShutDown_table, self.Browser_history_table,
            # Files activity tables
            self.RecentDocs_table, self.SearchViaExplorer_table, self.OpenSaveMRU_table,
            self.LastSaveMRU_table, self.TypedPath_table, self.Bam_table, self.Dam_table,
            # Prefetch table
            self.Prefetch_table,
            # LNK and JL tables
            self.LNK_table, self.Clj_table,
            # Logs table
            self.AppLogs_table,
            # MFT-related tables
            getattr(self, 'MFT_table', None),
            getattr(self, 'MFT_standard_info_table', None),
            getattr(self, 'MFT_file_names_table', None),
            getattr(self, 'MFT_data_attributes_table', None),
            # USN and Correlated tables
            getattr(self, 'USN_table', None),
            getattr(self, 'Correlated_table', None)
        ]
        
        for table in tables_to_clear:
            try:
                if table is not None:
                    table.setRowCount(0)
            except Exception:
                # Skip tables that may not be initialized yet
                pass
        
        self.clear_search_results()
    
    def hide_loading_screen(self):
        """Hide the loading screen"""
        try:
            if hasattr(self, 'loading_overlay') and self.loading_overlay:
                self.loading_overlay.hide()
                # Don't deleteLater here as it can cause issues with rapid show/hide
                # Just hide it and let it be reused
        except Exception as e:
            print(f"Error hiding loading screen: {e}")
            # Try to clean up if possible
            if hasattr(self, 'loading_overlay'):
                try:
                    self.loading_overlay.deleteLater()
                except:
                    pass
                    
    def clear_search_results(self):
        """Clear search results and reset search UI"""
        # Clear search results
        self.search_results = []
        self.current_result_index = -1
        
        # Clear search input if it exists
        if hasattr(self, 'search_input'):
            self.search_input.clear()
        
        # Update navigation buttons
        if hasattr(self, 'prev_result_button'):
            self.prev_result_button.setEnabled(False)
        if hasattr(self, 'next_result_button'):
            self.next_result_button.setEnabled(False)
        if hasattr(self, '_search_button'):
            self._search_button.setEnabled(False)
            
        # Clear any highlighting
        self.clear_highlighting()
        
    
    def close_all_database_connections(self):
        """Close any open database connections"""
        # SQLite doesn't maintain persistent connections, but we'll ensure any open ones are closed
        # This is a safety measure to ensure no connections are left open
        import gc
        for obj in gc.get_objects():
            if isinstance(obj, sqlite3.Connection):
                try:
                    obj.close()
                except Exception:
                    pass
    
    def create_directory(self):
        """Create case directory structure and store paths in class variables"""
        self.Creat_case.setEnabled(False)
        
        try:
            # Clear all tables and close database connections before creating a new case
            self.clear_all_tables()
            self.close_all_database_connections()
            
            # Get config directory and default cases directory
            config_dir, default_cases_dir = self.get_app_config_dir()
            
            # Get parent directory, starting from the default cases directory
            directory_path = QFileDialog.getExistingDirectory(
                self.main_window,
                "Select Parent Directory",
                default_cases_dir,  # Start in the default cases directory
                QFileDialog.ShowDirsOnly
            )
            
            if not directory_path:  # User cancelled
                self.Creat_case.setEnabled(True)
                return None
                
            # Get case directory name
            dir_name, ok = QInputDialog.getText(
                self.main_window,
                "Case Directory Name", 
                "Enter name for new case:",
                QLineEdit.Normal,
                "New_Case"
            )
            
            if not ok or not dir_name.strip():
                self.Creat_case.setEnabled(True)
                return None
                
            # Store paths as class variables
            artifacts_dir = os.path.join(os.path.join(directory_path, dir_name), "Target_Artifacts")
            self.case_paths = {
                'case_root': os.path.join(directory_path, dir_name),
                'artifacts_dir': artifacts_dir,
                'c_ajl_lnk_dir': os.path.join(artifacts_dir, "C_AJL_Lnk"),
                'registry_dir': os.path.join(artifacts_dir, "Registry_Hives"),
                'prefetch_dir': os.path.join(artifacts_dir, "Prefetch"),
                'mft_dir': os.path.join(artifacts_dir, "MFT"),
                'usn_dir': os.path.join(artifacts_dir, "USN_Journal"),
                'databases': {
                    'registry': os.path.join(artifacts_dir, 'registry_data.db'),
                    'lnk': os.path.join(artifacts_dir, 'LnkDB.db'),
                    'logs': os.path.join(artifacts_dir, 'Log_Claw.db'),
                    'prefetch': os.path.join(artifacts_dir, 'prefetch_data.db'),
                    'shimcache': os.path.join(artifacts_dir, 'shimcache.db'),
                    'amcache': os.path.join(artifacts_dir, 'amcache.db'),
                    'mft': os.path.join(artifacts_dir, 'mft_claw_analysis.db'),
                    'usn': os.path.join(artifacts_dir, 'USN_journal.db'),
                    'mft_usn_correlated': os.path.join(artifacts_dir, 'mft_usn_correlated_analysis.db')
                }
            }
            
            # Create case configuration
            case_config = {
                'case_name': dir_name,
                'created_date': datetime.datetime.now().isoformat(),
                'paths': self.case_paths,
                'databases': {
                    'registry': os.path.join(self.case_paths['artifacts_dir'], 'registry_data.db'),
                    'lnk': os.path.join(self.case_paths['artifacts_dir'], 'LnkDB.db'),
                    'logs': os.path.join(self.case_paths['artifacts_dir'], 'Log_Claw.db'),
                    'prefetch': os.path.join(self.case_paths['artifacts_dir'], 'prefetch_data.db'),
                    'shimcache': os.path.join(self.case_paths['artifacts_dir'], 'shimcache.db'),
                    'amcache': os.path.join(self.case_paths['artifacts_dir'], 'amcache.db'),
                    'mft': os.path.join(self.case_paths['artifacts_dir'], 'mft_claw_analysis.db'),
                    'usn': os.path.join(self.case_paths['artifacts_dir'], 'USN_journal.db'),
                    'mft_usn_correlated': os.path.join(self.case_paths['artifacts_dir'], 'mft_usn_correlated_analysis.db')
                }
            }
            
            # Save configuration to application directory - FIX HERE
            config_path = os.path.join(config_dir, f"case_{dir_name}.json")
            
            # Create all directories
            created_dirs = []
            try:
                # Create only the directory paths, not the databases dictionary
                for key, dir_path in self.case_paths.items():
                    if key != 'databases' and isinstance(dir_path, str):
                        os.makedirs(dir_path, exist_ok=True)
                        created_dirs.append(dir_path)
                
                # Save case configuration
                with open(config_path, 'w') as config_file:
                    json.dump(case_config, config_file, indent=4)
                    
                # Update UI with case name
                self.label.setText(f"Case: {dir_name}")
                    
                QMessageBox.information(
                    self.main_window,
                    "Case Initialized",
                    f"Case directories created successfully at:\n{self.case_paths['case_root']}"
                )
                
                return self.case_paths
                
            except Exception as e:
                # Clean up on error
                for dir_path in reversed(created_dirs):
                    try:
                        os.rmdir(dir_path)
                    except:
                        pass
                        
                if os.path.exists(config_path):
                    try:
                        os.remove(config_path)
                    except:
                        pass
                        
                QMessageBox.critical(
                    self.main_window,
                    "Error",
                    f"Failed to create case structure:\n{str(e)}"
                )
                self.case_paths = None
                return None
        
        except Exception as e:
            QMessageBox.critical(
                self.main_window,
                "Error",
                f"Failed to create case:\n{str(e)}"
            )
            return None
            
        finally:
            self.Creat_case.setEnabled(True)

    def open_existing_case(self):
        """Compatibility wrapper that delegates to open_case()."""
        return self.open_case()
        
    def show_case_dialog(self):
        """Show a dialog asking the user if they want to create a new case or open an existing one."""
        try:
            # Import the new case dialog component
            from ui.case_dialog import show_case_dialog
            
            # Show the enhanced case dialog
            choice = show_case_dialog(self.main_window)
            
            # Handle user choice
            if choice == 'create':
                self.create_directory()
            elif choice == 'open':
                self.open_case()
            else:  # None (cancelled or closed)
                sys.exit(0)
                
        except ImportError as e:
            print(f"Warning: Could not load enhanced case dialog: {e}")
            # Fallback to original message box implementation
            msg_box = QMessageBox(self.main_window)
            msg_box.setWindowTitle("Crow Eye - Case Management")
            msg_box.setText("No active case found. What would you like to do?")
            
            # Apply cyberpunk style
            msg_box.setStyleSheet(CrowEyeStyles.MESSAGE_BOX_STYLE)
            
            # Add buttons
            create_button = msg_box.addButton("Create New Case", QMessageBox.ActionRole)
            open_button = msg_box.addButton("Open Existing Case", QMessageBox.ActionRole)
            exit_button = msg_box.addButton("Exit", QMessageBox.RejectRole)
            
            msg_box.exec_()
            
            # Handle user choice
            if msg_box.clickedButton() == create_button:
                self.create_directory()
            elif msg_box.clickedButton() == open_button:
                self.open_case()
            else:  # Exit button or dialog closed
                sys.exit(0)

    def show_loading_screen_with_function(self, title, function_to_run, *args, run_in_thread=False, **kwargs):
        """Show enhanced cyberpunk loading screen while running a function"""
        try:
            # Import the loading dialog
            from ui.Loading_dialog import LoadingDialog
            
            # Create and configure the loading dialog with cyberpunk style
            loading_dialog = LoadingDialog(
                title="CROW EYE SYSTEM",
                parent=self.main_window
            )
            
            # Apply the cyberpunk style to the dialog
            loading_dialog.setStyleSheet(CrowEyeStyles.LOADING_DIALOG)
            
            # Apply title style
            title_label = loading_dialog.findChild(QtWidgets.QLabel, "titleLabel")
            if title_label:
                title_label.setStyleSheet(CrowEyeStyles.OVERLAY_TITLE)
            
            # Apply status style
            status_label = loading_dialog.findChild(QtWidgets.QLabel, "statusLabel")
            if status_label:
                status_label.setStyleSheet(CrowEyeStyles.OVERLAY_STATUS)
            
            # Apply progress bar style
            progress_bar = loading_dialog.findChild(QtWidgets.QProgressBar)
            if progress_bar:
                progress_bar.setStyleSheet(CrowEyeStyles.OVERLAY_PROGRESS)
            
            # Apply log text style
            log_text = loading_dialog.findChild(QtWidgets.QTextEdit)
            if log_text:
                log_text.setStyleSheet(CrowEyeStyles.OVERLAY_LOG)
            
            # Show the dialog
            loading_dialog.show()
            QtWidgets.QApplication.processEvents()
            
            # Start log capture
            loading_dialog.start_log_capture()
            
            try:
                # Run the function directly on the main thread
                # This is safer and simpler for GUI operations
                result = function_to_run(*args, **kwargs)
                
                # Show completion with success style
                loading_dialog.show_completion("OPERATION COMPLETED SUCCESSFULLY")
                QtWidgets.QApplication.processEvents()
                
                # Keep dialog open for a moment to show completion
                QtCore.QTimer.singleShot(1500, loading_dialog.close)
                
                # Wait a bit for user to see the completion
                QtCore.QTimer.singleShot(2000, lambda: None)  # Brief pause
                
                return result
                
            except Exception as ex:
                # Show error with error style
                error_msg = f"[Error] Operation failed: {str(ex)}"
                loading_dialog.add_log_message(error_msg)
                QtWidgets.QApplication.processEvents()
                
                # Keep error dialog open longer
                QtCore.QTimer.singleShot(3000, loading_dialog.close)
                print(f"Error in operation: {str(ex)}")
                raise
                
            finally:
                # Always stop log capture
                loading_dialog.stop_log_capture()
                
        except ImportError as e:
            print(f"Warning: Could not load loading dialog: {e}")
            # Fallback to simple progress dialog with cyberpunk style
            progress_dialog = QtWidgets.QProgressDialog(title, "Cancel", 0, 0, self.main_window)
            progress_dialog.setWindowTitle("Crow Eye - Processing")
            progress_dialog.setWindowModality(Qt.WindowModal)
            progress_dialog.setMinimumDuration(0)
            progress_dialog.setCancelButton(None)
            
            # Apply cyberpunk style to progress dialog
            progress_dialog.setStyleSheet("""
                QProgressDialog {
                    background-color: #0B1220;
                    color: #00FFFF;
                    border: 2px solid #00FFFF;
                    border-radius: 5px;
                }
                QLabel {
                    color: #E5E7EB;
                    font-weight: bold;
                }
                QProgressBar {
                    border: 2px solid #00FFFF;
                    border-radius: 5px;
                    background: #1E293B;
                    text-align: center;
                    color: #E5E7EB;
                }
                QProgressBar::chunk {
                    background-color: #00FFFF;
                    width: 20px;
                }
            """)
            
            progress_bar = progress_dialog.findChild(QtWidgets.QProgressBar)
            if progress_bar:
                progress_bar.setTextVisible(False)
                progress_bar.setStyleSheet(CrowEyeStyles.OVERLAY_PROGRESS)
            
            progress_dialog.show()
            QtWidgets.QApplication.processEvents()
            
            try:
                result = function_to_run(*args, **kwargs)
                progress_dialog.setLabelText("Operation completed successfully!")
                QtWidgets.QApplication.processEvents()
                QtCore.QTimer.singleShot(500, progress_dialog.close)
                return result
            except Exception as ex:
                progress_dialog.setLabelText(f"Error: {str(ex)}")
                QtWidgets.QApplication.processEvents()
                QtCore.QTimer.singleShot(2000, progress_dialog.close)
                raise
                
        except Exception as e:
            print(f"Error in loading screen: {str(e)}")
            raise
            

    def run_lnk_analysis(self):
        """Run LNK analysis with loading screen"""
        self.run_analysis_with_loading("Running LNK Analysis...", self.parse_LNK_files)
        
    def run_registry_analysis(self):
        """Run registry analysis with loading screen"""
        self.run_analysis_with_loading("Running Registry Analysis...", self.parse_live_registry)

    
    def run_prefetch_analysis(self):
        """Run prefetch analysis with loading screen"""
        self.run_analysis_with_loading("Running Prefetch Analysis...", self.parse_perfetch)
    
    def run_shimcache_analysis(self):
        """Run ShimCache analysis with loading screen and switch to ShimCache tab"""
        self.run_analysis_with_loading("Running ShimCache Analysis...", self.parse_shimcache)
        # Switch to the ShimCache main tab
        self.main_tab.setCurrentIndex(self.main_tab.indexOf(self.ShimCache_main_tab))
    
    def run_amcache_analysis(self):
        """Run Amcache analysis with loading screen and switch to Amcache tab"""
        self.run_analysis_with_loading("Running Amcache Analysis...", self.parse_amcache)
        # Switch to the Amcache main tab
        self.main_tab.setCurrentIndex(self.main_tab.indexOf(self.Amcache_main_tab))
    
    def run_mft_analysis(self):
        """Run MFT analysis with loading screen and switch to MFT/USN tab"""
        self.run_analysis_with_loading("Running MFT Analysis...", self.parse_mft)
        # Switch to the MFT/USN main tab
        self.main_tab.setCurrentIndex(self.main_tab.indexOf(self.MFT_USN_main_tab))
    
    def run_usn_analysis(self):
        """Run USN Journal analysis with loading screen and switch to MFT/USN tab"""
        self.run_analysis_with_loading("Running USN Journal Analysis...", self.parse_usn)
        # Switch to the MFT/USN main tab
        self.main_tab.setCurrentIndex(self.main_tab.indexOf(self.MFT_USN_main_tab))
    
    def run_logs_analysis(self):
        """Run Windows logs analysis with loading screen"""
        self.run_analysis_with_loading("Running Windows Logs Analysis...", self.parse_logs)
    
    def run_offline_lnk_analysis(self):
        """Run offline LNK analysis with loading screen"""
        self.run_analysis_with_loading("Running Offline LNK Analysis...", self.parse_offline_lnk_files)
    
    def run_offline_registry_analysis(self):
        """Run offline registry analysis with loading screen"""
        self.run_analysis_with_loading("Running Offline Registry Analysis...", self.parse_offline_registry)
    
    def run_offline_prefetch_analysis(self):
        """Run offline prefetch analysis with loading screen"""
        self.run_analysis_with_loading("Running Offline Prefetch Analysis...", self.parse_offline_prefetch)

    def run_mft_usn_correlation(self):
        """Run MFT and USN correlation analysis with loading screen and switch to MFT/USN tab"""
        self.run_analysis_with_loading("Running MFT & USN Correlation...", self.parse_mft_usn_correlation)
        # Switch to the MFT/USN main tab
        self.main_tab.setCurrentIndex(self.main_tab.indexOf(self.MFT_USN_main_tab))
    
    def run_recyclebin_analysis(self):
        """Run RecycleBin analysis with loading screen and switch to RecycleBin tab"""
        self.run_analysis_with_loading("Running Recycle Bin Analysis...", self.parse_recyclebin)
        # Switch to the RecycleBin main tab
        self.main_tab.setCurrentIndex(self.main_tab.indexOf(self.RecycleBin_main_tab))
    
    def run_srum_analysis(self):
        """Run SRUM analysis with loading screen and switch to SRUM tab"""
        self.run_analysis_with_loading("Running SRUM Analysis...", self.parse_srum)
        # Switch to the SRUM main tab
        self.main_tab.setCurrentIndex(self.main_tab.indexOf(self.SRUM_main_tab))
    
    def parse_LNK_files(self):
        """Parse LNK files and Jump Lists"""
        try:
            print("[LNK] Starting LNK and Jump Lists collection...")
            from Artifacts_Collectors.A_CJL_LNK_Claw import A_CJL_LNK_Claw
            
            # Get case directory information
            case_root = None
            artifacts_dir = None
            if hasattr(self, 'case_paths') and self.case_paths:
                case_root = self.case_paths.get('case_root')
                artifacts_dir = self.case_paths.get('artifacts_dir')
            
            # Get the database path
            db_path = self.get_lnk_db_path()
            
            # Run the LNK and Jump List collector with direct parsing enabled
            A_CJL_LNK_Claw(case_path=case_root, offline_mode=False, direct_parse=True)
            
            print("[LNK] LNK and Jump Lists collected successfully")
            
            # Load the data into the UI tables
            self.load_data_from_database_lnkAJL()  # This loads both LNK and AJL tables
            self.load_data_from_database_CJL()     # This loads the CJL table
        except Exception as e:
            print(f"[LNK Error] {str(e)}")
            raise
    
    def parse_live_registry(self):
        """Parse live registry data"""
        try:
            print("[Registry] Starting live registry collection...")
            from Artifacts_Collectors.Regclaw import parse_live_registry
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
            if artifacts_dir:
                db_path = os.path.join(artifacts_dir, 'registry_data.db')
            else:
                db_path = None
            parse_live_registry(case_root=case_root, db_path=db_path)
            print("[Registry] Registry data collected successfully")
            # Load the data into the UI using the correct method
            self.load_registry_data_from_db()
        except Exception as e:
            print(f"[Registry Error] {str(e)}")
            raise
    
    def parse_perfetch(self):
        """Parse prefetch files"""
        try:
            print("[Prefetch] Starting prefetch collection...")
            from Artifacts_Collectors.Prefetch_claw import process_prefetch_files
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            process_prefetch_files(case_path=case_root, offline_mode=False)
            print("[Prefetch] Prefetch data collected successfully")
            # Load the data into the UI using the correct method
            self.load_data_from_Prefetch()
        except Exception as e:
            print(f"[Prefetch Error] {str(e)}")
            raise
    
    def parse_logs(self):
        """Parse Windows event logs"""
        try:
            print("[Logs] Starting Windows event logs collection...")
            from Artifacts_Collectors.WinLog_Claw import main as collect_logs
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            collect_logs(case_path=case_root)
            print("[Logs] Event logs collected successfully")
            # Load the data into the UI using the correct method
            self.load_all_logs()
        except Exception as e:
            print(f"[Logs Error] {str(e)}")
            raise
            
    def parse_shimcache(self):
        """Parse ShimCache data"""
        try:
            print("[ShimCache] Starting ShimCache collection...")
            from Artifacts_Collectors.shimcash_claw import ShimCacheParser
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
            
            # Set the database path based on case directory if available
            if artifacts_dir:
                db_path = os.path.join(artifacts_dir, 'shimcache.db')
            else:
                db_path = 'shimcache.db'
                
            # Initialize and run the ShimCache parser
            parser = ShimCacheParser(db_path)
            parser.run()
            print("[ShimCache] ShimCache data collected successfully")
            
            # Load the data into the UI
            self.load_shimcache_data()
        except Exception as e:
            print(f"[ShimCache Error] {str(e)}")
            import traceback
            traceback.print_exc()
            raise
            
    def parse_amcache(self):
        """Parse Amcache data"""
        try:
            print("[Amcache] Starting Amcache collection...")
            from Artifacts_Collectors.amcacheparser import parse_amcache_hive
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
            
            # Set the database path based on case directory if available
            if artifacts_dir:
                db_path = os.path.join(artifacts_dir, 'amcache.db')
            else:
                db_path = 'amcache.db'
                
            # Run the Amcache parser
            offline_mode = False
            result_db_path = parse_amcache_hive(case_path=case_root, offline_mode=offline_mode, db_path=db_path)
            print("[Amcache] Amcache data collected successfully")
            
            # Update case configuration with the database path
            if result_db_path and hasattr(self, 'case_paths'):
                # Get the current case name
                case_name = os.path.basename(self.case_paths.get('case_root', ''))
                if case_name:
                    # Load the current case configuration
                    config_dir, _ = self.get_app_config_dir()
                    config_path = os.path.join(config_dir, f"case_{case_name}.json")
                    
                    try:
                        with open(config_path, 'r') as config_file:
                            case_config = json.load(config_file)
                            
                        # Update the databases entry
                        if 'databases' not in case_config:
                            case_config['databases'] = {}
                        case_config['databases']['amcache'] = result_db_path
                        
                        # Save the updated configuration
                        with open(config_path, 'w') as config_file:
                            json.dump(case_config, config_file, indent=4)
                            
                        # Update last case file
                        self.save_last_case(case_config)
                        print(f"[Amcache] Updated case configuration with database path: {result_db_path}")
                    except Exception as e:
                        print(f"[Amcache Warning] Failed to update case configuration: {str(e)}")
                        # Continue execution even if config update fails
            
            # Load the data into the UI
            self.load_amcache_data()
        except Exception as e:
            print(f"[Amcache Error] {str(e)}")
            import traceback
            traceback.print_exc()
            raise
    
    def parse_mft(self):
        """Parse MFT data"""
        try:
            print("[MFT] Starting MFT collection...")
            import sys
            import os
            # Add the MFT and USN journal directory to Python path
            mft_usn_path = os.path.join(os.path.dirname(__file__), 'Artifacts_Collectors', 'MFT and USN journal')
            if mft_usn_path not in sys.path:
                sys.path.insert(0, mft_usn_path)
            from MFT_Claw import main as mft_claw_main
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
            
            # Set the database path based on case directory if available
            if artifacts_dir:
                db_path = os.path.join(artifacts_dir, 'mft_claw_analysis.db')
            else:
                db_path = 'mft_claw_analysis.db'
                
            # Run the MFT parser
            # Save current directory and change to case directory for direct function call
            original_cwd = os.getcwd()
            try:
                if case_root:
                    os.chdir(case_root)
                # Run MFT parser directly as a function
                result = mft_claw_main()
                if result == 0:
                    print("[MFT] MFT data collected successfully")
                else:
                    print("[MFT Warning] MFT parser may have had issues but database might be created")
            finally:
                os.chdir(original_cwd)
            
            # Load the data into the UI
            self.load_mft_data()
        except Exception as e:
            print(f"[MFT Error] {str(e)}")
            import traceback
            traceback.print_exc()
            raise
    
    def parse_usn(self):
        """Parse USN Journal data"""
        try:
            print("[USN] Starting USN Journal collection...")
            import sys
            import os
            # Add the MFT and USN journal directory to Python path
            mft_usn_path = os.path.join(os.path.dirname(__file__), 'Artifacts_Collectors', 'MFT and USN journal')
            if mft_usn_path not in sys.path:
                sys.path.insert(0, mft_usn_path)
            from USN_Claw import main as usn_claw_main
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
            
            # Set the database path based on case directory if available
            if artifacts_dir:
                db_path = os.path.join(artifacts_dir, 'USN_journal.db')
            else:
                db_path = 'USN_journal.db'
                
            # Run the USN Journal parser
            # Save current directory and change to case directory for direct function call
            original_cwd = os.getcwd()
            try:
                if case_root:
                    os.chdir(case_root)
                # Run USN parser directly as a function
                result = usn_claw_main()
                if result == 0:
                    print("[USN] USN Journal data collected successfully")
                else:
                    print("[USN Warning] USN parser may have failed due to privilege requirements or missing dependencies")
            finally:
                os.chdir(original_cwd)
            
            # Load the data into the UI
            self.load_usn_data()
        except Exception as e:
            print(f"[USN Error] {str(e)}")
            import traceback
            traceback.print_exc()
            raise

    def parse_mft_usn_correlation(self):
        """Parse and correlate MFT and USN Journal data"""
        try:
            print("[MFT-USN] Starting MFT and USN Journal correlation...")
            
            # Get case directory information
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
            
            # Import and run the MFT-USN correlator
            import sys
            import os
            # Add the MFT and USN journal directory to Python path
            mft_usn_path = os.path.join(os.path.dirname(__file__), 'Artifacts_Collectors', 'MFT and USN journal')
            if mft_usn_path not in sys.path:
                sys.path.insert(0, mft_usn_path)
            from mft_usn_correlator import MFTUSNCorrelator
            
            # Initialize the correlator with case directory
            correlator = MFTUSNCorrelator(case_directory=case_root)
            
            # Run the complete correlation analysis
            correlator.run_correlation_for_case()
            
            print("[MFT-USN] MFT and USN Journal correlation completed successfully")
            
            # Load the correlated data into the UI
            self.load_mft_data()
            self.load_usn_data()
            self.load_correlated_data()
            
        except Exception as e:
            print(f"[MFT-USN Error] {str(e)}")
            import traceback
            traceback.print_exc()
            raise
    
    def parse_recyclebin(self):
        """Parse RecycleBin data with loading dialog"""
        def _parse_recyclebin_internal():
            try:
                print("[RecycleBin] Starting RecycleBin collection...")
                from Artifacts_Collectors.recyclebin_claw import parse_recycle_bin
                case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                
                # Run the RecycleBin parser with case path
                if case_root:
                    # For case-based analysis, pass the case root path
                    db_path = parse_recycle_bin(case_path=case_root)
                else:
                    # For live system analysis
                    db_path = parse_recycle_bin()
                    
                print(f"[RecycleBin] RecycleBin data collected successfully, database: {db_path}")
                
                # Load the data into the UI
                self.load_recyclebin_data()
            except Exception as e:
                print(f"[RecycleBin Error] {str(e)}")
                import traceback
                traceback.print_exc()
                raise
        
        # Use the loading dialog system
        self.show_loading_screen_with_function(
            "Collecting RecycleBin Data",
            _parse_recyclebin_internal
        )
    
    def parse_srum(self):
        """Parse SRUM data with loading dialog"""
        def _parse_srum_internal():
            try:
                print("[SRUM] Starting SRUM collection...")
                from Artifacts_Collectors.SRUM_Claw import parse_srum_data
                artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
                
                # Run the SRUM parser with artifacts directory
                if artifacts_dir:
                    result = parse_srum_data(case_artifacts_dir=artifacts_dir)
                    if result.get('success'):
                        print(f"[SRUM] SRUM data collected successfully: {result.get('statistics', {})}")
                    else:
                        print(f"[SRUM] SRUM parsing completed with warnings: {result.get('errors', [])}")
                else:
                    print("[SRUM] No artifacts directory available, skipping SRUM collection")
                    raise Exception("No artifacts directory available for SRUM parsing")
                
                # Load the data into the UI
                self.load_srum_data()
            except Exception as e:
                print(f"[SRUM Error] {str(e)}")
                import traceback
                traceback.print_exc()
                raise
        
        # Use the loading dialog system
        self.show_loading_screen_with_function(
            "Collecting SRUM Data",
            _parse_srum_internal
        )
    
    def load_recyclebin_data(self):
        """Load RecycleBin data from the recyclebin database"""
        try:
            # Get the database path from case configuration
            if not hasattr(self, 'case_paths') or not self.case_paths:
                return
                
            case_root = self.case_paths.get('case_root')
            if not case_root:
                return
                
            # RecycleBin database is created in case_root/Target_Artifacts/
            artifacts_dir = os.path.join(case_root, 'Target_Artifacts')
            db_path = os.path.join(artifacts_dir, 'recyclebin_analysis.db')
            
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[RecycleBin] Database not found at: {db_path}")
                print(f"[RecycleBin] Please run RecycleBin analysis first to create the database")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if recycle_bin_entries table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='recycle_bin_entries'")
            if not cursor.fetchone():
                print(f"[RecycleBin] recycle_bin_entries table not found in database: {db_path}")
                conn.close()
                return
                
            cursor.execute("SELECT * FROM recycle_bin_entries")
            rows = cursor.fetchall()
            
            if hasattr(self, 'RecycleBin_main_table'):
                self.RecycleBin_main_table.setRowCount(0)
                for row in rows:
                    row_index = self.RecycleBin_main_table.rowCount()
                    self.RecycleBin_main_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.RecycleBin_main_table.setItem(row_index, col_index, item)
                print(f"[RecycleBin] Successfully loaded {len(rows)} records from {db_path}")
                # Resize columns to fit content
                self.RecycleBin_main_table.resizeColumnsToContents()
                # Apply styles
                self.apply_table_styles(self.RecycleBin_main_table)
            conn.close()
        except Exception as e:
            print(f"[RecycleBin] Error loading data: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def load_srum_data(self):
        """Load all SRUM data from the SRUM database"""
        try:
            # Get the database path from case configuration
            if not hasattr(self, 'case_paths') or not self.case_paths:
                print("[SRUM] No case paths available")
                return
                
            artifacts_dir = self.case_paths.get('artifacts_dir')
            if not artifacts_dir:
                print("[SRUM] No artifacts directory available")
                return
                
            db_path = os.path.join(artifacts_dir, 'srum_data.db')
            
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[SRUM] Database not found at: {db_path}")
                print(f"[SRUM] Please run SRUM analysis first to create the database")
                return
            
            print(f"[SRUM] Loading SRUM data from: {db_path}")
            
            # Load each SRUM table
            self.load_srum_application_usage(db_path)
            self.load_srum_network_connectivity(db_path)
            self.load_srum_network_data_usage(db_path)
            self.load_srum_energy_usage(db_path)
            
            print("[SRUM] All SRUM data loaded successfully")
        except Exception as e:
            print(f"[SRUM] Error loading SRUM data: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def load_srum_application_usage(self, db_path):
        """Load SRUM Application Usage data"""
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='srum_application_usage'")
            if not cursor.fetchone():
                print("[SRUM] srum_application_usage table not found")
                conn.close()
                return
            
            cursor.execute("SELECT * FROM srum_application_usage")
            rows = cursor.fetchall()
            
            if hasattr(self, 'SRUM_application_usage_table'):
                # Disable updates during bulk loading for performance
                self.SRUM_application_usage_table.setUpdatesEnabled(False)
                self.SRUM_application_usage_table.setSortingEnabled(False)
                
                # Set row count once instead of inserting rows one by one
                self.SRUM_application_usage_table.setRowCount(len(rows))
                
                # Populate all cells
                for row_index, row in enumerate(rows):
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                        self.SRUM_application_usage_table.setItem(row_index, col_index, item)
                
                # Re-enable updates and sorting
                self.SRUM_application_usage_table.setUpdatesEnabled(True)
                self.SRUM_application_usage_table.setSortingEnabled(True)
                
                print(f"[SRUM] Loaded {len(rows)} application usage records")
                self.apply_table_styles(self.SRUM_application_usage_table)
            conn.close()
        except Exception as e:
            print(f"[SRUM] Error loading application usage: {str(e)}")
    
    def load_srum_network_connectivity(self, db_path):
        """Load SRUM Network Connectivity data"""
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='srum_network_connectivity'")
            if not cursor.fetchone():
                print("[SRUM] srum_network_connectivity table not found")
                conn.close()
                return
            
            cursor.execute("SELECT * FROM srum_network_connectivity")
            rows = cursor.fetchall()
            
            if hasattr(self, 'SRUM_network_connectivity_table'):
                # Disable updates during bulk loading for performance
                self.SRUM_network_connectivity_table.setUpdatesEnabled(False)
                self.SRUM_network_connectivity_table.setSortingEnabled(False)
                
                # Set row count once instead of inserting rows one by one
                self.SRUM_network_connectivity_table.setRowCount(len(rows))
                
                # Populate all cells
                for row_index, row in enumerate(rows):
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                        self.SRUM_network_connectivity_table.setItem(row_index, col_index, item)
                
                # Re-enable updates and sorting
                self.SRUM_network_connectivity_table.setUpdatesEnabled(True)
                self.SRUM_network_connectivity_table.setSortingEnabled(True)
                
                print(f"[SRUM] Loaded {len(rows)} network connectivity records")
                self.apply_table_styles(self.SRUM_network_connectivity_table)
            conn.close()
        except Exception as e:
            print(f"[SRUM] Error loading network connectivity: {str(e)}")
    
    def load_srum_network_data_usage(self, db_path):
        """Load SRUM Network Data Usage data"""
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='srum_network_data_usage'")
            if not cursor.fetchone():
                print("[SRUM] srum_network_data_usage table not found")
                conn.close()
                return
            
            cursor.execute("SELECT * FROM srum_network_data_usage")
            rows = cursor.fetchall()
            
            if hasattr(self, 'SRUM_network_data_table'):
                # Disable updates during bulk loading for performance
                self.SRUM_network_data_table.setUpdatesEnabled(False)
                self.SRUM_network_data_table.setSortingEnabled(False)
                
                # Set row count once instead of inserting rows one by one
                self.SRUM_network_data_table.setRowCount(len(rows))
                
                # Populate all cells
                for row_index, row in enumerate(rows):
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                        self.SRUM_network_data_table.setItem(row_index, col_index, item)
                
                # Re-enable updates and sorting
                self.SRUM_network_data_table.setUpdatesEnabled(True)
                self.SRUM_network_data_table.setSortingEnabled(True)
                
                print(f"[SRUM] Loaded {len(rows)} network data usage records")
                self.apply_table_styles(self.SRUM_network_data_table)
            conn.close()
        except Exception as e:
            print(f"[SRUM] Error loading network data usage: {str(e)}")
    
    def load_srum_energy_usage(self, db_path):
        """Load SRUM Energy Usage data"""
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='srum_energy_usage'")
            if not cursor.fetchone():
                print("[SRUM] srum_energy_usage table not found")
                conn.close()
                return
            
            cursor.execute("SELECT * FROM srum_energy_usage")
            rows = cursor.fetchall()
            
            if hasattr(self, 'SRUM_energy_usage_table'):
                # Disable updates during bulk loading for performance
                self.SRUM_energy_usage_table.setUpdatesEnabled(False)
                self.SRUM_energy_usage_table.setSortingEnabled(False)
                
                # Set row count once instead of inserting rows one by one
                self.SRUM_energy_usage_table.setRowCount(len(rows))
                
                # Populate all cells
                for row_index, row in enumerate(rows):
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                        self.SRUM_energy_usage_table.setItem(row_index, col_index, item)
                
                # Re-enable updates and sorting
                self.SRUM_energy_usage_table.setUpdatesEnabled(True)
                self.SRUM_energy_usage_table.setSortingEnabled(True)
                
                print(f"[SRUM] Loaded {len(rows)} energy usage records")
                self.apply_table_styles(self.SRUM_energy_usage_table)
            conn.close()
        except Exception as e:
            print(f"[SRUM] Error loading energy usage: {str(e)}")
    
    def parse_offline_lnk_files(self):
        """Parse offline LNK files and Jump Lists using the offline module"""
        try:
            print("[Offline LNK] Starting offline LNK and Jump Lists analysis...")
            from Artifacts_Collectors.A_CJL_LNK_Claw import A_CJL_LNK_Claw
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            
            # Call the offline LNK analysis function with case_root and direct parsing
            A_CJL_LNK_Claw(case_path=case_root, offline_mode=True, direct_parse=True)
            print("[Offline LNK] Offline LNK and Jump Lists analyzed successfully")
            
            # Load the data into the UI
            self.load_data_from_database_lnkAJL()
            self.load_data_from_database_CJL()
        except Exception as e:
            print(f"[Offline LNK Error] {str(e)}")
            raise
    
    def parse_offline_prefetch(self):
        """Parse offline prefetch files"""
        try:
            print("[Offline Prefetch] Starting offline prefetch analysis...")
            from Artifacts_Collectors.Prefetch_claw import process_prefetch_files
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            process_prefetch_files(case_path=case_root, offline_mode=True)
            print("[Offline Prefetch] Offline prefetch analyzed successfully")
            # Load the data into the UI using the correct method
            self.load_data_from_Prefetch()
        except Exception as e:
            print(f"[Offline Prefetch Error] {str(e)}")
            raise
    
    def parse_offline_registry(self):
        """Parse offline registry files using the offline registry module"""
        try:
            print("[Offline Registry] Starting offline registry analysis...")
            from Artifacts_Collectors.offline_RegClaw import reg_Claw
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            
            # Call the offline registry analysis function
            reg_Claw(case_root=case_root, offline_mode=True)
            print("[Offline Registry] Offline registry analyzed successfully")
            
            # Load the data into the UI using the correct method
            self.load_registry_data_from_db()
        except Exception as e:
            print(f"[Offline Registry Error] {str(e)}")
            raise

    def parse_all_live_artifacts(self):
        """Enhanced live artifact collection with loading dialog"""
        try:
            # Import the loading dialog
            from ui.Loading_dialog import LoadingDialog
            
            # Create enhanced loading dialog
            dialog = LoadingDialog(
                title="CROW EYE SYSTEM",
                parent=self.main_window
            )
            
            # Define the collection steps
            steps = [
                "Initializing artifact collection",
                "Collecting LNK files and Jump Lists",
                "Collecting Registry data", 
                "Collecting Prefetch files",
                "Collecting Event Logs",
                "Collecting ShimCache data",
                "Collecting Amcache data",
                "Collecting RecycleBin data",
                "Collecting SRUM data",
                "Collecting MFT & USN Journal data",
                "Loading data into GUI"
            ]
            
            dialog.set_steps(steps)
            dialog.show()
            dialog.start_log_capture()
            
            try:
                print("[Open Case] Starting full live analysis...")
                
                # Step 1: Initialize
                dialog.update_step(0, "⚙️ INITIALIZING ARTIFACT COLLECTION")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                print("[LNK] Collecting LNK and Jump Lists...")
                
                # Step 2: LNK and Jump Lists
                dialog.update_step(1, "🔗 COLLECTING LNK FILES AND JUMP LISTS")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    # Import and call the LNK collection function with direct parsing
                    from Artifacts_Collectors.A_CJL_LNK_Claw import A_CJL_LNK_Claw
                    case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                    A_CJL_LNK_Claw(case_path=case_root, offline_mode=False, direct_parse=True)
                    print("[LNK] LNK and Jump Lists collected successfully")
                except Exception as e:
                    print(f"[LNK Error] {str(e)}")
                
                # Step 3: Registry data
                dialog.update_step(2, "🔧 COLLECTING REGISTRY DATA")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    print("[Registry] Collecting live registry data...")
                    # Import and call the registry collection function
                    from Artifacts_Collectors.Regclaw import parse_live_registry
                    case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                    artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
                    if artifacts_dir:
                        db_path = os.path.join(artifacts_dir, 'registry_data.db')
                    else:
                        db_path = None
                    parse_live_registry(case_root=case_root, db_path=db_path)
                    print("[Registry] Registry data collected successfully")
                except Exception as e:
                    print(f"[Registry Error] {str(e)}")
                
                # Step 4: Prefetch files
                dialog.update_step(3, "⚡ COLLECTING PREFETCH FILES")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    print("[Prefetch] Collecting prefetch data...")
                    # Import and call the prefetch collection function
                    from Artifacts_Collectors.Prefetch_claw import prefetch_claw
                    case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                    prefetch_claw(case_path=case_root, offline_mode=False)
                    print("[Prefetch] Prefetch data collected successfully")
                except Exception as e:
                    print(f"[Prefetch Error] {str(e)}")
                
                # Step 5: Event logs
                dialog.update_step(4, "📊 COLLECTING EVENT LOGS")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    print("[Logs] Collecting Windows event logs...")
                    # Import and call the logs collection function
                    from Artifacts_Collectors.WinLog_Claw import main as collect_logs
                    case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                    collect_logs(case_path=case_root)
                    print("[Logs] Event Logs collected successfully")
                except Exception as e:
                    print(f"[Logs Error] {str(e)}")
                
                # Step 6: ShimCache data
                dialog.update_step(5, "🔍 COLLECTING SHIMCACHE DATA")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    print("[ShimCache] Collecting ShimCache data...")
                    # Import and call the ShimCache collection function
                    from Artifacts_Collectors.shimcash_claw import ShimCacheParser
                    case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                    artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
                    if artifacts_dir:
                        db_path = os.path.join(artifacts_dir, 'shimcache.db')
                    else:
                        db_path = 'shimcache.db'
                    parser = ShimCacheParser(db_path)
                    parser.run()
                    print("[ShimCache] ShimCache data collected successfully")
                except Exception as e:
                    print(f"[ShimCache Error] {str(e)}")
                
                # Step 7: Amcache data
                dialog.update_step(6, "🔍 COLLECTING AMCACHE DATA")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    print("[Amcache] Collecting Amcache data...")
                    # Import and call the Amcache collection function
                    from Artifacts_Collectors.amcacheparser import parse_amcache_hive
                    case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                    artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
                    if artifacts_dir:
                        db_path = os.path.join(artifacts_dir, 'amcache.db')
                    else:
                        db_path = 'amcache.db'
                    # Run the Amcache parser
                    offline_mode = False
                    parse_amcache_hive(case_path=case_root, offline_mode=offline_mode, db_path=db_path)
                    print("[Amcache] Amcache data collected successfully")
                except Exception as e:
                    print(f"[Amcache Error] {str(e)}")
                
                # Step 8: RecycleBin data
                dialog.update_step(7, "🗑️ COLLECTING RECYCLEBIN DATA")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    print("[RecycleBin] Collecting RecycleBin data...")
                    # Import and call the RecycleBin collection function
                    from Artifacts_Collectors.recyclebin_claw import parse_recycle_bin
                    case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                    
                    # Run the RecycleBin parser with case path
                    if case_root:
                        # For case-based analysis, pass the case root path
                        db_path = parse_recycle_bin(case_path=case_root)
                    else:
                        # For live system analysis
                        db_path = parse_recycle_bin()
                        
                    print(f"[RecycleBin] RecycleBin data collected successfully, database: {db_path}")
                except Exception as e:
                    print(f"[RecycleBin Error] {str(e)}")
                
                # Step 9: SRUM data
                dialog.update_step(8, "� COLLECTINNG SRUM DATA")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    print("[SRUM] Collecting SRUM data...")
                    # Import and call the SRUM collection function
                    from Artifacts_Collectors.SRUM_Claw import parse_srum_data
                    artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
                    
                    # Run the SRUM parser with artifacts directory
                    if artifacts_dir:
                        result = parse_srum_data(case_artifacts_dir=artifacts_dir)
                        if result.get('success'):
                            print(f"[SRUM] SRUM data collected successfully: {result.get('statistics', {})}")
                        else:
                            print(f"[SRUM] SRUM parsing completed with warnings: {result.get('errors', [])}")
                    else:
                        print("[SRUM] No artifacts directory available, skipping SRUM collection")
                except Exception as e:
                    print(f"[SRUM Error] {str(e)}")
                
                # Step 10: MFT and USN Journal data
                dialog.update_step(9, "🗂️ COLLECTING MFT & USN JOURNAL DATA")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    print("[MFT-USN] Collecting MFT and USN Journal data...")
                    # Import and call the MFT-USN correlation function
                    self.parse_mft_usn_correlation()
                    print("[MFT-USN] MFT and USN Journal data collected successfully")
                except Exception as e:
                    print(f"[MFT-USN Error] {str(e)}")
                
                print("[Open Case] Artifact collection finished. Loading data into UI...")
                
                # Step 11: Load data into GUI
                dialog.update_step(10, "📊 LOADING DATA INTO GUI")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    # Load all data including SRUM
                    self.load_all_data_internal()
                    print("[GUI] All data loaded successfully")
                except Exception as e:
                    print(f"[GUI Error] Failed to load data into UI: {str(e)}")
                
                # Show completion
                dialog.show_completion("ALL ARTIFACTS COLLECTED SUCCESSFULLY")
                print("[Open Case] Full live analysis and data loading completed.")
                print("\033[92m[Live Artifacts] All live artifacts have been collected and loaded successfully\033[0m")
                
                # Keep dialog open briefly
                QtCore.QTimer.singleShot(2500, dialog.close)
                
                # Show success message
                def show_success():
                    QtWidgets.QMessageBox.information(
                        self.main_window,
                        "Live Artifacts Collection",
                        "All live artifacts have been collected and loaded successfully."
                    )
                
                QtCore.QTimer.singleShot(3000, show_success)
                
            except Exception as e:
                error_msg = f"Artifact collection failed: {str(e)}"
                dialog.add_log_message(f"[Error] {error_msg}")
                print(f"[Error] {error_msg}")
                
                # Keep error dialog open longer
                QtCore.QTimer.singleShot(4000, dialog.close)
                
                # Show error message
                def show_error():
                    QtWidgets.QMessageBox.critical(
                        self.main_window,
                        "Live Artifacts Collection",
                        f"Failed to collect all artifacts: {str(e)}"
                    )
                
                QtCore.QTimer.singleShot(4500, show_error)
                raise
                
            finally:
                dialog.stop_log_capture()
                
        except ImportError:
            print("Warning: Could not load loading dialog, using fallback")
            # Fallback to original implementation
            print("[Open Case] Starting full live analysis...")
            
            # Step 1: Collect all artifacts (without loading data into UI)
            try:
                print("[LNK] Collecting LNK and Jump Lists...")
                from Artifacts_Collectors.A_CJL_LNK_Claw import A_CJL_LNK_Claw
                case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                A_CJL_LNK_Claw(case_path=case_root, offline_mode=False, direct_parse=True)
            except Exception as e:
                print(f"[LNK Error] {str(e)}")
            try:
                print("[Registry] Collecting live registry data...")
                # Import and call the registry collection function
                from Artifacts_Collectors.Regclaw import parse_live_registry
                case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
                if artifacts_dir:
                    db_path = os.path.join(artifacts_dir, 'registry_data.db')
                else:
                    db_path = None
                parse_live_registry(case_root=case_root, db_path=db_path)
            except Exception as e:
                print(f"[Registry Error] {str(e)}")
            try:
                print("[Prefetch] Collecting prefetch data...")
                from Artifacts_Collectors.Prefetch_claw import process_prefetch_files
                case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                process_prefetch_files(case_path=case_root, offline_mode=False)
            except Exception as e:
                print(f"[Prefetch Error] {str(e)}")
            try:
                print("[Logs] Collecting Windows event logs...")
                from Artifacts_Collectors.WinLog_Claw import main as collect_logs
                case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                collect_logs(case_path=case_root)
            except Exception as e:
                print(f"[Logs Error] {str(e)}")
            try:
                print("[ShimCache] Collecting ShimCache data...")
                from Artifacts_Collectors.shimcash_claw import ShimCacheParser
                case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
                if artifacts_dir:
                    db_path = os.path.join(artifacts_dir, 'shimcache.db')
                else:
                    db_path = 'shimcache.db'
                parser = ShimCacheParser(db_path)
                parser.run()
                print("[ShimCache] ShimCache data collected successfully")
            except Exception as e:
                print(f"[ShimCache Error] {str(e)}")
            try:
                print("[SRUM] Collecting SRUM data...")
                from Artifacts_Collectors.SRUM_Claw import parse_srum_data
                artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
                if artifacts_dir:
                    result = parse_srum_data(case_artifacts_dir=artifacts_dir)
                    if result.get('success'):
                        print(f"[SRUM] SRUM data collected successfully: {result.get('statistics', {})}")
                    else:
                        print(f"[SRUM] SRUM parsing completed with warnings: {result.get('errors', [])}")
                else:
                    print("[SRUM] No artifacts directory available, skipping SRUM collection")
            except Exception as e:
                print(f"[SRUM Error] {str(e)}")
            try:
                print("[MFT-USN] Collecting MFT and USN Journal data...")
                self.parse_mft_usn_correlation()
                print("[MFT-USN] MFT and USN Journal data collected successfully")
            except Exception as e:
                print(f"[MFT-USN Error] {str(e)}")
            
            print("[Open Case] Artifact collection finished. Loading data into UI...")
            
            # Step 2: Load all collected data into UI tables
            try:
                self.load_all_data_internal()
            except Exception as e:
                print(f"[Open Case Error] Failed to load data into UI: {str(e)}")
            
            print("[Open Case] Full live analysis and data loading completed.")
    
    def load_all_data(self, loading_dialog=None):
        """Load all data with enhanced loading dialog"""
        try:
            # Import the loading dialog
            from ui.Loading_dialog import LoadingDialog
            
            # Create enhanced loading dialog
            dialog = LoadingDialog(
                title="CROW EYE SYSTEM",
                parent=self.main_window
            )
            
            # Define the steps
            steps = [
                "Loading LNK and Jump List data",
                "Loading Custom Jump Lists", 
                "Loading Registry data",
                "Loading File Activity data",
                "Loading Prefetch data",
                "Loading Event Logs",
                "Loading ShimCache data",
                "Loading Registry Database",
                "Loading Amcache data",
                "Loading RecycleBin data",
                "Loading SRUM data",
                "Loading MFT data",
                "Loading USN Journal data",
                "Loading Correlated MFT-USN data"
            ]
            
            dialog.set_steps(steps)
            dialog.show()
            dialog.start_log_capture()
            
            try:
                # Step 1: Loading LNK data
                dialog.update_step(0, "🔗 LOADING LNK AND JUMP LIST DATA")
                self.load_data_from_database_lnkAJL()
                
                # Step 2: Loading Custom Jump Lists
                dialog.update_step(1, "📋 LOADING CUSTOM JUMP LISTS")
                self.load_data_from_database_CJL()
                
                # Step 3: Loading Registry data
                dialog.update_step(2, "🔧 LOADING REGISTRY DATA")
                self.load_allReg_data()
                
                # Step 4: Loading File Activity data
                dialog.update_step(3, "📁 LOADING FILE ACTIVITY DATA")
                print("[File Activity] Starting to load File Activity Data...")
                self.load_files_activity()
                print("[File Activity] Completed loading File Activity Data")
                
                # Step 5: Loading Prefetch data
                dialog.update_step(4, "⚡ LOADING PREFETCH DATA")
                print("[Prefetch] Starting to load Prefetch Data...")
                self.load_data_from_Prefetch()
                print("[Prefetch] Completed loading Prefetch Data")
                
                # Step 6: Loading Event Logs
                dialog.update_step(5, "📊 LOADING EVENT LOGS")
                print("[Logs] Starting to load Event Logs...")
                self.load_all_logs()
                print("[Logs] Completed loading Event Logs")
                
                # Step 7: Loading ShimCache data
                dialog.update_step(6, "🔍 LOADING SHIMCACHE DATA")
                print("[ShimCache] Starting to load ShimCache Data...")
                self.load_shimcache_data()
                print("[ShimCache] Completed loading ShimCache Data")
                
                # Step 8: Loading Registry Database
                dialog.update_step(7, "💾 LOADING REGISTRY DATABASE")
                print("[Registry] Starting to load Registry Database...")
                self.load_registry_data_from_db()
                print("[Registry] Completed loading Registry Database")
                
                # Step 9: Loading Amcache data
                dialog.update_step(8, "📦 LOADING AMCACHE DATA")
                print("[Amcache] Starting to load Amcache Data...")
                self.load_amcache_data()
                print("[Amcache] Completed loading Amcache Data")
                
                # Step 10: Loading RecycleBin data
                dialog.update_step(9, "🗑️ LOADING RECYCLEBIN DATA")
                print("[RecycleBin] Starting to load RecycleBin Data...")
                self.load_recyclebin_data()
                print("[RecycleBin] Completed loading RecycleBin Data")
                
                # Step 11: Loading SRUM data
                dialog.update_step(10, "� LLOADING SRUM DATA")
                print("[SRUM] Starting to load SRUM Data...")
                self.load_srum_data()
                print("[SRUM] Completed loading SRUM Data")
                
                # Step 12: Loading MFT data
                dialog.update_step(11, "🗂️ LOADING MFT DATA")
                print("[MFT] Starting to load MFT Data...")
                self.load_mft_data(dialog.add_log_message)
                print("[MFT] Completed loading MFT Data")
                
                # Step 13: Loading USN data
                dialog.update_step(12, "📝 LOADING USN JOURNAL DATA")
                print("[USN] Starting to load USN Journal Data...")
                self.load_usn_data(dialog.add_log_message)
                print("[USN] Completed loading USN Journal Data")
                
                # Step 14: Loading Correlated data
                dialog.update_step(13, "🔗 LOADING CORRELATED MFT-USN DATA")
                print("[Correlated] Starting to load Correlated MFT-USN Data...")
                self.load_correlated_data(dialog.add_log_message)
                print("[Correlated] Completed loading Correlated MFT-USN Data")
                
                # Show completion
                dialog.show_completion("ALL DATA LOADED SUCCESSFULLY")
                print("\033[92m\nData has been loaded into the GUI Successfully\033[0m")
                
                # Keep dialog open briefly to show completion
                QtCore.QTimer.singleShot(2000, dialog.close)
                
            except Exception as e:
                error_msg = f"Error loading data: {str(e)}"
                dialog.add_log_message(f"[Error] {error_msg}")
                print(f"[Error] {error_msg}")
                QtWidgets.QApplication.processEvents()
                
                # Keep error dialog open longer
                QtCore.QTimer.singleShot(4000, dialog.close)
                raise
                
            finally:
                dialog.stop_log_capture()
                
        except ImportError:
            print("Warning: Could not load loading dialog, using fallback")
            # Fallback to existing implementation
            if loading_dialog:
                self.load_all_data_with_progress(loading_dialog)
            else:
                self.run_analysis_with_loading("Loading All Data...", self.load_all_data_internal, run_in_thread=True)
    
    def load_all_data_internal(self):
        """Internal function to load all data (called by the loading screen)"""
        try:
            self.load_data_from_database_lnkAJL()
        except Exception as e:
            print(f"[LNK Error] Couldn't load JumpLists: {str(e)}")

        try:
            self.load_data_from_database_CJL()
        except Exception as e:
            print(f"[CustomJL Error] Couldn't load Custom JumpLists: {str(e)}")

        try:
            self.load_allReg_data()
        except Exception as e:
            print(f"[Registry Error] Couldn't load registry data: {str(e)}")

        try:
            self.load_files_activity()
        except Exception as e:
            print(f"[File Activity Error] Couldn't load file history: {str(e)}")

        try:
            self.load_all_logs()
        except Exception as e:
            print(f"[Logs Error] Couldn't load event logs: {str(e)}")

        try:
            self.load_data_from_Prefetch()
        except Exception as e:
            print(f"[Prefetch Error] Couldn't load prefetch data: {str(e)}")
            
        try:
            self.load_shimcache_data()
        except Exception as e:
            print(f"[ShimCache Error] Couldn't load ShimCache data: {str(e)}")
        try:
            self.load_amcache_data()
        except Exception as e:
            print(f"[Amcache Error] Couldn't load Amcache data: {str(e)}")
        
        try:
            self.load_recyclebin_data()
        except Exception as e:
            print(f"[RecycleBin Error] Couldn't load RecycleBin data: {str(e)}")
        
        try:
            self.load_srum_data()
        except Exception as e:
            print(f"[SRUM Error] Couldn't load SRUM data: {str(e)}")
            
        try:
            self.load_registry_data_from_db()
        except Exception as e:
            print(f"[Registry Error] Couldn't load registry data: {str(e)}")
        
        try:
            self.load_mft_data()
        except Exception as e:
            print(f"[MFT Error] Couldn't load MFT data: {str(e)}")
        
        try:
            self.load_usn_data()
        except Exception as e:
            print(f"[USN Error] Couldn't load USN data: {str(e)}")
        
        try:
            self.load_correlated_data()
        except Exception as e:
            print(f"[Correlated Error] Couldn't load correlated MFT-USN data: {str(e)}")
        
        print("\033[92m\nData has been loaded into the GUI Successfully\033[0m")

    def load_all_data_with_progress(self, loading_dialog):
        """Load all data with progress updates using the enhanced dialog"""
        steps = [
            "Loading LNK and Jump List data",
            "Loading Custom Jump Lists", 
            "Loading Registry data",
            "Loading Prefetch data",
            "Loading Event Logs",
            "Loading ShimCache data",
            "Loading Amcache data",
            "Loading RecycleBin data"
        ]
        
        try:
            # Update step 1: Loading LNK data
            loading_dialog.update_step(0, "🔄 Loading LNK and Jump List data...")
            self.load_data_from_database_lnkAJL()
            
            # Update step 2: Loading Custom Jump Lists
            loading_dialog.update_step(1, "🔄 Loading Custom Jump Lists...")
            self.load_data_from_database_CJL()
            
            # Update step 3: Loading Registry data
            loading_dialog.update_step(2, "🔄 Loading Registry data...")
            self.load_allReg_data()
            
            # Update step 4: Loading Prefetch data
            loading_dialog.update_step(3, "🔄 Loading Prefetch data...")
            print("[File Activity] Starting to load File Activity Data...")
            self.load_files_activity()
            print("[File Activity] Completed loading File Activity Data")
            
            # Load Event Logs
            loading_dialog.status_label.setText("Loading Event Logs...")
            QApplication.processEvents()
            print("[Logs] Starting to load Event Logs...")
            self.load_all_logs()
            print("[Logs] Completed loading Event Logs")
            
            # Load Prefetch Data
            loading_dialog.status_label.setText("Loading Prefetch Data...")
            QApplication.processEvents()
            print("[Prefetch] Starting to load Prefetch Data...")
            self.load_data_from_Prefetch()
            print("[Prefetch] Completed loading Prefetch Data")
            
            # Load ShimCache Data
            loading_dialog.update_step(5, "🔄 Loading ShimCache data...")
            print("[ShimCache] Starting to load ShimCache Data...")
            self.load_shimcache_data()
            print("[ShimCache] Completed loading ShimCache Data")
            
            # Load Amcache Data
            loading_dialog.update_step(6, "🔄 Loading Amcache data...")
            print("[Amcache] Starting to load Amcache Data...")
            self.load_amcache_data()
            print("[Amcache] Completed loading Amcache Data")
            
            # Load RecycleBin Data
            loading_dialog.update_step(7, "🔄 Loading RecycleBin data...")
            print("[RecycleBin] Starting to load RecycleBin Data...")
            self.load_recyclebin_data()
            print("[RecycleBin] Completed loading RecycleBin Data")
            
            # Load Registry Data from DB
            loading_dialog.status_label.setText("Loading Registry Database...")
            QApplication.processEvents()
            print("[Registry] Starting to load Registry Database...")
            self.load_registry_data_from_db()
            print("[Registry] Completed loading Registry Database")
            
            # Load ShimCache Data
            loading_dialog.update_step(5, "🔄 Loading ShimCache data...")
            QApplication.processEvents()
            print("[ShimCache] Starting to load ShimCache Data...")
            self.load_shimcache_data()
            print("[ShimCache] Completed loading ShimCache Data")
            
            loading_dialog.status_label.setText("Data loading completed successfully!")
            QApplication.processEvents()
            
            print("\033[92m\nData has been loaded into the GUI Successfully\033[0m")
            
        except Exception as e:
            error_msg = f"Error loading data: {str(e)}"
            loading_dialog.status_label.setText(error_msg)
            print(f"[Error] {error_msg}")
            QApplication.processEvents()
            print(f"[Error] Failed to load data: {str(e)}")

    def on_log_message(self, category, message):
        """Handle log message signal"""
        # Format the message based on category
        if category == "Error":
            formatted_message = f"<span style='color:#ff5555;'>[ERROR] {message}</span>"
        elif category == "Warning":
            formatted_message = f"<span style='color:#ffaa00;'>[WARNING] {message}</span>"
        elif category == "Success":
            formatted_message = f"<span style='color:#55ff55;'>[SUCCESS] {message}</span>"
        else:
            formatted_message = f"<span style='color:#aaaaaa;'>[{category}]</span> {message}"
        
        # Add the message to the log display
        self.log_display.append(formatted_message)
        
        # Scroll to the bottom
        scrollbar = self.log_display.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
        
        # Process events to ensure the UI updates
        QApplication.processEvents()

    def export_table_to_json(self, table_widget, file_path=None):
        """Export the contents of a table widget to a JSON file"""
        try:
            # Get the data from the table
            data = []
            headers = []
            
            # Get headers
            for col in range(table_widget.columnCount()):
                header_item = table_widget.horizontalHeaderItem(col)
                if header_item:
                    headers.append(header_item.text())
                else:
                    headers.append(f"Column {col}")
            
            # Get data
            for row in range(table_widget.rowCount()):
                row_data = {}
                for col in range(table_widget.columnCount()):
                    item = table_widget.item(row, col)
                    if item:
                        row_data[headers[col]] = item.text()
                    else:
                        row_data[headers[col]] = ""
                data.append(row_data)
            
            # If no file path provided, ask user for one
            if not file_path:
                file_path, _ = QFileDialog.getSaveFileName(
                    self.main_window,
                    "Save JSON File",
                    "",
                    "JSON Files (*.json)"
                )
                
            if not file_path:  # User cancelled
                return False
                
            # Ensure file has .json extension
            if not file_path.lower().endswith('.json'):
                file_path += '.json'
                
            # Write to file
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=4, ensure_ascii=False)
                
            print(f"[Export] Successfully exported table to JSON: {file_path}")
            return True
            
        except Exception as e:
            print(f"[Export Error] Failed to export table to JSON: {str(e)}")
            QMessageBox.critical(
                self.main_window,
                "Export Error",
                f"Failed to export table to JSON: {str(e)}"
            )
            return False
    
    def export_table_to_csv(self, table_widget, file_path=None):
        """Export the contents of a table widget to a CSV file"""
        try:
            import csv
            
            # If no file path provided, ask user for one
            if not file_path:
                file_path, _ = QFileDialog.getSaveFileName(
                    self.main_window,
                    "Save CSV File",
                    "",
                    "CSV Files (*.csv)"
                )
                
            if not file_path:  # User cancelled
                return False
                
            # Ensure file has .csv extension
            if not file_path.lower().endswith('.csv'):
                file_path += '.csv'
                
            # Get headers
            headers = []
            for col in range(table_widget.columnCount()):
                header_item = table_widget.horizontalHeaderItem(col)
                if header_item:
                    headers.append(header_item.text())
                else:
                    headers.append(f"Column {col}")
            
            # Write to file
            with open(file_path, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(headers)
                
                # Write data rows
                for row in range(table_widget.rowCount()):
                    row_data = []
                    for col in range(table_widget.columnCount()):
                        item = table_widget.item(row, col)
                        if item:
                            row_data.append(item.text())
                        else:
                            row_data.append("")
                    writer.writerow(row_data)
            print(f"[Export] Successfully exported table to CSV: {file_path}")
            return True
            
        except Exception as e:
            print(f"[Export Error] Failed to export table to CSV: {str(e)}")
            QMessageBox.critical(
                self.main_window,
                "Export Error",
                f"Failed to export table to CSV: {str(e)}"
            )
            return False
    
    def export_all_tables(self):
        """Export all tables to JSON and CSV files"""
        try:
            # Ask user for export directory
            export_dir = QFileDialog.getExistingDirectory(
                self.main_window,
                "Select Export Directory",
                "",
                QFileDialog.ShowDirsOnly
            )
            
            if not export_dir:  # User cancelled
                return
                
            # Create a timestamp for the export
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # Create a subdirectory for this export
            export_subdir = os.path.join(export_dir, f"CrowEye_Export_{timestamp}")
            os.makedirs(export_subdir, exist_ok=True)
            
            # Define the tables to export
            tables = {
                "LNK_Files": self.LNK_table,
                "Custom_JumpLists": self.Clj_table,
                "Prefetch": self.Prefetch_table,
                "SystemLogs": self.SystemLogs_table,
                "SecurityLogs": self.SecurityLogs_table,
                "ApplicationLogs": self.AppLogs_table,
                "ComputerName": self.computerName_table,
                "TimeZone": self.TimeZone_table,
                "NetworkInterfaces": self.NetworkInterface_table,
                "NetworkLists": self.NetworkLists_table,
                "SystemServices": self.SystemServices_table,
                "MachineRun": self.MachineRun_table,
                "MachineRunOnce": self.MachineRunOnce_tabel,
                "UserRun": self.UserRun_table,
                "UserRunOnce": self.UserRunOnce_table,
                "LastUpdate": self.LastUpdate_table,
                "LastUpdateInfo": self.LastUpdateInfo_table,
                "ShutDown": self.ShutDown_table,
                "ShimCache": self.ShimCache_main_table,
                # Add Amcache tables
                "Amcache_Application": self.Amcache_InventoryApplication_table,
                "Amcache_ApplicationFile": self.Amcache_InventoryApplicationFile_table,
                "Amcache_ApplicationShortcut": self.Amcache_InventoryApplicationShortcut_table,
                "Amcache_DriverBinary": self.Amcache_InventoryDriverBinary_table,
                "Amcache_DriverPackage": self.Amcache_InventoryDriverPackage_table,
                "BrowserHistory": self.Browser_history_table,
                "USBDevices": self.USBDevices_table,
                "USBInstances": self.USBInstances_table,
                "USBProperties": self.USBProperties_table,
                "USBStorageDevices": self.USBStorageDevices_table,
                "USBStorageVolumes": self.USBStorageVolumes_table,
                "RecentDocs": self.RecentDocs_table,
                "SearchExplorer": self.SearchViaExplorer_table,
                "OpenSaveMRU": self.OpenSaveMRU_table,
                "LastSaveMRU": self.LastSaveMRU_table,
                "TypedPaths": self.TypedPath_table,
                "BAM": self.Bam_table,
                "DAM": self.Dam_table,
                "UserAssist": self.UserAssist_table,
                "Shellbags": self.Shellbags_table,
                "RunMRU": self.RunMRU_table,
                "MUICache": self.MUICache_table,
                "WordWheelQuery": self.WordWheelQuery_table,
                "InstalledSoftware": self.tableWidget
            }
            
            # Create subdirectories for JSON and CSV
            json_dir = os.path.join(export_subdir, "JSON")
            csv_dir = os.path.join(export_subdir, "CSV")
            os.makedirs(json_dir, exist_ok=True)
            os.makedirs(csv_dir, exist_ok=True)
            
            # Export each table
            exported_count = 0
            for table_name, table_widget in tables.items():
                # Skip empty tables
                if table_widget.rowCount() == 0:
                    print(f"[Export] Skipping empty table: {table_name}")
                    continue
                    
                # Export to JSON
                json_path = os.path.join(json_dir, f"{table_name}.json")
                if self.export_table_to_json(table_widget, json_path):
                    exported_count += 1
                    
                # Export to CSV
                csv_path = os.path.join(csv_dir, f"{table_name}.csv")
                if self.export_table_to_csv(table_widget, csv_path):
                    exported_count += 1
            
            # Create a summary file
            summary_path = os.path.join(export_subdir, "export_summary.txt")
            with open(summary_path, 'w', encoding='utf-8') as f:
                f.write(f"CrowEye Export Summary\n")
                f.write(f"=====================\n\n")
                f.write(f"Export Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                if hasattr(self, 'case_paths') and self.case_paths:
                    f.write(f"Case Name: {os.path.basename(self.case_paths['case_root'])}\n")
                f.write(f"Tables Exported: {len([t for t in tables.values() if t.rowCount() > 0])}\n")
                f.write(f"Total Files Created: {exported_count}\n\n")
                f.write(f"Files are available in JSON and CSV formats in the respective directories.\n")
            
            QMessageBox.information(
                self.main_window,
                "Export Complete",
                f"Successfully exported {exported_count} files to:\n{export_subdir}"
            )
            
        except Exception as e:
            print(f"[Export Error] Failed to export tables: {str(e)}")
            QMessageBox.critical(
                self.main_window,
                "Export Error",
                f"Failed to export tables: {str(e)}"
            )
    
    def open_timeline_dialog(self):
        """Open the timeline visualization dialog"""
        try:
            # Check if case is loaded
            if not hasattr(self, 'case_paths') or not self.case_paths:
                QMessageBox.warning(
                    self.main_window,
                    "No Case Loaded",
                    "Please load a case before opening the timeline."
                )
                return
            
            # Import timeline dialog
            from timeline.timeline_dialog import TimelineDialog
            
            # Create a wrapper that provides both QWidget parent and case_paths
            # TimelineDialog expects parent to have case_paths attribute
            # So we pass self (Ui_Crow_Eye) which has case_paths
            # But we need to make sure it's treated as a valid parent
            
            # Store reference to Ui object in main_window for timeline to access
            if not hasattr(self.main_window, 'ui'):
                self.main_window.ui = self
            
            # Create and show timeline dialog with main_window as parent
            timeline_dialog = TimelineDialog(self.main_window)
            timeline_dialog.exec_()
            
        except Exception as e:
            print(f"[Timeline Error] Failed to open timeline: {str(e)}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(
                self.main_window,
                "Timeline Error",
                f"Failed to open timeline: {str(e)}"
            )

                    
    def setup_search_ui(self):
        """Set up the search UI with filtering options"""
        # Create a layout for the search filter options
        self.search_filter_layout = QHBoxLayout()
        
        # Create a dropdown for table selection mode
        self.search_mode_combo = QComboBox()
        self.search_mode_combo.addItem("Search All Tables", "all")
        self.search_mode_combo.addItem("Search Selected Tables", "include")
        self.search_mode_combo.addItem("Search All Except Selected", "exclude")
        self.search_mode_combo.setToolTip("Select which tables to search in")
        self.search_mode_combo.currentIndexChanged.connect(self.update_search_table_selection)
        
        # Create a dropdown for table selection
        self.search_tables_combo = QComboBox()
        self.search_tables_combo.setEnabled(False)  # Initially disabled when "Search All Tables" is selected
        self.search_tables_combo.setToolTip("Select tables to include/exclude from search")
        
        # Add a button to add the selected table to the list
        self.add_table_button = QtWidgets.QPushButton("+")
        self.add_table_button.setEnabled(False)  # Initially disabled
        self.add_table_button.setToolTip("Add selected table to filter list")
        self.add_table_button.clicked.connect(self.add_table_to_filter)
        
        # Create a layout for the selected tables
        self.selected_tables_layout = QVBoxLayout()
        self.selected_tables_frame = QFrame()
        self.selected_tables_frame.setLayout(self.selected_tables_layout)
        self.selected_tables_frame.setVisible(False)  # Initially hidden
        
        # Add the widgets to the search filter layout
        self.search_filter_layout.addWidget(self.search_mode_combo)
        self.search_filter_layout.addWidget(self.search_tables_combo)
        self.search_filter_layout.addWidget(self.add_table_button)
        
        # Add the search filter layout to the main search layout
        self.search_layout.insertLayout(1, self.search_filter_layout)
        self.search_layout.insertWidget(2, self.selected_tables_frame)
        
        # Populate the tables dropdown
        self.populate_tables_dropdown()
    
    def populate_tables_dropdown(self):
        """Populate the tables dropdown with all available tables"""
        self.search_tables_combo.clear()
        table_names = SearchUtils.get_table_names(self)
        for table_name in sorted(table_names):
            self.search_tables_combo.addItem(table_name)
    
    def update_search_table_selection(self):
        """Update the UI based on the selected search mode"""
        mode = self.search_mode_combo.currentData()
        if mode == "all":
            self.search_tables_combo.setEnabled(False)
            self.add_table_button.setEnabled(False)
            self.selected_tables_frame.setVisible(False)
        else:  # "include" or "exclude"
            self.search_tables_combo.setEnabled(True)
            self.add_table_button.setEnabled(True)
            self.selected_tables_frame.setVisible(True)
    
    def add_table_to_filter(self):
        """Add the selected table to the filter list"""
        table_name = self.search_tables_combo.currentText()
        if not table_name:
            return
            
        # Check if this table is already in the list
        for i in range(self.selected_tables_layout.count()):
            widget = self.selected_tables_layout.itemAt(i).widget()
            if isinstance(widget, QHBoxLayout):
                label = widget.itemAt(0).widget()
                if label.text() == table_name:
                    return  # Table already in the list
        
        # Create a layout for this table entry
        table_layout = QHBoxLayout()
        
        # Add a label with the table name
        label = QLabel(table_name)
        
        # Add a remove button
        remove_button = QtWidgets.QPushButton("X")
        remove_button.setMaximumWidth(30)
        remove_button.clicked.connect(lambda: self.remove_table_from_filter(table_layout))
        
        # Add the widgets to the layout
        table_layout.addWidget(label)
        table_layout.addWidget(remove_button)
        
        # Create a widget to hold this layout
        table_widget = QWidget()
        table_widget.setLayout(table_layout)
        
        # Add the widget to the selected tables layout
        self.selected_tables_layout.addWidget(table_widget)
    
    def remove_table_from_filter(self, layout):
        """Remove a table from the filter list"""
        # Find the widget that contains this layout
        for i in range(self.selected_tables_layout.count()):
            widget = self.selected_tables_layout.itemAt(i).widget()
            if widget.layout() == layout:
                # Remove the widget from the layout
                self.selected_tables_layout.removeWidget(widget)
                # Delete the widget
                widget.deleteLater()
                break
    
    def get_filtered_tables(self):
        """Get the list of tables to include or exclude based on the filter settings"""
        try:
            # Check if we have selected tables from the filter dialog
            if hasattr(self, 'selected_tables') and self.selected_tables:
                print(f"DEBUG: Using selected tables from filter dialog: {self.selected_tables}")
                return self.selected_tables, None  # Include only these tables
            
            # Legacy code for backward compatibility
            # Check if search_mode_combo exists
            if hasattr(self, 'search_mode_combo'):
                mode = self.search_mode_combo.currentData()
            else:
                print("DEBUG: search_mode_combo not found, defaulting to 'all' mode")
                return None, None  # Default to searching all tables
                
            if mode == "all":
                return None, None  # No filtering
            
            # Get the list of selected tables
            selected_tables = []
            if hasattr(self, 'selected_tables_layout'):
                for i in range(self.selected_tables_layout.count()):
                    widget = self.selected_tables_layout.itemAt(i).widget()
                    if widget:
                        label = widget.layout().itemAt(0).widget()
                        selected_tables.append(label.text())
            else:
                print("DEBUG: selected_tables_layout not found")
                return None, None  # Default to searching all tables
            
            if mode == "include":
                return selected_tables, None  # Include only these tables
            else:  # mode == "exclude":
                return None, selected_tables  # Exclude these tables
        except Exception as e:
            print(f"ERROR in get_filtered_tables: {str(e)}")
            import traceback
            traceback.print_exc()
            return None, None  # Default to searching all tables
    
    def open_filter_dialog(self):
        """Open the search filter dialog to select tables and time range"""
        try:
            # Pass the current filter settings to the dialog if available
            selected_tables = getattr(self, 'selected_tables', None)
            start_time = None
            end_time = None
            
            # Convert datetime objects to string format if they exist
            if hasattr(self, 'start_time') and self.start_time:
                start_time = self.start_time.isoformat().replace(' ', 'T')
            if hasattr(self, 'end_time') and self.end_time:
                end_time = self.end_time.isoformat().replace(' ', 'T')
            
            # Create the dialog with saved settings
            dialog = SearchFilterDialog(self.main_window, selected_tables, start_time, end_time)
            
            # Connect the filterApplied signal to handle the filter parameters
            dialog.filterApplied.connect(self.apply_search_filter)
            dialog.exec_()
        except Exception as e:
            print(f"ERROR in open_filter_dialog: {str(e)}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self.main_window, "Filter Error", f"An error occurred opening filter dialog: {str(e)}")
    
    def apply_search_filter(self, selected_tables, start_time, end_time):
        """Apply the filter parameters from the dialog"""
        try:
            # Store the filter parameters for use in search_tables
            self.selected_tables = selected_tables
            
            # Convert string dates to datetime objects if they exist
            if start_time:
                from datetime import datetime
                try:
                    # Parse ISO format (YYYY-MM-DDTHH:MM:SS)
                    self.start_time = datetime.fromisoformat(start_time.replace('T', ' '))
                except ValueError:
                    print(f"ERROR: Could not parse start_time: {start_time}")
                    self.start_time = None
            else:
                self.start_time = None
                
            if end_time:
                from datetime import datetime
                try:
                    # Parse ISO format (YYYY-MM-DDTHH:MM:SS)
                    self.end_time = datetime.fromisoformat(end_time.replace('T', ' '))
                except ValueError:
                    print(f"ERROR: Could not parse end_time: {end_time}")
                    self.end_time = None
            else:
                self.end_time = None
            
            # Update the filter button style to indicate filtering is active
            if selected_tables or start_time or end_time:
                self.filter_button.setStyleSheet(CrowEyeStyles.FILTER_BUTTON + "background-color: #2a3990;")
            else:
                self.filter_button.setStyleSheet(CrowEyeStyles.FILTER_BUTTON)
                
            # If there's text in the search input, perform a search with the new filters
            if self.search_input.text().strip():
                self.search_tables()
        except Exception as e:
            print(f"ERROR in apply_search_filter: {str(e)}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self.main_window, "Filter Error", f"An error occurred applying filter: {str(e)}")
    
    def search_tables(self):
        """Search for text in tables with filtering options"""
        try:
            search_text = self.search_input.text().strip()
            print(f"DEBUG: search_tables called with search_text: '{search_text}'")
            if not search_text:
                QMessageBox.information(self.main_window, "Search", "Please enter text to search for.")
                return

            self.loading_label.show()
            self.loading_movie.start()
            self.clear_search_results()

            # Get tables and filter settings
            tables = SearchUtils.find_all_table_widgets(self)
            include_tables, exclude_tables = self.get_filtered_tables()
            
            # Get time filter settings if available
            start_time = getattr(self, 'start_time', None)
            end_time = getattr(self, 'end_time', None)
            
            print(f"DEBUG: Found {len(tables)} tables to search.")
            if include_tables:
                print(f"DEBUG: Including only these tables: {include_tables}")
            if exclude_tables:
                print(f"DEBUG: Excluding these tables: {exclude_tables}")
            if start_time:
                print(f"DEBUG: Filtering from time: {start_time}")
            if end_time:
                print(f"DEBUG: Filtering to time: {end_time}")

            # Ensure highlight_queue exists
            if not hasattr(self, 'highlight_queue'):
                self.highlight_queue = collections.deque()
                
            # Ensure is_processing_highlight flag exists
            if not hasattr(self, 'is_processing_highlight'):
                self.is_processing_highlight = False

            self.thread = QtCore.QThread()
            # Import SearchWorker from utils.search_utils
            from utils.search_utils import SearchWorker
            self.worker = SearchWorker(tables, search_text, include_tables, exclude_tables, start_time, end_time)
            self.worker.moveToThread(self.thread)
            self.thread.started.connect(self.worker.run)
            self.worker.finished.connect(self.on_search_finished)
            self.worker.finished.connect(self.thread.quit)
            self.worker.finished.connect(self.worker.deleteLater)
            self.thread.finished.connect(self.thread.deleteLater)
            self.thread.start()
        except Exception as e:
            print(f"ERROR in search_tables: {str(e)}")
            import traceback
            traceback.print_exc()
            self.loading_movie.stop()
            self.loading_label.hide()
            QMessageBox.critical(self.main_window, "Search Error", f"An error occurred during search: {str(e)}")
            return

    def on_search_finished(self, results):
        try:
            self.search_results = results
            print(f"DEBUG: on_search_finished called with {len(self.search_results)} results.")
            self.loading_movie.stop()
            self.loading_label.hide()

            # Ensure highlight_queue exists
            if not hasattr(self, 'highlight_queue'):
                self.highlight_queue = collections.deque()
            else:
                # Clear any existing highlights and queue
                self.highlight_queue.clear()
            
            if self.search_results:
                # Initialize the current result index
                self.current_result_index = 0
                print(f"DEBUG: Initial current_result_index: {self.current_result_index}")
                
                # Update the search result label
                self.update_search_result_label()
                
                # Enable navigation buttons
                if hasattr(self, 'prev_result_button'):
                    self.prev_result_button.setEnabled(len(self.search_results) > 1)
                if hasattr(self, 'next_result_button'):
                    self.next_result_button.setEnabled(len(self.search_results) > 1)
                if hasattr(self, '_search_button'):
                    self._search_button.setEnabled(True)
                    
                # Trigger highlighting of the first result
                self.highlight_current_result()
                
                # Show message after highlighting is queued
                QMessageBox.information(self.main_window, "Search Results",
                                      f"Found {len(self.search_results)} matches.")
            else:
                # No results found
                self.search_label.setText("Search:")
                QMessageBox.information(self.main_window, "Search Results", "No matches found.")
                if hasattr(self, 'prev_result_button'):
                    self.prev_result_button.setEnabled(False)
                if hasattr(self, 'next_result_button'):
                    self.next_result_button.setEnabled(False)
                if hasattr(self, '_search_button'):
                    self._search_button.setEnabled(False)
        except Exception as e:
            print(f"ERROR in on_search_finished: {str(e)}")
            import traceback
            traceback.print_exc()
            self.loading_movie.stop()
            self.loading_label.hide()
            QMessageBox.critical(self.main_window, "Search Error", f"An error occurred while processing search results: {str(e)}")
            return

    
    def find_all_table_widgets(self):
        """Find all QTableWidget instances in the application"""
        # Use the SearchUtils class to find all table widgets
        return SearchUtils.find_all_table_widgets(self)
        
    def enable_sorting_for_all_tables(self):
        """Enable sorting for all table widgets in the application"""
        tables = self.find_all_table_widgets()
        for table in tables:
            # Enable sorting for the table
            table.setSortingEnabled(True)
            
            # Apply header styling to show sort indicators better
            header = table.horizontalHeader()
            header.setHighlightSections(True)
            
            # Set header style to make sort indicators more visible - use UNIFIED_TABLE_STYLE for consistency
            header.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
            
            # Connect header click event to sort indicator update
            header.sectionClicked.connect(lambda logicalIndex, table=table: 
                                         self.update_sort_indicator(table, logicalIndex))
    
    def update_sort_indicator(self, table, column_index):
        """Update the sort indicator when a column header is clicked"""
        # Get the current sort order
        header = table.horizontalHeader()
        
        # Toggle sort order
        if header.sortIndicatorSection() == column_index:
            # If clicking the same column, toggle the sort order
            if header.sortIndicatorOrder() == Qt.AscendingOrder:
                table.sortItems(column_index, Qt.DescendingOrder)
            else:
                table.sortItems(column_index, Qt.AscendingOrder)
        else:
            # If clicking a different column, default to ascending order
            table.sortItems(column_index, Qt.AscendingOrder)
    
    def highlight_current_result(self, process_immediately=False):
        """Adds a highlight request to the queue.
        
        Args:
            process_immediately (bool): If True, process the highlight immediately instead of waiting for the timer.
            
        Returns:
            bool: True if a highlight request was added to the queue, False otherwise.
        """
        try:
            # Check if search_results exists and is valid
            if not hasattr(self, 'search_results') or not self.search_results:
                print("DEBUG: No search results available for highlighting")
                return False
                
            # Check if current_result_index exists and is valid
            if not hasattr(self, 'current_result_index'):
                print("DEBUG: current_result_index not found")
                return False
                
            # Check if we have valid search results
            if 0 <= self.current_result_index < len(self.search_results):
                result = self.search_results[self.current_result_index]
                
                # Validate result format
                if not isinstance(result, tuple) or len(result) not in [2, 3]:  # Accept both (table, row) and (table, row, col)
                    print(f"DEBUG: Invalid result format: {result}")
                    return False
                
                # Handle both new (table, row) and old (table, row, col) formats
                if len(result) == 2:
                    table, row = result
                else:  # len(result) == 3
                    table, row, _ = result  # Ignore column
                
                # Add to queue if not processing immediately
                if not process_immediately:
                    # Ensure highlight_queue exists
                    if not hasattr(self, 'highlight_queue'):
                        self.highlight_queue = collections.deque()
                    
                    # Add to queue
                    self.highlight_queue.append((table, row))
                    return True
                else:
                    # Process immediately
                    result = SearchUtils.highlight_search_result(self, table, row, process_immediately)
                    # Update the search result counter display
                    self.update_search_result_label()
                    return result
            else:
                print(f"DEBUG: current_result_index {self.current_result_index} out of range for search_results length {len(self.search_results)}")
            return False
        except Exception as e:
            print(f"ERROR in highlight_current_result: {str(e)}")
            import traceback
            traceback.print_exc()
            return False

    def process_highlight_queue(self, force=False):
        """Processes one highlight request from the queue.
        
        Args:
            force (bool): If True, process the queue even if is_processing_highlight is True.
        """
        try:
            # Use SearchUtils to process the highlight queue
            SearchUtils.process_highlight_queue(self, force)
        except Exception as e:
            print(f"ERROR in process_highlight_queue: {str(e)}")
            import traceback
            traceback.print_exc()
            # Reset processing flag if it exists
            if hasattr(self, 'is_processing_highlight'):
                self.is_processing_highlight = False

    def update_search_result_label(self):
        try:
            # Check if search_results exists
            if not hasattr(self, 'search_results'):
                print("DEBUG: search_results not found in update_search_result_label")
                self.search_label.setText("Search:")
                return
                
            if self.search_results:
                # Check if current_result_index exists
                if not hasattr(self, 'current_result_index'):
                    print("DEBUG: current_result_index not found in update_search_result_label")
                    self.search_label.setText(f"Found {len(self.search_results)} results")
                    return
                    
                self.search_label.setText(f"Result {self.current_result_index + 1} of {len(self.search_results)}")
            else:
                self.search_label.setText("Search:")
        except Exception as e:
            print(f"ERROR in update_search_result_label: {str(e)}")
            import traceback
            traceback.print_exc()
            # Set a safe default
            self.search_label.setText("Search:")
            return
    
    def make_table_visible(self, table):
        """Make the table visible by switching to its tab, handling nested tabs."""
        # Use the SearchUtils class to make the table visible
        return SearchUtils.make_table_visible(self, table)
    
    def _check_table_visibility(self, table):
        """Check if a table is visible after a delay and log the result."""
        if table.isVisible():
            print(f"DEBUG: Table {table.objectName()} is now visible after delay")
        else:
            print(f"WARNING: Table {table.objectName()} is still not visible after delay")
    
    def go_to_next_result(self):
        """Navigate to the next search result"""
        if self.search_results and len(self.search_results) > 0:
            self.current_result_index = (self.current_result_index + 1) % len(self.search_results)
            print(f"DEBUG: go_to_next_result - new index: {self.current_result_index}")
            # Process the highlight immediately
            self.highlight_current_result(process_immediately=True)
            # Update the search result counter display
            self.update_search_result_label()
    
    def go_to_previous_result(self):
        """Navigate to the previous search result"""
        if self.search_results and len(self.search_results) > 0:
            self.current_result_index = (self.current_result_index - 1 + len(self.search_results)) % len(self.search_results)
            print(f"DEBUG: go_to_previous_result - new index: {self.current_result_index}")
            # Process the highlight immediately
            self.highlight_current_result(process_immediately=True)
            # Update the search result counter display
            self.update_search_result_label()
    
    def clear_search_results(self):
        """Clear all search results and highlighting"""
        print("DEBUG: Clearing all search results")
        
        # Use SearchUtils to clear search results
        SearchUtils.clear_search_results(self)
        
        # Reset search results
        self.search_results = []
        self.current_result_index = -1
        
        # Update navigation buttons
        if hasattr(self, 'prev_result_button'):
            self.prev_result_button.setEnabled(False)
        if hasattr(self, 'next_result_button'):
            self.next_result_button.setEnabled(False)
        if hasattr(self, '_search_button'):
            self._search_button.setEnabled(False)
                    

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Crow_Eye = QtWidgets.QMainWindow()
    ui = Ui_Crow_Eye()
    ui.setupUi(Crow_Eye)
    
    # Set window state to maximized before showing
    Crow_Eye.show()
    screen = QtWidgets.QApplication.primaryScreen().availableGeometry()
    Crow_Eye.setGeometry(screen)
    Crow_Eye.setWindowState(QtCore.Qt.WindowMaximized)
    
    # Connect double-click events to all table widgets
    from ui.row_detail_dialog_handler import connect_table_double_click_events
    connect_table_double_click_events(ui)
    
    # Try to load the last case first
    # load_last_case will only return False if there's no last case file
    # or if the case directory doesn't exist
    last_case_loaded = ui.load_last_case()
    
    # Only show the case dialog if there's no last case to load
    if not last_case_loaded:
        print("[Info] No valid last case found. Showing case dialog.")
        # Show dialog to create new case or open existing one
        ui.show_case_dialog()
    
    sys.exit(app.exec_())
